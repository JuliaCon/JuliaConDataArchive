{"schedule": {"version": "0.25", "base_url": "https://pretalx.com/juliacon2021/schedule/", "conference": {"acronym": "juliacon2021", "title": "JuliaCon 2021 (times are UTC)", "start": "2021-07-20", "end": "2021-07-30", "daysCount": 11, "timeslot_duration": "00:05", "days": [{"index": 1, "date": "2021-07-20", "day_start": "2021-07-20T04:00:00+00:00", "day_end": "2021-07-21T03:59:00+00:00", "rooms": {"Green": [{"id": 9709, "guid": "d9be87b5-4c8e-5343-abc6-e619ec978c84", "logo": "", "date": "2021-07-20T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Green", "slug": "juliacon2021-9709-gpu-programming-in-julia", "url": "https://pretalx.com/juliacon2021/talk/VK87Q3/", "title": "GPU programming in Julia", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "In this workshop, we will demonstrate three major packages for programming GPUs in Julia (CUDA.jl, AMDGPU.jl, oneAPI.jl), and the different programming models, tools and APIs that these packages support.", "description": "Julia has several packages for programming GPUs, each of which support various programming models. In this workshop, we will demonstrate the use of three major GPU programming packages: CUDA.jl for NVIDIA GPUs, AMDGPU.jl for AMD GPUs, and oneAPI.jl for Intel GPUs. We will explain the various approaches for programming GPUs with these packages, ranging from generic array operations that focus on ease-of-use, to hardware-specific kernels for when performance matters.\r\n\r\nMost of the workshop will be vendor-neutral, and the content will be available for all supported GPU back-ends. There will also be a part on vendor-specific tools and APIs.\r\n\r\nAttendees will be able to follow along, but are recommended to have access to a suitable GPU for doing so. Material for this workshop can be found at https://github.com/maleadt/juliacon21-gpu_workshop", "recording_license": "", "do_not_record": false, "persons": [{"id": 2402, "code": "9YQMAK", "public_name": "Tim Besard", "biography": "I'm a software engineer at Julia Computing, working on Julia's GPU packages and compilers.", "answers": []}, {"id": 4385, "code": "GRFD9D", "public_name": "Julian P Samaroo", "biography": "I am an HPC software engineer working at the JuliaLab. I maintain Dagger.jl, AMDGPU.jl, and BPFnative.jl, and generally enjoy the challenge of hacking on compilers and HPC runtimes.", "answers": []}, {"id": 903, "code": "3C7UBC", "public_name": "Valentin Churavy", "biography": "PhD Student at MIT", "answers": []}], "links": [], "attachments": [], "answers": []}], "Red": [{"id": 9235, "guid": "ee7a58ff-16ec-5fb1-9756-2be0d0501826", "logo": "", "date": "2021-07-20T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Red", "slug": "juliacon2021-9235-dataframes-jl-1-2-tutorial", "url": "https://pretalx.com/juliacon2021/talk/FXZXMB/", "title": "DataFrames.jl 1.2 tutorial", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "In this workshop an introduction to DataFrames.jl 1.2 will be presented. You will learn how to load, transform and visualize your data using the DataFrames.jl package. The tutorial assumes that you have some experience in working with data frames in e.g. R or Python.\r\n\r\nAll the materials used are available for download at https://github.com/bkamins/JuliaCon2021-DataFrames-Tutorial.", "description": "In this workshop an introduction to DataFrames.jl 1.2 will be presented.\r\n\r\nThe tutorial is targeted at people wanting to start using DataFrames.jl. However, it assumes that you have some experience in working with data frames in e.g. R or Python. The tutorial presents an example of doing a small data science project.\r\n\r\nThe topics covered are:\r\n\r\n* creating a `DataFrame` object and getting basic information about it\r\n* reading and writing data frames using [CSV.jl](https://github.com/JuliaData/CSV.jl) and [Arrow.jl](https://github.com/JuliaData/Arrow.jl)\r\n* indexing and filtering\r\n* sorting\r\n* joining\r\n* reshaping\r\n* transforming columns and aggregation\r\n* plotting\r\n* building predictive models\r\n* bootstrapping\r\n\r\nAll the materials used are available for download at https://github.com/bkamins/JuliaCon2021-DataFrames-Tutorial.", "recording_license": "", "do_not_record": false, "persons": [{"id": 929, "code": "DHRPEA", "public_name": "Bogumi\u0142 Kami\u0144ski", "biography": "I am a researcher in the fields of operations research and computational social science.\r\nFor development I use the Julia language. I currently mostly contribute to DataFrames.jl and related packages.", "answers": []}], "links": [], "attachments": [], "answers": []}]}}, {"index": 2, "date": "2021-07-21", "day_start": "2021-07-21T04:00:00+00:00", "day_end": "2021-07-22T03:59:00+00:00", "rooms": {"Green": [{"id": 9773, "guid": "9015e174-872a-5389-a4f6-b45f6c23fb8f", "logo": "", "date": "2021-07-21T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Green", "slug": "juliacon2021-9773-quantum-computing-with-julia", "url": "https://pretalx.com/juliacon2021/talk/V3N73B/", "title": "Quantum Computing with Julia", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "Quantum computing is an emerging area of the technology industry with applicability to many different fields. But it\u2019s not obvious how to get started with quantum hardware or quantum algorithms. In this workshop, we\u2019ll use Julia to introduce attendees to quantum computing, creating state of the art quantum machine learning models and solving real-world optimization problems on a real quantum device or a quantum circuit simulators using Amazon Braket.", "description": "In this two part workshop we will use Amazon Braket with Julia to introduce attendees to the exciting world of quantum computing. Getting started in QC can be daunting if you\u2019re not already an expert in physics or CS. We\u2019ll spend the first part of the workshop getting acquainted with the different types of quantum hardware available today and some introductory algorithms, which we\u2019ll run on real quantum computers and simulators. Then we\u2019ll build upon this and begin exploring using quantum hardware to tackle machine learning and optimization problems.\r\n\r\nIn order to access the quantum hardware and simulators during the workshop, we\u2019ll be using Amazon Braket, which is a fully managed quantum computing service that helps researchers and developers get started with the technology to accelerate research and discovery.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10387, "code": "N9LFTG", "public_name": "Saravana Kumar", "biography": "I'm a software engineer at Amazon working on Amazon Braket, a managed quantum computing platform. I graduated from The Ohio State University with a Master's in Computer Science in August 2019. I worked on high performance computing for representation learning in graphs at the Data Mining Research Laboratory at OSU. I dabble in quantum computing, graphs, high performance computing and most recently in serverless compute.", "answers": []}, {"id": 4379, "code": "YYDPCZ", "public_name": "Katharine Hyatt", "biography": "I am a longtime Julia contributor with a special interest in GPU programming and HPC. I currently work at Amazon Braket as a scientist.", "answers": []}], "links": [], "attachments": [], "answers": []}], "Red": [{"id": 9006, "guid": "8176d6f1-5e52-5de2-9cbd-f33bbe7ca0d2", "logo": "/media/juliacon2021/submissions/A9KZCY/3-32_mAYZchl.png", "date": "2021-07-21T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Red", "slug": "juliacon2021-9006-statistics-with-julia-from-the-ground-up", "url": "https://pretalx.com/juliacon2021/talk/A9KZCY/", "title": "Statistics with Julia from the ground up", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "This workshop provides an introduction to the Julia language for data-scientists and statisticians. No prior experience with Julia is assumed. The workshop starts with a few Julia basics and then progresses through basic probability and statistics examples, usage of dataframes, elementary statistical inference, regression, and more advanced methods. At the end of this workshop, attendees will have solid entry point for using Julia as their preferred data analysis tool.", "description": "This workshop accommodates data-scientists and statisticians that have experience with a language like R, but have not used Julia previously. In learning to use Julia, a contemporary \"stats based\" approach is taken focusing on short scripts that achieve concrete goals. The primary focus is on statistical applications and packages. The Julia language is covered as a by-product of the applications. Thus, this workshop is much more of a *how to use Julia for stats* course than a *how to program in Julia* course. This approach may be suitable for statisticians and data-scientists that tend to do their day-to-day scripting with a data and model based approach - as opposed to a software development approach. \r\n\r\nThe topics covered include:\r\n\r\n* Basic probability and Monte Carlo.\r\n* Basics from the in-built Statistics package and the [StatsBase](https://juliastats.org/StatsBase.jl/stable/) package.\r\n* Basic plotting and statistical plotting with [StatsPlots](https://github.com/JuliaPlots/StatsPlots.jl).\r\n* Using the [Distributions](https://juliastats.org/Distributions.jl/latest/) package.\r\n* (Basic) usage of the [Dataframes](https://dataframes.juliadata.org/stable/) package.\r\n* Using the [GLM](https://juliastats.org/GLM.jl/stable/) package.\r\n* Other useful resources and packages.\r\n\r\n(Note that Julia has hundreds of statistical packages and we can not cover them all in 3 hours).\r\n\r\nCode snippets from [Statistics with Julia: Fundamentals for Data Science, Machine Learning and Artificial Intelligence](https://statisticswithjulia.org/) will be used in conjunction with smaller live constructed examples.\r\n\r\nAn extensive Jupyter notebook for the workshop together with data files is [here](https://github.com/yoninazarathy/JuliaCon2021-StatisticsWithJuliaFromTheGroundUp). You can install it to follow along.\r\n\r\nIf you don't have Julia with IJulia (Jupyter) installed, you can follow the instructions in [this video](https://www.youtube.com/watch?v=KJleqSITuRo).", "recording_license": "", "do_not_record": false, "persons": [{"id": 9298, "code": "777AC8", "public_name": "Yoni Nazarathy", "biography": "Associate Professor [Yoni Nazarathy](https://yoninazarathy.com/) from the University of Queensland Australia, specializes in data science, probability and statistics. His specific research interests include scheduling, control, queueing theory, and machine learning. He has been at The University of Queensland for nearly a decade, teaching courses in the Masters of Data Science program and working on research. Prior to his previous academic positions in Melbourne and the Netherlands, he worked in the aerospace industry in Israel. In recent years, he has also been heavily involved with primary and secondary mathematics education and is the co-founder of an EdTech mathematics organization called One on Epsilon. He is also the co-author of a data science book, \"Statistics with Julia: Fundamentals for Data Science, Machine Learning and Artificial Intelligence\". Recently his research has also focused on epidemics and he leads the [Safe Blues](https://safeblues.org/) program dealing with finding efficient and ethical methods to track social mobility with a goal of prediction and control of epidemics.", "answers": []}], "links": [], "attachments": [], "answers": []}]}}, {"index": 3, "date": "2021-07-22", "day_start": "2021-07-22T04:00:00+00:00", "day_end": "2021-07-23T03:59:00+00:00", "rooms": {"Green": [{"id": 9568, "guid": "689716be-b7c8-58b4-bb7c-21a4be86ef90", "logo": "", "date": "2021-07-22T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Green", "slug": "juliacon2021-9568-a-mathematical-look-at-electronic-structure-theory", "url": "https://pretalx.com/juliacon2021/talk/KK9KS7/", "title": "A mathematical look at electronic structure theory", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "Electronic structure theory is a fascinating interdisciplinary field. Physics, chemistry, materials science, mathematics, high-performance computing ... they're all in it. Rooted at the quantum-mechanical description of electrons it is the backbone for quite a few simulation methods in the chemical and physical sciences. Here we'll focus on the numerical tools required to solve standard problems in the field like density-functional theory, which --- as we will see --- is challenging in itself.", "description": "### Content\r\nThe material for the workshop is available at https://github.com/mfherbst/juliacon_dft_workshop.\r\n\r\nI'll briefly introduce the setting of density-functional theory (DFT), in particular show the equation system and its mathematical structure. With that we are in good shape to tackle the main part of the workshop, which will be devoted to discussing the numerical techniques used for solving it. \r\n\r\nOur main tool in this workshop will be the [density-functional toolkit (DFTK)](https://dftk.org),\r\na state-of-the-art DFT code written in Julia (of course ;)). This code will allow us to consider a number of reduced problems, where things are more tractable if you wish to interactively explore, visualise and understand. In particular we will use DFTK to inspect what's going on while the  DFT problem is being solved. With that knowledge at hand we'll try to code up some simple DFT solvers on our own. Due to  the scaffolding DFTK provides this is a fairly manageable task and (as a small bonus) the resulting algorithms could be directly applied to cutting edge problems (if we're careful with performance issues).\r\n\r\nDepending on how our progress is I plan to cover the following topics:\r\n  - Problem setup: Mathematical structure of DFT \r\n  - Typical discretisation approaches: Gaussians versus plane waves\r\n  - Typical solution algorithms: Direct minimisation versus self-consistent field (SCF) iterations\r\n  - Numerical analysis of SCF problems\r\n  - Writing our own SCF, understanding why it badly fails and what we can do about it. \r\n  - Connections between the physical properties of matter and convergence properties of an SCF\r\n\r\n### Assumed background\r\nI'll try to do my best to make this workshop accessible for a broad range of people: Those with the chemistry or physics background that always wanted to understand the maths behind DFT as well as those with the understanding on PDEs / linear algebra that are interested in getting an idea about this challenging application domain.\r\n\r\nI will assume you safely know your way around Julia.", "recording_license": "", "do_not_record": false, "persons": [{"id": 3526, "code": "DZ7WHZ", "public_name": "Michael F. Herbst", "biography": "By training a chemist, who got more and more twisted towards the \"dark side\" of numerical analysis. Now working as a PostDoc at the [Applied and Computational Mathematics](http://www.acom.rwth-aachen.de) lab of RWTH Aachen University, Germany. Lead developer of [DFTK](https://dftk.org), a Julia code for mathematical research in on density-functional theory (a quantum chemistry method).", "answers": []}], "links": [], "attachments": [], "answers": []}], "Red": [{"id": 9945, "guid": "bbe3f601-08ad-5ba6-ae2d-b11fd3c89756", "logo": "", "date": "2021-07-22T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Red", "slug": "juliacon2021-9945-game-development-in-julia-with-gamezero-jl", "url": "https://pretalx.com/juliacon2021/talk/RS9B7Q/", "title": "Game development in Julia with GameZero.jl", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "A game development workshop where participants will create a few simple games, inspired by classic games from the early days of computing. This workshop is suitable for beginner programmers, or for experienced coders hoping to teach programming to younger people. Or for anyone wanting to have some fun while programming.\r\n\r\nPlease add the GameZero and Colors package to a julia environment.", "description": "Developing simple games is one the most effective ways to learning, and teaching, programming. GameZero.jl is a low-overhead game development framework, that allows beginners and students to learn programming while having a lot of fun. \r\n\r\nWe will describe the simple API exposed by GameZero, and then build up a couple of games using these building blocks. By the end of the session, participants will have one fully functional game working, and will have the building blocks to create the second. On the way, we will also describe the basic syntax and semantics of Julia and its standar library for users who are unfamiliar with it.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1163, "code": "JR9GPS", "public_name": "Avik Sengupta", "biography": "Avik Sengupta is the head of product development and software engineering at Julia Computing, contributor to open source Julia and maintainer of several Julia packages, including JavaCall, TextAnalysis and GameZero. Avik is the author of Julia High Performance, co-founder of two artificial intelligence start-ups in the financial services sector and creator of large complex trading systems for the world's leading investment banks.", "answers": []}, {"id": 944, "code": "A3J7CA", "public_name": "Ahan Sengupta", "biography": "I am a 15-year-old student, currently attending the City of London School. I have always had a deep interest in programming, first starting with Scratch when I was quite young, then moving onto Python, then finally, a few years ago, Julia. I have since presented at JuliaCon 2018, 2019 and 2020 and therefore have some experience with the language.", "answers": []}], "links": [], "attachments": [], "answers": []}]}}, {"index": 4, "date": "2021-07-23", "day_start": "2021-07-23T04:00:00+00:00", "day_end": "2021-07-24T03:59:00+00:00", "rooms": {"Green": [{"id": 9444, "guid": "1d8c512e-2c58-5c55-8f1a-61cb3ef88a09", "logo": "", "date": "2021-07-23T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Green", "slug": "juliacon2021-9444-solving-differential-equations-in-parallel-on-gpus", "url": "https://pretalx.com/juliacon2021/talk/CPH7SG/", "title": "Solving differential equations in parallel on GPUs", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "Why to wait hours for computations to complete, when it could take only a few seconds? Tired of prototyping code in an interactive, high-level language and rewriting it in a lower-level language to get high-performance code? Or simply curious about parallel and GPU computing being game changers.", "description": "The workshop materials can be found here: https://github.com/luraess/parallel-gpu-workshop-JuliaCon21\r\n\r\nThis workshop covers trendy areas in modern numerical computing with examples from geoscientific applications. The physical processes governing natural systems' evolution are often mathematically described as systems of differential equations. Fast and accurate solutions require numerical implementations to leverage modern parallel hardware.\r\n\r\nThe goal of this workshop is to offer an interactive hands-on to solve systems of differential equations in parallel on GPUs using the [`ParallelStencil.jl`](https://github.com/omlins/ParallelStencil.jl) and [`ImplicitGlobalGrid.jl`](https://github.com/eth-cscs/ImplicitGlobalGrid.jl) Julia modules. [`ParallelStencil.jl`](https://github.com/omlins/ParallelStencil.jl) permits to write architecture-agnostic parallel high-performance GPU and CPU code and [`ImplicitGlobalGrid.jl`](https://github.com/eth-cscs/ImplicitGlobalGrid.jl) renders stencil-based distributed parallelisation almost trivial. The resulting codes are fast, short and readable. We will use these two Julia modules to design and implement a (multi-) GPU application that predicts ice flow dynamics over mountainous topography.\r\n\r\nThe workshop consists of 2 parts:\r\n1. You will learn about parallel and distributed computing and iterative solvers.\r\n2. You will implement a PDE solver to predict ice flow dynamics on real topography.\r\n\r\nBy the end of this workshop, you will:\r\n- Have a GPU PDE solver that predicts ice-flow;\r\n- Have a concise Julia code that achieves similar performance than legacy C, CUDA, MPI code;\r\n- Be able to leverage the computing power of modern GPU accelerated servers and supercomputers.\r\n\r\nWe look forward to having you on board and will make sure to foster exchange of ideas and knowledge to provide an as inclusive as possible event.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4202, "code": "ZTATFJ", "public_name": "Ludovic R\u00e4ss", "biography": "[Geo-HPC, GPUs, supercomputing & Julia](https://github.com/luraess) @ [VAW ETHZ](https://vaw.ethz.ch/forschung/glaziologie.html).", "answers": []}, {"id": 4374, "code": "CRJ7BV", "public_name": "Mauro Werder", "biography": null, "answers": []}, {"id": 10286, "code": "BYZ8MT", "public_name": "Samuel Omlin", "biography": "N/A", "answers": []}], "links": [], "attachments": [], "answers": []}], "Red": [{"id": 9728, "guid": "39e00366-1335-54f5-81a4-5bec3339abe9", "logo": "", "date": "2021-07-23T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Red", "slug": "juliacon2021-9728-package-development-in-vscode", "url": "https://pretalx.com/juliacon2021/talk/WCSKJ7/", "title": "Package development in VSCode", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "The [Julia extension for VSCode](https://www.julia-vscode.org/) provides a multitude of tools and commands to make package development and interactive coding easy. We'll provide an overview on how to develop a Julia package from scratch and show how to use the debugger and profiler efficiently to find and fix faulty logic or performance issues.", "description": "The [Julia extension for VSCode](https://www.julia-vscode.org/) has changed significantly over the last year, with multiple feature additions and UX improvements. At the same time, VSCode has many not particularly widely known yet very useful features.\r\n\r\nThis workshop aims to introduce new as well experienced users to a package development workflow in VSCode, including use cases like debugging and profiling as well as how to best use inline evaluation or the Revise integration. We'll also provide an overview on the various possibilities for interactive data exploration/analysis, the remote capabilities built into VScode, and more.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4375, "code": "8GV8MU", "public_name": "Sebastian Pfitzner", "biography": "Software engineer at Julia Computing and one of the maintainers of the Julia extension for VSCode.", "answers": []}, {"id": 1038, "code": "7JQFVF", "public_name": "David Anthoff", "biography": "David Anthoff is an environmental economist who studies climate change and environmental policy. He co-develops the integrated assessment model FUND that is used widely in academic research and in policy analysis. His research has appeared in Nature, Science, the American Economic Review and other academic journals. He contributed a background research paper to the Stern Review and has advised numerous organizations (including US EPA and the Canadian National Round Table on the Environment and the Economy) on the economics of climate change.\r\n\r\nHe is an assistant professor in the Energy and Resources Group at the University of California, Berkeley. Previously he was an assistant professor in the School of Natural Resources and the Environment of the University of Michigan, a postdoc at the University of California, Berkeley and a postdoc at the Economic and Social Research Institute in Ireland. He also was a visiting research fellow at the Smith School of Enterprise and the Environment, University of Oxford.\r\n\r\nHe holds a PhD (Dr. rer. pol.) in economics from the University of Hamburg (Germany) and the International Max Planck Research School on Earth System Modelling, a MSc in Environmental Change and Management from the University of Oxford (UK) and a M.Phil. in philosophy, logic and philosophy of science from Ludwig-Maximilians-Universit\u00e4t M\u00fcnchen (Munich, Germany).", "answers": []}], "links": [], "attachments": [], "answers": []}]}}, {"index": 5, "date": "2021-07-24", "day_start": "2021-07-24T04:00:00+00:00", "day_end": "2021-07-25T03:59:00+00:00", "rooms": {"Green": [{"id": 9218, "guid": "d89ba03a-039f-58ab-b16d-87c7a37e1150", "logo": "", "date": "2021-07-24T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Green", "slug": "juliacon2021-9218-simulating-big-models-in-julia-with-modelingtoolkit", "url": "https://pretalx.com/juliacon2021/talk/NNVXZC/", "title": "Simulating Big Models in Julia with ModelingToolkit", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "It can be hard to build and solve million equation models. Making them high performance, stable, and parallel? Introducing ModelingToolkit.jl! The modeling auto-optimizer for all of your performance needs! We will show many use cases on differential equations and beyond (optimization, nonlinear solving, etc.).", "description": "It can be hard to build and solve million equation models. Making them high performance, stable, and parallel? Introducing ModelingToolkit.jl! In this workshop we will showcase ModelingToolkit as a system for building large differential equation models in a hierarchical component-wise way. This acausal modeling system is reminiscent of widely used tools like Simulink and Modelica, but we will showcase how ModelingToolkit's deep integration with interactive symbolic programming leads to a more intuitive pure Julia modeling system. The audience will be walked through a live demonstration of using ModelingToolkit to compose models and add transformations, like index reduction of differential-algebraic equations (DAEs) and tearing of nonlinear systems, to improve stability and performance of the generated code. We will demonstrate how to use the automated parallelism easily solve millions of equations in the most performant way. We will show how ModelingToolkit extends far beyond differential equations, featuring how it can be used for similarly generating high performance code for nonlinear optimization, solving nonlinear equations, doing nonlinear optimal control, generating models from chemical reaction descriptions, and more. The user will leave with a better understanding of the growing symbolic-numeric modeling ecosystem and the future of large-scale accurate and high-performance SciML modeling.", "recording_license": "", "do_not_record": false, "persons": [{"id": 904, "code": "WUWQQ3", "public_name": "Chris Rackauckas", "biography": "Chris Rackauckas is an Applied Mathematics Instructor at MIT and the Director of Scientific Research at Pumas-AI. He is the lead developer of the SciML open source scientific machine learning organization which develops widely used software for scientific modeling and inference. One such software is DifferentialEquations.jl for which its innovative solvers won an IEEE Outstanding Paper Award and the inaugural Julia Community Prize. Chris' work on high performance differential equation solving is seen in many applications from the MIT-CalTech CLiMA climate modeling initiative to the SIAM DSWeb award winning DynamicalSystems.jl toolbox. Chris is also the creator of Pumas, the foundational software of Pumas-AI for nonlinear mixed effects modeling in clinical pharmacology. These efforts on Pumas led to the International Society of Pharmacology's (ISoP) Mathematical and Computational Special Interest Group Award at the American Conference of Pharmacology (ACoP) 2019 for his work on improved clinical dosing via Koopman Expectations, along with the ACoP 2020 Quality Award for his work on GPU-accelerated nonlinear mixed effects modeling via generation of SPMD programs. For this work in pharmacology, Chris received the Emerging Scientist award from ISoP in 2020, the highest early career award in pharmacometrics.", "answers": []}], "links": [], "attachments": [], "answers": []}], "Red": [{"id": 9085, "guid": "eed3054c-305a-53a5-a020-1983ac4d2c49", "logo": "", "date": "2021-07-24T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Red", "slug": "juliacon2021-9085-package-development-improving-engineering-quality-latency", "url": "https://pretalx.com/juliacon2021/talk/VY9UVX/", "title": "Package development: improving engineering quality & latency", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "Julia holds immense promise for a composable package ecosystem. Potential obstacles to achieving this promise include missing methods for unanticipated types, unwitting type-piracy, poor performance due to inference failures, method ambiguities, and latency due to long compilation times and/or invalidation of previously-compiled code.\r\n\r\nThis workshop will tutor developers on the use of some recently-developed tools for detecting, diagnosing, and fixing such problems.", "description": "This workshop will tutor developers on the use of some of the tools available for improving package quality and reducing latency. We will begin by summarizing the factors that influence dispatch, inference, latency, and invalidation, and how monitoring inference provides a framework for detecting problems before or as they arise. We will then tutor attendees in the use of tools like MethodAnalysis, JET, Cthulhu, and SnoopCompile to discover, analyze, and fix detected problems in package implementation. We will also show how in addition to improving robustness, such steps can often streamline design and reduce latency.\r\n\r\nThis workshop is aimed at experienced Julia developers. Materials can be cloned from https://github.com/aviatesk/juliacon2021-workshop-pkgdev", "recording_license": "", "do_not_record": false, "persons": [{"id": 1179, "code": "J9BSUH", "public_name": "Tim Holy", "biography": "Timothy E. Holy is the Alan A. and Edith L. Wolff Professor of Neuroscience and Biomedical Engineering at Washington University in St. Louis. His lab combines technological innovation with analysis of the rules governing neuronal function and computation. His work on Julia includes contributions to the type system, the array and broadcasting infrastructure, the standard library, and developer tools like the profiler, debugger, Revise, and many others.", "answers": []}, {"id": 4222, "code": "8BZR7G", "public_name": "Shuhei Kadowaki", "biography": "A research programmer working at Julia Lab, MIT. Working on Julia's compiler technology stack, mainly around its abstract interpretation based type inference. Aso a maintainer of Julia IDEs, [julia-vscode](https://www.julia-vscode.org/) and [Juno](https://junolab.org/).", "answers": []}], "links": [], "attachments": [], "answers": []}]}}, {"index": 6, "date": "2021-07-25", "day_start": "2021-07-25T04:00:00+00:00", "day_end": "2021-07-26T03:59:00+00:00", "rooms": {"Green": [{"id": 9948, "guid": "d5911a1e-5fe1-5f24-a70a-310f539ef71b", "logo": "", "date": "2021-07-25T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Green", "slug": "juliacon2021-9948-parse-and-broker-log-messages-with-combinedparsers-ebnf-", "url": "https://pretalx.com/juliacon2021/talk/DKEJ97/", "title": "Parse and broker (log) messages with CombinedParsers(.EBNF)", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "Parsers are programs to break apart strings that match a grammar\r\nin order to transform into structured representations.\r\nI demonstrate composing regular expressions, EBNF grammars and CombinedParsers.jl constructors to build a slick message broker system inspired by Apache Kafka:\r\nLog lines and other messages are parsed to julia types.\r\nParsed instances are brokered by julia's multiple dispatch into different data sinks (git managed CSV, SearchLight.jl).", "description": "Step by step I show available options for defining CombinedParsers to process different message formats (e.g. log lines) and to transform into julia result_types.\r\nThe examples demonstrate that julia's dispatch leverages parsed result_types straightforwardly to a slick and powerful platform for complex string-processing workflows like message brokering similar to Apache Kafka:\r\nJulia's multiple dispatch is easier to write and executes faster than conditional programming patterns of the form \"if this kind of thing then do x\" in java-based Kafka.\r\nThe demonstration exemplifies dispatch into different data sinks like git managed CSV and text files,  SearchLight.jl, and even Telegram.jl Bot alerts.\r\n\r\nThe workshop details the use of grammar languages supported by CombinedParsers.jl:\r\nYou can conveniently compose existing EBNF Grammars with PCRE regular expressions and CombinedParser's julia constructors to create fast pure julia compiled (also recursive) parsers.\r\nRegular expressions and EBNF CombinedParsers result in nested (named) tuples by default.\r\nUsers can inject transformation functions for any (sub-)parser after definition as EBNF/PCRE.\r\nAlternatively a CombinedParsers julia syntax equivalent to a PCRE/EBNF grammar can be printed and amended with transformations.\r\n\r\nFor improved performance, lazy transformations allow access to parts of a parsed string without transforming the full parsing result (similar to LazyJSON.jl).\r\n\r\nBenchmarks and standards compliance is reported based on extensive unit tests.\r\nJulia CombinedParsers performance competes with the PCRE C library, which is among the fastest regex libraries on the market.\r\nThis is achieved by leveraging the excellent julia compiler with generated functions, multiple dispatch and parametric types.\r\nCombinedParsers supports to lazily iterate all valid parsings if not unique, and the TextParse interface to include CombinedParsers e.g. in CSV.jl.\r\n\r\nOther parsing packages (Automa.jl, ParserCombinator.jl, Lerche.jl) and current limitations and considerations for further optimization will be discussed.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4398, "code": "ABRWNH", "public_name": "Gregor Kappler", "biography": "Gregor Kappler carries out psychometric research and data science consulting, and is founder of FilingForest, a julia-focused startup developing solutions for fast unbiased measurement in graph data.\r\n\r\nGregor was initially trained as a mathematician and psychologist, has implemented solutions for semantic text analytics for his PhD in 2007, and developed psychometric models for measuring with texts.\r\nHe has worked as a lecturer and researcher at the University of Vienna and the University of Jena and worked on a series of predictive analytic projects for software vendors and customers.\r\n\r\nGregor has switched to Julia from R in 2018, and is creator of the CombinedParsers package which provides parser combinators for fast, recursive and type-save parsing in pure Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}], "Red": [{"id": 9873, "guid": "6f760da5-35f7-564e-b199-c8badea5a03a", "logo": "", "date": "2021-07-25T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Red", "slug": "juliacon2021-9873-modeling-marine-ecosystems-at-multiple-scales-using-julia", "url": "https://pretalx.com/juliacon2021/talk/FEZW9Q/", "title": "Modeling Marine Ecosystems At Multiple Scales Using Julia", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "Life in the oceans is strongly connected to our climate. In this workshop, you will learn to use packages from the JuliaOcean and JuliaClimate organizations that provide a foundation for studying marine ecosystems across a wide range of scales. We will first run agent-based models to explore individual microbes and processes that drive species interactions. On the other end of the model hierarchy, we will simulate planetary-scale transports that control ocean biogeography and climate change.", "description": "Packages covered in this workshop will include: \r\n\r\n- `AIBECS.jl` : global steady-state biogeochemistry and gridded transport models that run fast for long time scales (centuries or even millenia).\r\n- `PlanktonIndividuals.jl` : local to global agent based model, particluarly suited to study microbial communities, plankton physiology, and nutrient cycles.\r\n- `IndividualDisplacements.jl` : local to global particle tracking, for simulating dispersion, connectivity, transports in the ocean or atmosphere, etc.\r\n- `MITgcmTools.jl` : interface to full-featured, fortran-based, general circulation model and its output (transports, chemistry, ecology, ocean, seaice, atmosphere, and more).\r\n\r\nThe workshop's first two hours will be organized around tutorials and self-contained Pluto notebooks for the different packages.\r\n\r\nThe third hour will provide the opportunity for attendees to further explore the models in breakout rooms and via exercises.\r\n\r\nWorkshop schedule in more detail:\r\n\r\n- Introduction of the topics covered, presenters, installation, and workshop roadmap (15 minutes).\r\n\r\n- AIBECS.jl : concept, implementation, tutorial workthough (20 minutes + 10' for questions)\r\n\r\n- PlanktonIndividuals.jl : concept, implementation, tutorial workthough (20 minutes + 10' for questions)\r\n\r\n- IndividualDisplacements.jl : concept, implementation, tutorial workthough (10 minutes + 10' for questions)\r\n\r\n- MITgcmTools.jl : concept, implementation, tutorial workthough (10 minutes + 10' for questions)\r\n\r\n- 5-minute break\r\n\r\n- breakout rooms for deeper dive in tutorials, exercises, or trying out your own idea with guidance from the presenters (1 hour)\r\n\r\nWorkshop materials will be made available ahead of time @ https://github.com/JuliaOcean/MarineEcosystemsJuliaCon2021.jl", "recording_license": "", "do_not_record": false, "persons": [{"id": 10449, "code": "PFYSJ9", "public_name": "Gael Forget", "biography": "I work as a reseach scientist at the Massachusetts Institute of Technology (MIT) where I investigate oceanography and climate. As part of the Department of Earth, Atmospheric and Planetary Sciences, my work focuses on ocean modeling and the analysis of global ocean data sets such as Argo profile collections, satellite records of sea level, or ocean color retrievals. I co-develop computer programs in various languages and carry out ocean state estimation using the MIT general circulation model in order to interpolate and interpret ocean observations. My scientific interests include: ocean circulation and climate variability; tracer transport and turbulent transformation processes; interaction of ecological, geochemical, and physical processes; global cycles of heat, water, and carbon; observational statistics; forward and inverse modeling.", "answers": []}, {"id": 10500, "code": "9WPU3V", "public_name": "Benoit Pasquier", "biography": "Postdoc at the University of Southern California", "answers": []}, {"id": 11532, "code": "JFA3PF", "public_name": "Zhen Wu", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}]}}, {"index": 7, "date": "2021-07-26", "day_start": "2021-07-26T04:00:00+00:00", "day_end": "2021-07-27T03:59:00+00:00", "rooms": {"Green": [{"id": 9859, "guid": "c09267c8-45bc-561c-be8e-82fcf34e3b81", "logo": "/media/juliacon2021/submissions/9KGMHJ/logo_n0pYIwG.png", "date": "2021-07-26T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Green", "slug": "juliacon2021-9859-it-s-all-set-a-hands-on-introduction-to-juliareach", "url": "https://pretalx.com/juliacon2021/talk/9KGMHJ/", "title": "It's all Set: A hands-on introduction to JuliaReach", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "JuliaReach is among the best-of-breed software addressing the fundamental problem of reachability analysis: computing the set of states that are reachable by a dynamical system from all initial states and for all admissible inputs and parameters. We explain the role of Julia's multiple dispatch to gain an unprecedented level of flexibility and expressiveness in this area. We explore diverse applications including differential equations, hybrid systems and neural network controlled systems.", "description": "We present [JuliaReach](https://github.com/JuliaReach), a Julia ecosystem to perform reachability analysis of dynamical systems. JuliaReach builds on sound scientific approaches and was, in two occasions (2018 and 2020) the winner of the annual friendly competition on Applied Verification for Continuous and Hybrid Systems ([ARCH-COMP](https://cps-vo.org/group/ARCH)).\r\n\r\nThe workshop consists of three parts (respectively packages) in [JuliaReach](https://github.com/JuliaReach): our core package for set representations, our main package for reachability analysis, and a new package applying reachability analysis with potential use in domain of control, robotics and autonomous systems.\r\n\r\nIn the first part we present [LazySets.jl](https://github.com/JuliaReach/LazySets.jl), which provides ways to symbolically represent sets of points as geometric shapes, with a special focus on convex sets and polyhedral approximations. [LazySets.jl](https://github.com/JuliaReach/LazySets.jl) provides methods to apply common set operations, convert between different set representations, and efficiently compute with sets in high dimensions.\r\n\r\nIn the second part we present [ReachabilityAnalysis.jl](https://github.com/JuliaReach/ReachabilityAnalysis.jl), which provides tools to approximate the set of reachable states of systems with both continuous and mixed discrete-continuous dynamics, also known as hybrid systems. It implements conservative discretization and set-propagation techniques at the state-of-the-art.\r\n\r\nIn the third part we present [NeuralNetworkAnalysis.jl](https://github.com/JuliaReach/NeuralNetworkAnalysis.jl), which is an application of [ReachabilityAnalysis.jl](https://github.com/JuliaReach/ReachabilityAnalysis.jl) to analyze dynamical systems that are controlled by neural networks. This package can be used to validate or invalidate specifications, for instance about the safety of such systems.\r\n\r\n---\r\n\r\nMeet the team of researchers and students that form the [JuliaReach](https://juliareach.com) network:\r\n\r\n- [Luis Benet](https://github.com/lbenet). Universidad Nacional Aut\u00f3noma de M\u00e9xico. *Validated integration, Nonlinear Physics.* He is also one of the lead developers of [JuliaIntervals](https://github.com/JuliaIntervals).\r\n\r\n- [Marcelo Forets](https://github.com/mforets). Universidad de la Rep\u00fablica, Uruguay. *Reachability Analysis, Hybrid Systems, Neural Network Robustness.*\r\n\r\n- [Daniel Freire Caporale](https://github.com/dfcaporale). Universidad de la Rep\u00fablica, Uruguay. *Reachability, PDEs, Fluid Mechanics.*\r\n\r\n- [Sebastian Guadalupe](https://github.com/sebastianguadalupe). Universidad de la Rep\u00fablica, Uruguay. *Julia Seasons of Contributions 2020 Alumni. Mathematical Modeling, Hybrid systems.*\r\n\r\n- [Uziel Linares](https://github.com/uziellinares). Universidad Nacional Aut\u00f3noma de M\u00e9xico. *Google Summer of Code 2020 Alumni. Nonlinear reachability, Taylor models.*\r\n\r\n- [Jorge P\u00e9rez Zerpa](https://github.com/jorgepz). Universidad de la Rep\u00fablica, Uruguay. *Finite Element Method, Structural Engineering, Material Identification.*\r\n\r\n- [David P. Sanders](https://github.com/dpsanders). Universidad Nacional Aut\u00f3noma de M\u00e9xico and visiting professor at MIT. *Computational Science, Interval Arithmetic, and Numeric-symbolic Computing.* He is also one of the lead developers of [JuliaIntervals](https://github.com/JuliaIntervals).\r\n\r\n- [Christian Schilling](https://github.com/schillic). University of Konstanz, Germany. *Formal Verification, Artificial Intelligence, Cyber-Physical Systems.*", "recording_license": "", "do_not_record": false, "persons": [{"id": 10415, "code": "V93HYB", "public_name": "Marcelo Forets", "biography": "[Marcelo Forets](https://github.com/mforets) is an Applied Mathematician that works as Assistant Professor at Universidad de la Rep\u00fablica (Uruguay). Born in Uruguay (Montevideo, 1988), he graduated in Physics and in Electrical Engineering, then moved to France for a PhD in Mathematics and Informatics (Univ. Joseph Fourier,  France) on the quantum random walk, a model of particular interest to Quantum Computing. He was a post-doc researcher at VERIMAG laboratory of Universit\u00e9 Grenoble Alpes (France) under the supervision of Oded Maler and Goran Frehse, where he started to develop what is now the [JuliaReach](http://juliareach.com) package ecosystem. His research has to do with developing innovative numerical tools that impact decisions regarding reliability, correctness and safety of control systems, hybrid dynamical systems, and robustness analysis of neural networks.", "answers": []}, {"id": 10444, "code": "HB7CMX", "public_name": "Christian Schilling", "biography": "[Christian Schilling](https://www.christianschilling.net/) received his Ph.D. degree in computer science from the University of Freiburg, Germany, in 2018 under the supervision of Andreas Podelski.  He was a postdoctoral research fellow at IST Austria in the group of Thomas A. Henzinger.  Since 2020 he is the interim professor for cyber-physical system at the University of Konstanz, Germany.  Christian's research in the area of formal methods is focused on the analysis, verification, and synthesis of systems with dynamical or machine-learned components. He is a co-lead developer in the JuliaReach ecosystem.", "answers": []}], "links": [], "attachments": [], "answers": []}], "Red": [{"id": 9858, "guid": "34aba984-523f-5603-a234-9b32dc2764ef", "logo": "", "date": "2021-07-26T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Red", "slug": "juliacon2021-9858-introduction-to-bayesian-data-analysis", "url": "https://pretalx.com/juliacon2021/talk/J7BFBM/", "title": "Introduction to Bayesian Data Analysis", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "This workshop will introduce the recommended workflow for applied Bayesian data analysis by working through an example analysis together. We will start with the simplest non-trivial model and use increasingly sophisticated models to explain the properties of our data set based on model diagnostics. We will also give an overview of the different probabilistic programming packages in Julia and show where we have advantages over other languages such as Stan and Python.", "description": "We will give participants an intuition and diagnostics for the workhorse of modern Bayesian statistics: the Hamiltonian MCMC algorithm. Additionally, we will cover the following topics:\r\n - modeling count data with Poisson regression\r\n  - modeling overdispersion with the negative Binomial model\r\n  - hierarchical modeling\r\n  - modeling time varying effects with autoregressive models and Gaussian processes\r\n\r\nWe will conclude the workshop by showcasing future potential and features that are not currently available elsewhere such as Bayesian neural ODEs and symbolic optimization of Bayesian models.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4397, "code": "Z7JSAN", "public_name": "Kusti Skyt\u00e9n", "biography": "A Biostatistics PhD student from the University of Oslo. I'm working on combining computer simulations with Bayesian statistical models. I have been a big fan of Julia since version 0.4. My research interests are Bayesian statistics, symbolic computing and applied category theory.", "answers": []}], "links": [], "attachments": [], "answers": []}]}}, {"index": 8, "date": "2021-07-27", "day_start": "2021-07-27T04:00:00+00:00", "day_end": "2021-07-28T03:59:00+00:00", "rooms": {"Red": [{"id": 9833, "guid": "dbc868aa-563b-5a96-baae-58b5cfe624a6", "logo": "", "date": "2021-07-27T14:00:00+00:00", "start": "14:00", "duration": "03:00", "room": "Red", "slug": "juliacon2021-9833-introduction-to-metaprogramming-in-julia", "url": "https://pretalx.com/juliacon2021/talk/DWEMBV/", "title": "Introduction to metaprogramming in Julia", "subtitle": "", "track": null, "type": "Workshop", "language": "en", "abstract": "Metaprogramming is a key technique that intermediate to advanced Julia users *sometimes* need -- although not as often as they think!\r\n\r\nThis will be a tutorial introduction to metaprogramming, analyzing, from the bottom up, key topics such as the structure of Julia expressions, how and when to use (and not use) generated functions and macros, and touching on more recent techniques like use of Symbolics.jl and MLStyle.jl.", "description": "Metaprogramming is an important skill that intermediate to advanced Julia users *sometimes* need to use. This tutorial will be an introduction at the intermediate level, aiming to answer clearly questions such as:\r\n\r\n- What is metaprogramming?\r\n- When and why should I use it?\r\n- When should I *not* use it? (See Steven Johnson's keynote from JuliaCon 2019.)\r\n- What are macros for, and how do they work?\r\n- What is macro hygiene and how should I use it?\r\n- How can I write a function that recursively analyses a syntax tree?\r\n- When should I use a generated function?\r\n- How can I get access to the code for a function that is already defined? \r\n- Are there packages that can make this simpler? (Brief sketch)\r\n\r\nThe goal is to provide a firm foundation of understanding that can then be built on later with more advanced applications (not covered in the workshop). The aim is to provide a relatively pedestrian, but easy to follow, path to understanding, rather than to apply powerful, but difficult to understand, functional techniques.\r\n\r\nWe will provide simple examples of metaprogramming applied to interesting questions in scientific computing, always aiming for simple examples and explanations.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1022, "code": "TJJRTG", "public_name": "David P. Sanders", "biography": "Professor of Computational Science at the Universidad Nacional Aut\u00f3noma de M\u00e9xico and visiting professor at MIT.\r\n\r\nInterested in computational science, interval arithmetic, and numeric-symbolic computing.\r\n\r\nAuthor of the JuliaIntervals suite of packages for interval arithmetic, and various tutorials on Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}]}}, {"index": 9, "date": "2021-07-28", "day_start": "2021-07-28T04:00:00+00:00", "day_end": "2021-07-29T03:59:00+00:00", "rooms": {"Green": [{"id": 9276, "guid": "88018952-ab67-5fdb-b582-87827565fd49", "logo": "/media/juliacon2021/submissions/SLUMQM/juliacon_GoYOxp2.png", "date": "2021-07-28T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9276-geostatistical-learning", "url": "https://pretalx.com/juliacon2021/talk/SLUMQM/", "title": "Geostatistical Learning", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "**Geostatistical Learning** is a new branch of Geostatistics concerned with learning functions over geospatial domains (e.g. 2D maps, 3D subsurface models). The theory is being carefully implemented in the **GeoStats.jl** framework, which is an extensible framework for high-performance geostatistics in Julia. In this talk, I will illustrate how the framework can be used to learn functions over general unstructured meshes, and how this unique technology can help advance geoscientific work.", "description": "The theory was introduced in our recent (open access) paper available online: https://www.frontiersin.org/articles/10.3389/fams.2021.689393/full\r\n\r\nIts implementation requires knowledge of geostatistics, computational geometry, and high-performance computing. Due to the great features of the Julia language we were able to achieve an elegant design with great runtime performance.\r\n\r\n**Packages:** [GeoStats.jl](https://github.com/JuliaEarth/GeoStats.jl), [Meshes.jl](https://github.com/JuliaGeometry/Meshes.jl)", "recording_license": "", "do_not_record": false, "persons": [{"id": 3028, "code": "GUDMS8", "public_name": "J\u00falio Hoffimann", "biography": "Dr. J\u00falio Hoffimann is a research scientist with more than 10 years of experience in advanced statistical theories for geosciences. He is the author and lead developer of the [GeoStats.jl](https://github.com/JuliaEarth/GeoStats.jl) framework, as well as various other [open source projects](https://github.com/JuliaEarth) that are widely used by geoscientists around the world: https://juliohm.github.io", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9307, "guid": "0425c314-0f3a-5ba4-b506-a7b1e5ddcb66", "logo": "", "date": "2021-07-28T13:00:00+00:00", "start": "13:00", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9307-hierarchical-multiple-instance-learning", "url": "https://pretalx.com/juliacon2021/talk/XFZWWA/", "title": "Hierarchical Multiple Instance Learning", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Learning from raw data input is one of the key components of many successful applications of machine learning methods. While machine learning problems are often formulated on data that naturally translate into a vector representation suitable for classifiers, there are data sources with a unifying hierarchical structure, such as JSON. This talk will describe Mill.jl and JsonGrinder.jl, which offers a theoretically justified approach to solve machine learning problems with these data sources.", "description": "Learning from raw data input, thus limiting the need for manual feature engineering, is one of the key components of many successful applications of machine learning methods. While machine learning problems are often formulated on data that naturally translate into a vector representation suitable for classifiers, there are data sources, for example in cybersecurity, that are naturally represented in diverse files with a unifying hierarchical structure, such as XML, JSON, and Protocol Buffers.\r\n\r\n Converting this data to vector (tensor) representation is generally done by manual feature engineering, which is laborious, lossy, and prone to human bias about the importance of particular features. \r\n \r\nMill.jl and Jsongrinder.jl is a tandem of libraries,  which fully automates the conversion. Starting with an arbitrary set of JSON samples, they create a differentiable machine learning model capable of infer from  further JSON samples in their raw form.\r\n\r\nIn the spirit of the Julia language, the framework is split into two packages --- Mill.jl implementing the hierarchical multiple instance learning paradigm, offering a theoretically justified approach for building machine learning models for this type of data, and Jsongrinder.jl summarizing the structure in a set of JSON samples and reflecting it in a Mill.jl model. \r\n\r\nThe talk will be split in four parts.\r\n1) Motivation why we think the problem is interesting\r\n2) Description of mathematical function and theorems about mathematical correctness\r\n3) Description of a design of libraries\r\n4) Practical demo\r\n\r\nLink to libraries:\r\nhttps://github.com/CTUAvastLab/Mill.jl\r\nhttps://github.com/pevnak/JsonGrinder.jl", "recording_license": "", "do_not_record": false, "persons": [{"id": 9771, "code": "C78D79", "public_name": "Tomas Pevny", "biography": "Tomas Pevny has graduated from Faculty of Nuclear sciences and Physical Engineering, CTU, Prague, in 2003. From 2004-2008, he was pursuing Ph.D. at Binghamton University, SUNY, USA specializing on Steganalysis. In 2008-2009 he spent a wonderful post-doc year in Grenoble. Since 2009, he is with Faculty of electrical engineering, CTU, at Prague. From 2013-2019, he was also consulting scientist at Cisco and from 2019 he is consulting scientist at Avast. His specialization is machine learning in security domains. He is an active user of Julia since 2015.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9446, "guid": "35686450-6129-539f-a19b-2ef9b4784b2b", "logo": "", "date": "2021-07-28T13:30:00+00:00", "start": "13:30", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9446-reactivemp-jl-reactive-message-passing-based-bayesian-inference", "url": "https://pretalx.com/juliacon2021/talk/J7Z9PL/", "title": "ReactiveMP.jl: Reactive Message Passing-based Bayesian Inference", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "ReactiveMP.jl is a native Julia implementation of reactive message passing-based Bayesian inference in probabilistic graphical models. The package supports a large range of standard probabilistic models and can be extended to custom novel nodes and message update rules. In contrast to non-reactive (imperatively coded) Bayesian inference packages, ReactiveMP.jl scales easily to support inference on a standard laptop for large models with tens of thousands of variables and millions of nodes.", "description": "Bayesian inference is one of the key computational mechanisms that underlies probabilistic model-based machine learning applications such as time series prediction, image and speech recognition, and robotics. Unfortunately, for many models of practical interest, Bayesian inference requires evaluating high-dimensional integrals that have no analytical solution. As a result, Probabilistic Programming (PP) tools for Automated Approximate Bayesian Inference (AABI) have become popular, e.g., Turing.jl, Soss.jl, ForneyLab.jl, Pyro, and others. These tools help researchers to define custom probabilistic models in a high-level domain-specific language and run AABI algorithms with minimal additional overhead. \r\n\r\nAn important issue in the development of PP frameworks is scalability of AABI algorithms for large models and large data sets. One solution approach concerns message passing-based inference in factor graphs. In this framework, relationships between model variables are represented by a graph of sparsely connected nodes, and inference proceeds efficiently by a sequence of nodes sending probabilistic messages to neighboring nodes. While the optimal message passing schedule is data-dependent, all existing factor graph frameworks  (e.g., Infer.Net, ForneyLab.jl) use preset message sequence schedules. The potential benefits of massively parallel and asynchronous reactive message passing in a factor graph include scaling to large inference tasks, much smaller processing latency and processing of data samples that arrive at irregular time intervals. \r\n\r\nWe have developed ReactiveMP.jl, which is a native Julia package for automated reactive message passing-based (both exact and approximate) Bayesian inference. ReactiveMP.jl is based on Rocket.jl, which is a native Julia package for a reactive programming. In ReactiveMP.jl, there are no pre-scheduled messages. Instead, nodes subscribe to messages from connected nodes and react autonomously and asynchronously whenever a new message has been received. As a result, ReactiveMP.jl scales comfortably to inference tasks on factor graphs with tens of thousands of variables and millions of nodes.\r\n\r\nThe ReactiveMP.jl package comes with a collection of standard probabilistic models, including linear Gaussian state-space models, hidden Markov models, auto-regressive models and mixture models. Moreover, ReactiveMP.jl API supports various processing modes such as offline learning, online filtering of infinite data streams and protocols for handling missing data.\r\n\r\nReactiveMP.jl is customizable and provides an easy way to add new models, node functions and analytical message update rules to the existing platform. As a result, a user can extend built-in functionality with custom nodes to run automated inference in novel probabilistic models. The resulting inference procedures are differentiable with the ForwardDiff.jl or ReverseDiff.jl packages. In addition, the inference engine supports different types of floating point numbers, e.g., the built-in BigFloat Julia type.\r\n\r\nWe achieved excellent performance by relying on Julia's great multiple dispatch capabilities and advanced compile-time optimization techniques. Message passing-based inference requires computation of many messages by node-specific update rules. Some of these updates can be evaluated and in-lined at compile time, which results in a fast and accurate automated Bayesian inference realization with almost zero overhead when compared to manually hard-coded inference procedures. \r\n\r\nWe compared ReactiveMP.jl to other message passing and sampling-based inference packages. In terms of computation time and memory usage, specifically for conjugate models, the ReactiveMP.jl engine outperforms Turing.jl, ForneyLab.jl and Infer.Net significantly by orders of magnitude. Comparative performance benchmarks are available at the GitHub repository: https://github.com/biaslab/ReactiveMP.jl.\r\n\r\nAutomating scalable Bayesian inference is a key factor in the quest to apply Bayesian machine learning to useful applications. We developed ReactiveMP.jl as a package that enables developers to build novel probabilistic models and automate scalable inference in those models by asynchronous, reactive message passing in a factor graph. We are looking forward to presenting the ReactiveMP.jl package and discuss the advantages and drawbacks of the reactive message passing approach.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9845, "code": "F87RD7", "public_name": "Dmitry Bagaev", "biography": "I am a PhD candidate in the SPS group of Electrical Engineering department in Eindhoven University of Technology. My research interests lie in the fields of computer science, software developing, numerical modeling, machine learning, computational optimization and high-performant parallelized applications.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9917, "guid": "36938349-22c0-5e68-a876-834385c62fa2", "logo": "", "date": "2021-07-28T13:40:00+00:00", "start": "13:40", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9917-exploiting-structure-in-kernel-matrices", "url": "https://pretalx.com/juliacon2021/talk/LXATFU/", "title": "Exploiting Structure in Kernel Matrices", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Kernel methods are widely used in statistics, machine learning, and physical simulations. These methods give rise to dense matrices that are na\u00efvely expensive to multiply or invert. Herein, we present CovarianceFunctions.jl, a package that automatically detects and exploits low rankness, hierarchical structure, approximate sparsity. We highlight applications of this technology in Bayesian optimization and physical simulations.", "description": "CovarianceFunctions.jl implements many commonly used kernel functions including stationary ones like the exponentiated quadratic, rational quadratic, and Mat\u00e9rn kernel, but also non-stationary ones like the polynomial and neural network kernel. A crucial component of the package is the \"Gramian\" matrix type which lazily represents kernel matrices with virtually no memory footprint. The package's most significant functionality derives from algorithms designed for particular combinations of kernel and data types, since they are able to drastically reduce the computational complexity of multiplication and inversion. However, even in the general case the lazy implementation eliminates the typical O(n^2) memory allocation for simply storing a kernel matrix of n data points\r\n\r\nFor stationary kernels in low dimensions, the package implements a new hierarchical factorization based on multipole expansions of the kernels via automatic differentiation. The user need only input the kernel function and data points, and the package automatically computes the relevant analytic expansions which are then leveraged within a treecode analagous to the Barnes-Hut algorithm. Fast multiplies are then performed in O(nlog(n)) time, and solves are performed using an iterative method whose preconditioner is also based on the aforementioned treecode.\r\n\r\nFor exponentially decaying stationary kernels (i.e. exponential, Mat\u00e9rn, RBF) in high dimensions, it is highly likely that the associated kernel matrix can be approximated well by a sparse matrix. However, na\u00efvely detecting this approximate sparsity pattern would require evaluating the entire matrix in O(n^2) time. Instead, the package takes advantage of vantage trees to quickly find the most prominent neighbors of each data point in O(nk log(n)), where k is the maximum number of relevant neighbors of a data point.\r\n \r\nIn the context of Bayesian optimization with gradient information, the associated gradient kernel matrices are of size (nd x nd), na\u00efvely requiring O(n^2d^2) operations for multiplication, which becomes prohibitive quickly as the number of parameters d increases. Based on recent work that uncovered a particular structure in a large class of these gradient kernel matrices, the package contains an exact multiplication algorithm that requires O(n^2d) operations. As a result, we are able to demonstrate first-order Bayesian optimization on problems of higher dimensionality than were previously possible.\r\n\r\nIn the absence of any of the above particular structure, the package attempts to construct a low-rank approximation of the matrix via a generic pivoted Cholesky algorithm that lazily computes the kernel matrix's entries, allowing the algorithm to terminate in O(nr^2) steps, where r is the numerical rank, before even fully forming the entire matrix. In the worst case however, this falls back to O(n^3) complexity in the absence of any structure.\r\n\r\nIn addition to implementing the above algorithms, a main feature of the package is the automatic detection of the most scalable algorithm depending on the kernel and data type. We believe that this type of automation is particularly useful for practitioners that rely on kernel methods and need to scale them to large datasets. We further invite specialists to contribute their methods for efficient computations with kernel matrices.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10501, "code": "T3U8MQ", "public_name": "Sebastian Ament", "biography": "PhD Candidate at Cornell University", "answers": []}, {"id": 12367, "code": "NWJDLX", "public_name": "John Paul Ryan", "biography": "PhD Candidate in Computer Science at Cornell University", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9809, "guid": "53cc4a9a-e9a5-58b0-8f7e-802e6cc0073c", "logo": "", "date": "2021-07-28T13:50:00+00:00", "start": "13:50", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9809-effects-jl-effectively-understand-effects-in-regression-models", "url": "https://pretalx.com/juliacon2021/talk/BMMEGV/", "title": "Effects.jl: Effectively Understand Effects in Regression Models", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Regression models are useful but they can be tricky to interpret.\r\nVariable centering and contrast coding can obscure the meaning of main effects.\r\nInteraction terms, especially higher order ones, only increase the difficulty of interpretation.\r\nHere, we introduce Effects.jl which translates the fitted model, including estimated uncertainty, back into data space.\r\nUsing Effects.jl, it is possible to generate effects plots that enable rapid visualization and interpretation of regression models.", "description": "Regression is a foundational technique of statistical analysis, and many common statistical tests are based on regression models (e.g., ANOVA, t-test, correlation tests, etc.).\r\nDespite the expressive power of regression models, users often prefer the simpler procedures because regression models themselves can be difficult to interpret.\r\nMost notably, the interpretation of individual regression coefficients (including their magnitude, sign, and even significance) changes depending on the presence or even centering/contrast coding of other terms or interactions.\r\nFor instance, a common source of confusion in regression analysis is the meaning of the intercept coefficient.\r\nOn its own, this coefficient corresponds to the grand mean of the independent variable, but in the presence of a contrast-coded categorical variable, it can correspond to the mean of the baseline level of that variable, the grand mean, or something else altogether, depending on the contrast coding scheme that is used.\r\nEffects.jl provides a general-purpose tool for interpreting fitted regression models by projecting the effects of one or more terms in the model back into \"data space\", along with the associated uncertainty, fixing other the value of other terms at typical or user-specified values.\r\nThis makes it straightforward to interrogate the estimated effects of any predictor at any combination of other predictors' values.\r\nBecause these effects are computed in data space, they can be plotted in parallel format to raw or aggregated data, enabling intuitive model interpretation and sanity checks.", "recording_license": "", "do_not_record": false, "persons": [{"id": 3828, "code": "3EFERC", "public_name": "Phillip Alday", "biography": "Phillip was a struggling mathematician, then a linguist and now a neuroscientist, but always a hacker.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11706, "guid": "69e137c3-99a7-54d9-909f-2d2ab8109934", "logo": "", "date": "2021-07-28T14:30:00+00:00", "start": "14:30", "duration": "00:05", "room": "Green", "slug": "juliacon2021-11706-opening-remarks", "url": "https://pretalx.com/juliacon2021/talk/3JYPC9/", "title": "Opening remarks", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Opening remarks", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 11700, "guid": "550fc076-1c39-5770-8ed8-8a7c2a2fe906", "logo": "", "date": "2021-07-28T14:35:00+00:00", "start": "14:35", "duration": "00:45", "room": "Green", "slug": "juliacon2021-11700-keynote-jan-vitek-", "url": "https://pretalx.com/juliacon2021/talk/7WYDH3/", "title": "Keynote (Jan Vitek)", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Julia - Is it a great language, or it is the greatest language!", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 11837, "guid": "12e4ea92-3920-5471-a9af-08df61daebd3", "logo": "", "date": "2021-07-28T15:20:00+00:00", "start": "15:20", "duration": "00:40", "room": "Green", "slug": "juliacon2021-11837-keynote-william-kahan-debugging-tools-for-floating-point-code", "url": "https://pretalx.com/juliacon2021/talk/UKVUHW/", "title": "Keynote: William Kahan - Debugging Tools for Floating-Point Code", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Debugging tools widely used for almost all other programs are inadequate\r\nfor floating-point programs because these are so different. Suitable tools\r\nappeared in 1980 with IEEE Standard 754 for Floating-Point Hardware,\r\nbut such tools have gone largely undemandeded by customers who pay for\r\ndesigners and implementors of languages and operating systems. These\r\nalmost never support such tools. Their value has gone unappreciated.\r\nMAYBE A FEW EXAMPLES WILL CHANGE SOME MINDS.", "description": "William Kahan was instrumental in creating the IEEE 754-1985 standard for floating-point computation in the late 1970s and early 1980s. He developed a program called \u201cparanoia\u2019 in the 1980s to test for potential floating point bugs and developed the Kahan summation algorithm which helps minimize errors introduced when adding a sequence of finite precision floating-point numbers. Kahan won the ACM A.M. Turing Award in 1989.", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 11836, "guid": "f356bc9f-2eca-57cc-8067-215960f06126", "logo": "", "date": "2021-07-28T16:00:00+00:00", "start": "16:00", "duration": "00:30", "room": "Green", "slug": "juliacon2021-11836-juliacon-trivia", "url": "https://pretalx.com/juliacon2021/talk/C9VRY3/", "title": "JuliaCon Trivia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Trivia questions related to Julia -- this is a fun optional activity for our first break.", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 9495, "guid": "c2ec709f-558b-5353-9c50-dd1a4e513c59", "logo": "/media/juliacon2021/submissions/LWVB39/logo_NobvM4b.png", "date": "2021-07-28T16:30:00+00:00", "start": "16:30", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9495-everything-you-need-to-know-about-chainrules-1-0", "url": "https://pretalx.com/juliacon2021/talk/LWVB39/", "title": "Everything you need to know about ChainRules 1.0", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "ChainRules is an automatic differentiation (AD)-independent ecosystem for forward-, reverse-, and mixed-mode primitives. It comprises ChainRules.jl, a collection of primitives for Julia Base, ChainRulesCore.jl, the utilities for defining custom primitives, and ChainRulesTestUtils.jl, the utilities to test primitives using finite differences. This talk provides brief updates on the ecosystem since last year and focuses on when and how to write and test custom primitives.", "description": "Automatic differentiation (AD), the ability to efficiently evaluate derivatives of arbitrary functions without computing derivatives by hand, enables efficient learning of many mathematical models. There are two components to every AD system: a collection of primitives (also called sensitivities or adjoints), and a way to keep track of and combine primitives using the chain rule of calculus in order to compute derivatives of arbitrary functions. While AD systems differ greatly in the latter, the set of primitives can be shared among them.\r\n\r\nThe ChainRules ecosystem provides the AD-independent collection of primitives for Julia Base (ChainRules.jl), utilities for defining custom primitives (ChainRulesCore.jl), and utilities for testing custom primitives using finite differences (ChainRulesTestUtils.jl). While not needed in principle, the ability to define custom primitives provides a way to speed up the computation by applying domain knowledge or mathematical insight, or get around limitations and performance issues of individual AD systems. In addition, ChainRulesCore.jl provides a suite of expressive differential types which allow comparing derivatives across multiple AD systems.\r\n\r\nSince last year the ecosystem has matured considerably, improving the user experience in a number of ways. Improvements include:\r\n- It is now possible to write rules for higher order functions (e.g. map) by calling back into the AD system\r\n- @non_differentiable makes it easy to define rules for non-differentiable functions\r\n- Testing custom primitives became easier since a random tangent (usually) does not have to be provided\r\n- It is now possible to test f/rrule like functions, meaning AD systems can be tested\r\n- ChainRules is now used by Zygote, Nabla, ForwardDiff2, and ReversePropagation\r\n\r\nThis talk will start by briefly introducing the ChainRules ecosystem, and highlighting the most important new features since last year. Those unfamiliar with the general idea of ChainRules are encouraged to watch last year\u2019s talk on ChainRules first, since the core of the talk is a comprehensive guide to using, writing, and testing custom primitives. In particular, the talk will explain when it is advantageous to write custom primitives compared to using an AD system on its own, the interface for writing custom primitives and the associated supporting functionality, as well as why and how to test primitives by finite differencing methods.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10068, "code": "PG7DEE", "public_name": "Miha Zgubic", "biography": "Miha is a theoretical physicist by training and holds an MSci degree from Imperial College London. After completing his Masters, he moved to the countryside to pursue a PhD at the University of Oxford where he analysed the data from the Large Hadron Collider at CERN searching for a rare decay of the Higgs boson. He now works as a Research Software Engineer at Invenia Labs, where he builds tools that accelerate research in electricity grid efficiency.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9725, "guid": "e17fde37-c4d8-5721-a51d-71b396c06e13", "logo": "", "date": "2021-07-28T17:00:00+00:00", "start": "17:00", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9725-enzyme-jl-reverse-mode-differentiation-on-llvm-ir-for-julia", "url": "https://pretalx.com/juliacon2021/talk/UDJ7SJ/", "title": "Enzyme.jl -- Reverse mode differentiation on LLVM IR for Julia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Enzyme (https://enzyme.mit.edu) is a reverse mode auto-differentiation tool that performs automatic differentiation over LLVM intermediate representation and synthesis high-performance reverse-mode functions. We will discuss how Enzyme.jl integrates with the Julia compiler and special considerations required for differentiating a dynamic programming language such as Julia.", "description": "Automatic differentiation (AD) is key to training neural networks, bayesian inference, and scientific computing. This talk presents Enzyme.jl, a Julia frontend for the Enzyme high performance LLVM automatic differentiation (AD) toolkit. By operating at a low level, Enzyme is able to run optimizations prior to differentiation and is therefore highly efficient on scalar code and can support mutation out of the box. We explain how Enzyme.jl integrates with the Julia compiler, supports synthesis for Julia GPU kernels, and propagates Julia knowledge of types to the lower-level tool. We will discuss ongoing work to extend Enzyme.jl to be able to differentiate through Julia language features like dynamic calls and garbage collection. We will conclude by describing the potential of combining high level and low level systems to get the benefit of both algebraic and instruction level optimizations, and using Enzyme.jl in other AD systems such as Zygote.jl or Diffractor.jl to perform differentiation of foreign function calls, enabling cross-language AD.", "recording_license": "", "do_not_record": false, "persons": [{"id": 903, "code": "3C7UBC", "public_name": "Valentin Churavy", "biography": "PhD Student at MIT", "answers": []}, {"id": 10358, "code": "FEJFGM", "public_name": "William Moses", "biography": "PhD Candidate @ MIT", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9938, "guid": "5afbbf6d-1a74-54ba-87e9-43033ba3dd6b", "logo": "", "date": "2021-07-28T17:30:00+00:00", "start": "17:30", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9938-a-tour-of-the-differentiable-programming-landscape-with-flux-jl", "url": "https://pretalx.com/juliacon2021/talk/ZEV3MR/", "title": "A Tour of the differentiable programming landscape with Flux.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Deep learning has grown steadily and there has been rising interest from various groups to incorporate ML techniques in their modelling via differentiable programming. Software 2.0 as its known, is going to need a large resource pool of tools to actualise its goal. In this talk, we will discuss how the Flux.jl stack along with Zygote and next-gen AD tooling is enabling differentiable programming already in a variety of domains and tour across the packages and projects that are taking part in it.", "description": "Machine Learning has come a long way in the past decade. With differentiable programming we have seen a renewed interest from numerous communities to apply ML techniques to diverse fields through scientific machine learning. Traditional deep learning has seen many strides with larger, more compute-intensive models which need increasingly complex training routines that push the boundaries of the current state-of-the-art.\r\n\r\nIn this talk, we will go through the depth of the machine learning and differentiable programming ecosystem in Julia through the [FluxML](https://github.com/FluxML) stack.  We shall discuss the various tools and features available to the users through the advances in the ecosystem and the next-gen tooling required to allow even more expressive modelling possible in Julia.\r\n\r\nWe will also take note of the new packages and techniques being developed in domains such as differentiable physics, [chemistry](https://github.com/aced-differentiate/AtomicGraphNets.jl), graph networks, [molecular simulation](https://juliamolsim.github.io/Molly.jl/stable/differentiable/) and [multi-GPU training](https://julialang.org/jsoc/gsoc/hpc/#distributed_training) etc.\r\n\r\nWe will also talk about the development effort in the [Flux](https://github.com/FluxML/Flux.jl) stack including performance enhancements, better coverage of CUDA, NNlib optimisations for the CPU and the new composable and functional optimisers via [Optimisers.jl](https://github.com/FluxML/Optimisers.jl) etc.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1160, "code": "83D8SQ", "public_name": "Dhairya Gandhi", "biography": "Dhairya Gandhi is a data scientist at Julia Computing Inc. and is the lead developer of the Machine Learning framework Flux.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9716, "guid": "5f9d3151-1e46-5d4c-ade0-7f1473dbf48d", "logo": "", "date": "2021-07-28T17:40:00+00:00", "start": "17:40", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9716-learning-to-align-with-differentiable-dynamic-programming", "url": "https://pretalx.com/juliacon2021/talk/QB8EC8/", "title": "Learning to align with differentiable dynamic programming", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "The alignment of two or more biological sequences is one of the main workhorses in bioinformatics because it can quantify similarity and reveal conserved patterns. We provided a differential version of the two most popular algorithms for sequence alignment: the Needleman\u2013Wunsch and Smith-Waterman algorithms. Using ChainRulesCore.jl, the gradients can be used directly in combination with bioinformatics and machine learning libraries.", "description": "The alignment of two or more biological sequences is one of the main workhorses in bioinformatics because it can quantify similarity and reveal conserved patterns. Dynamic programming allows for rapidly computing the optimal alignment between two sequences by recursively splitting the problem into smaller tractable choices, i.e., deciding whether it is best to extend a current alignment or introduce a gap in one of the sequences. This process leads to the optimal alignment score and backtracking yields the optimal alignment. By departing from a collection of pairwise alignments, one can heuristically compute a multiple sequence alignment of many sequences. If one is interested in the effect of a small change in the alignment parameter or the sequences, one has to compute the alignment score gradient with respect to these inputs. Regrettably, computing this gradient is not possible because the individual maximisation (minimisation) steps in the dynamic programming are non-differentiable.\r\n\r\nHowever, Mensch and Blondel recently showed that by smoothing the maximum operator, for example, by regularising with an entropic term, one can design fully differentiable dynamic programming algorithms. The individual smoothed maximum operators have various desirable properties, such as being efficient to compute, sparsity, or probabilistic interpretation. Departing from this work, we created a differentiable version of the Needleman\u2013Wunsch and Smith-Waterman algorithm. Using ChainRulesCore.jl, we allowed this gradient to be compatible with Julia's autodiff ecosystem.\r\n\r\nThe resulting gradient has an immediate diagnostic and statistical interpretation, such as computing the Fisher information to create uncertainty estimates. Furthermore, it enables us to use sequence alignment in differentiable computing, allowing one to learn an optimal substitution matrix and gap cost from a set of homologous sequences. The flexibility allows these parameters to vary at different regions in the sequences, for example, depending on the secondary structure. One can also change this around and fix the alignment parameters and optimise the sequences for alignment. This scheme allows for finding consensus sequences, which can be useful in creating a multiple sequence alignment. More broadly, our algorithm can be incorporated in arbitrary artificial neural network architectures (using e.g. Flux.jl), making it an attractive alternative to the popular convolution neural networks, LSTMs or transformer networks currently used to learn from biological sequences.", "recording_license": "", "do_not_record": false, "persons": [{"id": 961, "code": "T3ZCAP", "public_name": "Michiel Stock", "biography": "I am a postdoctoral researcher at Ghent University. My interest is in using computational intelligence to understand and design biological systems.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9930, "guid": "c222c4cc-35a1-5429-af2f-51c3f8f995c9", "logo": "", "date": "2021-07-28T17:50:00+00:00", "start": "17:50", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9930-partitions-and-chains-enabling-batch-processing-for-your-data", "url": "https://pretalx.com/juliacon2021/talk/Z7ZLTP/", "title": "Partitions and chains: enabling batch processing for your data", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "While big data isn't new anymore, building efficient pipelines to parse, analyze, transform, aggregate, and save all this data is still a tricky business. Come learn about new tools across the JuliaData family of packages for batch processing data, allowing automatic use of multithreading for data processing tasks.", "description": "I want to give a overview of the next \"phase\" of functionality we've been building across the data ecosystem and some walk-throughs of how the functionality is already being leveraged, including:\r\n  * The ChainedVector array type, which allows treating \"batches\" of arrays as one long array, while allowing efficient multithreading and other concurrent operations on the data automatically\r\n  * Tables.partitions: The Tables.jl package now supports \"batches\" of data for sinks to process, with a focus on enabling multithreaded sink processing of source partitions\r\n  * The TableOperations.jl package provides the `makepartitions` and `joinpartitions` utility functions for facilitating working with partitions and your data\r\n  * Examples of how packages are already taking advantage: Arrow.jl, CSV.jl, JuliaDB.jl, Parquet.jl, and Avro.jl", "recording_license": "", "do_not_record": false, "persons": [{"id": 1166, "code": "MQ3SJP", "public_name": "Jacob Quinn", "biography": "Been a Julia enthusiast for a long time, since Julia 0.1! Always been interested in data engineering, making data processing more efficient, and various data formats, and Julia is just such a fun tool to dive into these kinds of problems.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11882, "guid": "0b3b7f6a-1f48-5fb8-b4cb-1cc1ffe86205", "logo": "", "date": "2021-07-28T18:00:00+00:00", "start": "18:00", "duration": "01:00", "room": "Green", "slug": "juliacon2021-11882-gathertown-social-break", "url": "https://pretalx.com/juliacon2021/talk/SLGTWB/", "title": "GatherTown -- Social break", "subtitle": "", "track": null, "type": "Social hour", "language": "en", "abstract": "Join us on Gather.town for a social hour.\r\n\r\nIt is a virtual location where we will facilitate the poster sessions, social gatherings, and hackathon. You can join the space using the URL: https://gather.town/invite?token=3QYkt8gX.\r\n\r\nYou should have received the password through Eventbrite", "description": "", "recording_license": "", "do_not_record": true, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 9489, "guid": "8e735eef-523b-56c6-867a-af9274a765cd", "logo": "/media/juliacon2021/submissions/NLG9FQ/logo-text_Es5VNyy.png", "date": "2021-07-28T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9489-building-on-alphazero-with-julia", "url": "https://pretalx.com/juliacon2021/talk/NLG9FQ/", "title": "Building on AlphaZero with Julia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In this talk, we give an introduction to the AlphaZero algorithm and discuss some research challenges of using it beyond board games. In an effort to make this algorithm widely accessible to students and researchers, we introduce [AlphaZero.jl](https://github.com/jonathan-laurent/AlphaZero.jl). We show how this package leverages Julia's strengths to provide an implementation that is simple and flexible, while being up to two orders of magnitude faster than comparable Python implementations.", "description": "Deepmind's AlphaZero algorithm illustrates a general methodology of combining learning and search to solve complex combinatorial problems. Yet, despite its much-publicized success at the game of Go and a wide range of potential applications, few researchers have managed to build on it.\r\n\r\nIn an effort to make AlphaZero widely accessible to students and researchers, we introduce [AlphaZero.jl](https://github.com/jonathan-laurent/AlphaZero.jl). Leveraging Julia's unique strengths, this package provides an implementation of Deepmind's algorithm that is simple and flexible, while being up to two orders of magnitude faster than comparable Python implementations.\r\n\r\nIn this talk, we give a short lecture on the AlphaZero algorithm and discuss some research challenges of using it to solve problems beyond board games. Then, we introduce our [AlphaZero.jl](https://github.com/jonathan-laurent/AlphaZero.jl) package. We show how Julia enables a unique combination of simplicity, flexibility and speed, while also identifying areas in which improvements to the Julia ecosystem could lead to further performance gains. We conclude the talk with more general thoughts on how we believe Julia can have a transformative impact on reinforcement-learning research.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10059, "code": "AKVCHV", "public_name": "Jonathan Laurent", "biography": "Jonathan Laurent is a PhD student in Computer Science at Carnegie Mellon University. His current research interests lie at the intersection of machine learning and automated theorem proving.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9764, "guid": "28bf408b-9f50-52f9-9f18-7ef82cd464ae", "logo": "", "date": "2021-07-28T19:30:00+00:00", "start": "19:30", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9764-bayesian-neural-ordinary-differential-equations", "url": "https://pretalx.com/juliacon2021/talk/FJLE7U/", "title": "Bayesian Neural Ordinary Differential Equations", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We answer the question: \u201cCan Bayesian learning frameworks be integrated with Neural ODE\u2019s to robustly quantify the uncertainty in the weights of a Neural ODE?\u201d for the following categories of inference methods: (a) NUTS samples and stochastic frameworks like (b) SGLD, SGHMC. We test these methods on physical systems and ML datasets like MNIST. Finally, we demonstrate probabilistic, symbolic recovery of missing terms from dynamical systems using universal ODEs.", "description": "Recently, Neural Ordinary Differential Equations has emerged as a powerful framework for modeling physical simulations without explicitly defining the ODEs governing the system, but instead learning them via machine learning. However, the question: \u201cCan Bayesian learning frameworks be integrated with Neural ODE\u2019s to robustly quantify the uncertainty in the weights of a Neural ODE?\u201d remains unanswered. In an effort to address this question, we primarily evaluate the following categories of inference methods: (a) The No-U-Turn MCMC sampler (NUTS), (b) Stochastic Gradient Hamiltonian Monte Carlo (SGHMC) and (c) Stochastic Langevin Gradient Descent (SGLD). We demonstrate the successful integration of Neural ODEs with the above Bayesian inference frameworks on classical physical systems, as well as on standard machine learning datasets like MNIST, using GPU acceleration. On the MNIST dataset, we achieve a posterior sample accuracy of 98.5% on the test ensemble  of 10,000 images.  This is a performance competitive with current state-of-the-art image classification methods, which meanwhile lack our method's ability to quantify the confidence in its predictions. \r\n\r\nSubsequently, for the first time, we demonstrate the successful integration of variational inference with normalizing flows and Neural ODEs, leading to a powerful Bayesian Neural ODE object. \r\n\r\nFinally, considering a predator-prey model and an epidemiological system, we demonstrate the probabilistic identification of model specification in partially-described dynamical systems using universal ordinary differential equations. Together, this gives a scientific machine learning tool for probabilistic estimation of epistemic uncertainties.\r\n\r\nIn this study, we used the Julia differentiable programming stack to compose the Julia differential equation solvers with the Turing probabilistic programming language. The study was performed without modifications to the underlying libraries due to the composability afforded by the differentiable programming stack.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4000, "code": "LWEMM8", "public_name": "Raj Dandekar", "biography": "4th year PhD student at the Julia Lab, MIT.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9929, "guid": "aef51a91-1179-5c97-8620-b1e3c63ab38a", "logo": "/media/juliacon2021/submissions/HLFY9G/16347008_aDjo62a.png", "date": "2021-07-28T20:10:00+00:00", "start": "20:10", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9929-pomdps-jl-and-interactive-assignments-in-julia", "url": "https://pretalx.com/juliacon2021/talk/HLFY9G/", "title": "POMDPs.jl and Interactive Assignments in Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "POMDPs.jl is a leading research tool for partially observable Markov decision processes that also enables new teaching opportunities. This talk will describe POMDPs.jl and the Decision Making under Uncertainty class at CU Boulder. Each assignment in this class includes an open-ended challenge problem where students implement algorithms in Julia that are auto-graded. The system enables challenging assignments such as programming MCTS with a 100ms time limit and DQN for reinforcement learning.", "description": "The course materials website, including notes and homework assignments, is located here: https://github.com/zsunberg/CU-DMU-Materials, and the Julia package for the course is located here: https://github.com/zsunberg/DMUStudent.jl. The algorithms that the students implement in Julia include Value Iteration, Monte Carlo Tree Search, DQN, and QMDP. The algorithms are graded on the students' machine to ease debugging. This talk will give a very-brief overview of POMDPs.jl, and discuss the course, what went well, and what aspects turned out to be challenging.\r\n\r\n(this talk could be expanded into a 30 minute talk if there is enough interest).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10427, "code": "NRUUVW", "public_name": "Zachary Sunberg", "biography": "Assistant Professor of Aerospace Engineering at the University of Colorado", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9952, "guid": "307708f7-51c2-5fa2-8fba-8c05a6f2c129", "logo": "", "date": "2021-07-28T20:20:00+00:00", "start": "20:20", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9952-probabilistic-model-checking-using-pomdpmodelchecking-jl", "url": "https://pretalx.com/juliacon2021/talk/7GYDRZ/", "title": "Probabilistic Model Checking using POMDPModelChecking.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Autonomous systems are often required to operate in partially observable environments. They must reliably execute a specified objective even with incomplete information about the state of the environment. Model checking allows us to synthesize a decision policy that satisfies a linear temporal logic (LTL) formula in a POMDP. By reformulating the model checking problem into an AI planning problem, we can use state-of-the-art POMDP planning algorithms to solve model checking problems.", "description": "In this talk we will show how we built a model checking library in a few lines of Julia by integrating an LTL manipulation library to the JuliaPOMDP ecosystem. With this library we can compute decision policies with probabilistic guarantees for various range of partially observable problems: drone surveillance, robot exploration, pedestrian avoidance for autonomous driving.\r\n\r\nThis lightning talk will be organized as follows:\r\n-  Introduction to the problem of POMDP/MDP model checking: quick overview of JuliaPOMDP [1]\r\n-  Introduction to linear temporal logic manipulation using Spot.jl [2]: Spot.jl is a wrapper of spot [3], a c++ library for LTL manipulation. The Julia wrapper is built using CxxWrap.jl. We will demonstrate some visual examples of how spot is used to convert a temporal logic formula into a finite state machine and how we can visualize it (material will be inspired from the Spot.jl tutorial but remodeled to fit the talk format).\r\n- Introduction to POMDPModelChecking.jl [4]: we will show how we can reuse the whole JuliaPOMDP ecosystem to solve model checking problems. Our library exposes two solvers (ModelCheckingSolver and ReachabilitySolver), which takes as input any Julia POMDP model and an LTL formula and outputs a policy. Internally, the solver creates a new POMDP model which is a composition of the original model, and a finite state machine created by Spot.jl. This new model can then be solved by any JuliaPOMDP planning algorithm. The theoretical justification of reformulating the model checking problem into a planning problem has been detailed in previous work [5].\r\n- Gallery: We will show visual examples of decision policies computed using POMDPModelChecking.jl on the rock sample POMDP problem [6].\r\n\r\n\r\nReferences:\r\n[1] https://github.com/JuliaPOMDP\r\n[2] https://github.com/sisl/Spot.jl\r\n[3] https://spot.lrde.epita.fr/index.html\r\n[4] https://github.com/sisl/POMDPModelChecking.jl\r\n[5] M. Bouton, J. Tumova, and M. J. Kochenderfer, \"Point-Based Methods for Model Checking in Partially Observable Markov Decision Processes,\" in AAAI Conference on Artificial Intelligence (AAAI), 2020.\r\n[6] https://github.com/JuliaPOMDP/RockSample.jl\r\n[7] M. Bouton, \"Safe and Scalable Planning Under Uncertainty for Autonomous Driving\", PhD thesis, Stanford University, 2020.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10520, "code": "VQFKCJ", "public_name": "Maxime Bouton", "biography": "I am an AI Researcher at Ericsson Research. My research interests lie in reinforcement learning, planning under uncertainty, and AI safety. Prior to joining Ericsson I completed my PhD at Stanford University under the supervision of Prof. Mykel Kochenderfer. My thesis was about safe and scalable planning under uncertainty for autonomous driving and all the code was written in Julia. At Juliacon 2021 I will present work I did during my thesis.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11889, "guid": "426c6a17-fcbb-5e53-ac22-507c29df080b", "logo": "", "date": "2021-07-28T20:30:00+00:00", "start": "20:30", "duration": "01:00", "room": "Green", "slug": "juliacon2021-11889-gathertown-social-break", "url": "https://pretalx.com/juliacon2021/talk/YXJ8YQ/", "title": "GatherTown -- Social break", "subtitle": "", "track": null, "type": "Social hour", "language": "en", "abstract": "Join us on Gather.town for a social hour.\r\n\r\nIt is a virtual location where we will facilitate the poster sessions, social gatherings, and hackathon. You can join the space using the URL: https://gather.town/invite?token=3QYkt8gX.\r\n\r\nYou should have received the password through Eventbrite", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}], "Red": [{"id": 9868, "guid": "94849d97-1bfd-54b7-bb19-6c33300e02ff", "logo": "/media/juliacon2021/submissions/8LL9QH/jc-logo_1024x1024_0Z2zqxf.png", "date": "2021-07-28T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9868-put-some-constraints-into-your-life-with-juliacon-straints-", "url": "https://pretalx.com/juliacon2021/talk/8LL9QH/", "title": "Put some constraints into your life with JuliaCon(straints)", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "The freshly born JuliaConstraints GitHub organization provides a combination of packages around the theme of Constraint Programming and Combinatorial Optimization.\r\nThis talk introduces the whole ecosystem of JuliaConstraints packages and its main dependencies. It focuses on the LocalSearchSolvers.jl framework (and CBLS.jl, its interface with JuMP) for Constraint-Based Local Search. We also cover the utility packages that we hope to share with the Julia and Constraint Programming communities.", "description": "Problem-solving often consists in two actions: model and solve. The holy grail of Constraint Programming is to have the human (user) model the problem and have the machine (solver) solve it. All the smartness should be in the solver.\r\n**JuliaConstraints**, a freshly hatched GitHub organization, is a first attempt to provide common grounds to the growing Constraint Programming community in Julia while tackling that holy grail.\r\n \r\nWe will approach the different blocks of the ecosystem through the lens of shared interfaces, shared instances and models, and shared internals. We will illustrate the use, pros and cons of problem-solving through Constraint Programming with different solvers and frameworks such as *ConstraintSolver.jl* and *LocalSearchSolvers.jl*.\r\n \r\nA possible common interface, building on the popular *JuMP.jl*, is already available for some solvers. An attempt to write shared models in JuMP syntax as just started as *ConstraintModels.jl*. Various problems have been modeled such as:\r\n- sudoku\r\n- n-queens\r\n- magic square\r\n- chemical equilibrium\r\n- quadratic assignment\r\n- golomb ruler\r\n- minimum and maximum cuts in networks\r\n- traveler salesman problem\r\n- scheduling\r\n \r\nA store of instances, generators and global information combinatorial optimization problems is also available as *COPInstances.jl* (tentative name, WIP). This package aims for a larger audience than simply CP solvers, and we would be glad to see it grows for other optimization packages.\r\n \r\nFinally, JuliaConstraints hosts also some internal packages, mainly used within the *LocalSearchSolvers.jl* framework, but with the hope, that some parts can be shared with other solvers:\r\n- *Constraints.jl*: a store of usual constraints in CP\r\n- *ConstraintDomains.jl*: structures and methods for the domain of variables\r\n- *CompositionalNetworks.jl*: a glass-box neural networks for scalable compositions of functions\r\n- A very nice logo with chains and Julia (in)famous colored dots\r\n \r\nThere is an extensive list of incredible Julia packages and internal methods that provide all the computational power and the expressive syntax of the Constraint Programming ecosystem in Julia. We will also highlight the key external dependencies such as JuMP, Evolutionary, Dictionaries, Base.Threads, and more!\r\n \r\nIncidentally, we will try to have some fun with an interactive model session (if interactivity is allowed in the COVID-19 context) for LocalSearchSolvers.jl. Did we mention that the solving speed scale super linearly with the number of thread/process?", "recording_license": "", "do_not_record": false, "persons": [{"id": 10457, "code": "LZTBFS", "public_name": "Jean-Fran\u00e7ois BAFFIER (azzaare@github)", "biography": "Jean-Fran\u00e7ois Baffier is an academic researcher at the RIKEN Center for Advanced Intelligence Project (AIP), and a consultant in Artificial Intelligence, Big Data Science, Data Structures, and Algorithms. As an academic, he gives back to society through fundamental research in computer science supplemented by open source libraries and softwares.\r\nHis current research project involves the study of the \u201cAnalysis of information networks,\u201d the \u201cSmart compression for high-scalability of data structures,\u201d and \u201cExplainable Artificial Intelligence.\u201d Other topic of interest covers modeling of failures and routing in Networks, Game Analysis, and AI for Games.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9864, "guid": "c37ff5c2-f856-5c78-9104-01a312fbeb8d", "logo": "", "date": "2021-07-28T13:00:00+00:00", "start": "13:00", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9864-julog-jl-prolog-like-logic-programming-in-julia", "url": "https://pretalx.com/juliacon2021/talk/3PGHMY/", "title": "Julog.jl: Prolog-like Logic Programming in Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Julog.jl is a library and domain-specific language for Prolog-like logic programming in Julia. This lightning will introduce logic programming at a high level, how Julog can be used to solve first-order logic problems, how its functionality can be integrated with custom Julia functions, downstream use cases, and some next steps for making logic and constraint programming fast and accessible for Julia users.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10333, "code": "CFLQJP", "public_name": "Xuan (Tan Zhi Xuan)", "biography": "Xuan (Sh-YEN, IPA: \u0255\u0265\u025bn) is a PhD student at MIT in the Computational Cognitive Science and Probabilistic Computing research groups. Their current research focuses on inferring the hidden structure of human motivations by modeling agents as probabilistic programs, in the hope of aligning AI with the higher-order goals, values, and principles that humans strive (in part) to live by.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9822, "guid": "e72468e6-7be7-59fb-93bd-608964339e10", "logo": "", "date": "2021-07-28T13:10:00+00:00", "start": "13:10", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9822-solving-discrete-problems-via-boolean-satisfiability-with-julia", "url": "https://pretalx.com/juliacon2021/talk/GNB93V/", "title": "Solving discrete problems via Boolean satisfiability with Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Many discrete problems in mathematics and computer science can be encoded into Boolean satisfiability (SAT) problems, and then solved by one of the many SAT \"solvers\" written in C or C++, which are now capable of solving problems with millions of variables. \r\n\r\nIn order to understand the algorithms and trade-offs involved, we developed a simple SAT solver in pure Julia that is performant for small systems. We also have developed simple tools to encode discrete problems like sudoku into SAT.", "description": "Many discrete problems in computer science can be encoded into Boolean satisfiability (SAT) problems. In such problems, all variables are Boolean (true or false), but are restricted by *constraints* between the Boolean variables. \r\n\r\nOver the last 50 years there have been remarkable developments in understanding how to solve these constraint satisfaction problems, and many open-source solvers have been developed, some of which have been wrapped in Julia, which are capable of solving problems with millions of variables. However, their code is often difficult to understand and modify.\r\n\r\nIn order to increase the awareness and accessibility of SAT solvers in the community, and to encourage experimentation, we developed a simple solver in pure Julia that is performant for small systems. \r\n\r\nWe also have developed a tool that allows us to write down discrete problems, such as sudoku, symbolically in Julia, and encode them into SAT.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1022, "code": "TJJRTG", "public_name": "David P. Sanders", "biography": "Professor of Computational Science at the Universidad Nacional Aut\u00f3noma de M\u00e9xico and visiting professor at MIT.\r\n\r\nInterested in computational science, interval arithmetic, and numeric-symbolic computing.\r\n\r\nAuthor of the JuliaIntervals suite of packages for interval arithmetic, and various tutorials on Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9953, "guid": "662069ff-db53-5247-b81f-666c0f9607bd", "logo": "", "date": "2021-07-28T13:20:00+00:00", "start": "13:20", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9953-running-programs-forwards-backwards-and-everything-in-between", "url": "https://pretalx.com/juliacon2021/talk/LRHPUH/", "title": "Running Programs Forwards, Backwards, and Everything In Between", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Every method defines a relation, which contains all the information we need to query possible values of any of the inputs or outputs given information on the others. This talk introduces parametric relational programming, which given a method M; information on any of M's variables, and a query set Q of variables of interest, compiles a new method M\u0302 that computes possible values of variables in Q. This unifies the forward and inverse execution (and everything in between) as forms of inference.", "description": "This talk should be of interest to people interested in any of:\r\n- Compiler transformations\r\n- Probabilistic programming\r\n- Inference and machine learning", "recording_license": "", "do_not_record": false, "persons": [{"id": 10521, "code": "BZXF73", "public_name": "Zenna Tavares", "biography": "Zenna Tavares is a postdoctoral researcher at MIT under the supervision of Armando Solar Lezama. His interests are in probabilistic and causal inference, programming languages, and human-inspired artificial intelligence.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9875, "guid": "e18be6df-932b-5635-8622-ccaba8467c4e", "logo": "", "date": "2021-07-28T13:30:00+00:00", "start": "13:30", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9875-funsql-a-library-for-compositional-construction-of-sql-queries", "url": "https://pretalx.com/juliacon2021/talk/FEG39B/", "title": "FunSQL: a library for compositional construction of SQL queries", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Julia programmers sometimes need to interrogate data with the Structured Query Language (SQL).  But SQL is notoriously hard to write in a modular fashion. There is no way to reuse SQL query fragments among different queries.\r\n\r\nFunSQL exposes full expressive power of SQL with a compositional semantics. FunSQL allows you to build queries incrementally from small independent fragments.  This approach is particularly useful for building applications that programmatically construct SQL queries.", "description": "To introduce FunSQL, we will construct a practical query from healthcare informatics and then discuss how it works. We use a fragment of the [OMOP Common Data Model](https://github.com/OHDSI/CommonDataModel), a cross-platform database model for observational healthcare data.\r\n\r\nAs typical in healthcare, this schema is patient-centric. The table `person` contains de-identified information about patients including the unique identifier, approximate birthdate, and demographic information. To make this table available for FunSQL, we define it as follows.\r\n<pre>\r\nconst person =\r\n    SQLTable(:person, columns = [:person_id, :year_of_birth, :location_id])\r\n</pre>\r\n\r\nThe `patient` table has a foreign key to `location`, which specifies geographic location, typically down to a zipcode.\r\n<pre>\r\nconst location =\r\n    SQLTable(:location, columns = [:location_id, :city, :state, :zip])\r\n</pre>\r\n\r\nEach person is associated with clinical events: encounters with care providers, recorded observations, diagnosed conditions, performed procedures, etc. We will represent one of them.\r\n<pre>\r\nconst visit_occurrence =\r\n    SQLTable(:visit_occurrence, columns = [:visit_occurrence_id, :person_id, :visit_start_date])\r\n</pre>\r\n\r\nWith this background in place, let us suppose a physician scientist asks:\r\n\r\n*When was the last time each person, born in 2000 or earlier and living in Illinois, was seen by a care provider?*\r\n\r\nThis research question could be answered using FunSQL.\r\n\r\n<pre>\r\nFrom(person) |>\r\nWhere(Get.year_of_birth .<= 2000) |>\r\nJoin(:location => From(location),\r\n     on = (Get.location_id .== Get.location.location_id)) |>\r\nWhere(Get.location.state .== \"IL\") |>\r\nJoin(:visit_group => From(visit_occurrence) |>\r\n                     Group(Get.person_id),\r\n     on = (Get.person_id .== Get.visit_group.person_id),\r\n     left = true) |>\r\nSelect(Get.person_id,\r\n       :max_visit_start_date =>\r\n           Get.visit_group |> Agg.Max(Get.visit_start_date))\r\n</pre>\r\n\r\nFunSQL provides operations with familiar SQL names such as `From`, `Where`, `Join`, `Group`, and `Select`, which can be chained together using the `|>` operator. The notation `:location => From(location)`, and its counterpart `Get.location.state`, lets us arrange table attributes hierarchically. Most importantly, the query can be constructed and tested incrementally, one operation at a time.\r\n\r\nContrast this with a hand-crafted SQL query.\r\n\r\n<pre>\r\nSELECT p.person_id, MAX(vo.visit_start_date)\r\nFROM person p\r\nJOIN location l ON (p.location_id = l.location_id)\r\nLEFT JOIN visit_occurrence vo ON (p.person_id = vo.person_id)\r\nWHERE (p.year_of_birth <= 2000) AND (l.state = 'IL')\r\nGROUP BY p.person_id\r\n</pre>\r\n\r\nAlthough the SQL query is compact, it cannot be incrementally constructed. Indeed, if we follow the progression of the research question, we arrive at:\r\n\r\n<pre>\r\nFROM person p\r\nWHERE (p.year_of_birth <= 2000)\r\nJOIN location l ON (p.location_id = l.location_id)\r\n...\r\n</pre>\r\n\r\nBut this is not valid SQL.  SQL enforces a rigid order of clauses: `FROM`, `JOIN`, `WHERE`, `GROUP BY`. As we refine a SQL query, attempting to incrementally correlate it with the research question, we are always forced to backtrack and rebuild it. This is what makes SQL tedious and error-prone.\r\n\r\nFunSQL solves the problem of compositional query construction by representing individual operations as subqueries with a deferred `SELECT` list.\r\n<pre>\r\nq1 AS (SELECT ... FROM person)\r\nq2 AS (SELECT ... FROM q1 WHERE q1.year_of_birth <= 2000)\r\nq3 AS (SELECT ... FROM location)\r\nq4 AS (SELECT ... FROM q2 JOIN q3 ON (q2.location_id = q3.location_id))\r\nq5 AS (SELECT ... FROM q4 WHERE q4.state = 'IL')\r\nq6 AS (SELECT ... FROM visit_occurrence)\r\nq7 AS (SELECT ... FROM q6 GROUP BY q6.person_id)\r\nq8 AS (SELECT ... FROM q5 LEFT JOIN q7 ON (q5.person_id = q7.person_id))\r\n</pre>\r\n\r\nThe final subquery fixes the output columns.\r\n<pre>\r\nSELECT q8.person_id, q8.max_visit_start_date FROM q8\r\n</pre>\r\n\r\nOnce the output columns are known, each deferred `SELECT` list can be resolved automatically.  For instance, references `q1.year_of_bith`, `q2.location_id`, `q5.person_id` force `q1` to take the following form.\r\n<pre>\r\nq1 AS (SELECT person_id, year_of_birth, location_id FROM person)\r\n</pre>\r\n\r\nThis `SELECT` resolution also propagates aggregate expressions. Thus, `q7` becomes:\r\n<pre>\r\nq7 AS (SELECT q6.person_id,\r\n              MAX(q6.visit_start_date) AS max_visit_start_date\r\n       FROM q6\r\n       GROUP BY q6.person_id)\r\n</pre>\r\n\r\nThis approach provides a uniform compositional interface to the variety of SQL operations, preserving the expressive power of SQL while eliminating its stifling inflexibility.\r\n\r\nFor a Julia programmer, FunSQL realizes query operations as 1st class objects. Treated as values, they could be generated independently, assembled into composite operations, and remixed as needed. FunSQL lets us construct queries systematically, converging upon the research questions we wish to ask our databases.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10466, "code": "9MPXGK", "public_name": "Kyrylo Simonov", "biography": "The author of PyYAML, LibYAML, HTSQL, and DataKnots.", "answers": []}, {"id": 923, "code": "NWXJWH", "public_name": "Clark C. Evans", "biography": "Collaborator on YAML, HTSQL, DataKnots, and other projects that advance the usability of software systems.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9590, "guid": "25f1e5f5-4c90-530a-aa42-170d61f90c2f", "logo": "", "date": "2021-07-28T16:30:00+00:00", "start": "16:30", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9590-topopt-jl-topology-optimization-software-done-right-", "url": "https://pretalx.com/juliacon2021/talk/XV3AH8/", "title": "TopOpt.jl: topology optimization software done right!", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Topology optimization is a field lacking in good software tools. Most available software in this field either can\u2019t be installed easily on all operating systems, support one or a few simple types of problems, implement one or a few types of algorithms, lack modularity and a decent API, lack performance, or all of the above! TopOpt.jl is a Julian attempt to provide a modular, flexible and high performance tool for topology optimization researchers.", "description": "Topology optimization is a field that combines physics simulation and (mathematical) optimization to optimize the shapes and designs of physical systems. It is an extremely rich and fast growing field with its roots in structural and solid mechanics design but is quickly growing into other areas of physics and engineering. Being a fast growing research field, there is still no consensus on what functionality must be available in a decent topology optimization software. The ability to easily experiment with existing algorithms and easily define new problems to apply algorithms on is something that TopOpt.jl takes to a whole new level. Manually deriving gradients of long chained functions is still embarrassingly half of almost every important topology optimization paper in the field to this day! TopOpt.jl hopes to eliminate the need for this using automatic differentiation (Zygote.jl). Some custom adjoint rules are necessary to define for efficiency but automatic differentiation makes the software design and the API for defining custom adjoints much more pleasant than the status quo of re-inventing automatic differentiation for every new objective, constraint, sub-function, physical system, etc. The modular design of TopOpt.jl also allows a near complete segregation of the objective and constraint definitions from the mathematical optimization algorithm implementations which enables both to grow asynchronously appeasing to different audiences with different sets of expertise.", "recording_license": "", "do_not_record": false, "persons": [{"id": 3814, "code": "PFTTSC", "public_name": "Mohamed Tarek", "biography": "A topology optimization researcher, a co-maintainer of Turing.jl, a scientist at Pumas-AI, and an enthusiastic learner of anything \"scientific computing\".", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9804, "guid": "be8a8fa9-273b-5ed3-b02b-5864e684bfc4", "logo": "", "date": "2021-07-28T17:00:00+00:00", "start": "17:00", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9804-frankwolfe-jl-scalable-constrained-optimization", "url": "https://pretalx.com/juliacon2021/talk/99GSDN/", "title": "FrankWolfe.jl: scalable constrained optimization", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We present FrankWolfe.jl, a new Julia package implementing several Frank-Wolfe algorithms to optimize differentiable functions with convex constraints.\r\nThe Julia optimization ecosystem includes toolboxes for unconstrained optimization on one hand and domain-specific modelling languages for constrained optimization on the other hand.\r\nThis package offers the possibility to optimize functions defined as Julia code with DSL-based closed-form or arbitrary convex constraints in an efficient manner.", "description": "For large-scale and data-intensive optimization, first-order methods are often a favoured choice, motivated by faster iterations and lower memory requirements.\r\nFrank-Wolfe algorithms allow the optimization of a differentiable function over a convex set, solving a linear optimization problem at each iteration to determine a progress direction.\r\nEach of these linear subproblems is much cheaper than the quadratic subproblems solved by projected gradient algorithms.\r\n\r\nThe talk will present the package and how it fits an unaddressed spot in the Julia optimization landscape, comparing it with the DSL approaches such as JuMP and Convex.jl,\r\nStructuredOptimization.jl and to the other smooth optimization frameworks such as Optim.jl and JuliaSmoothOptimizers.\r\n\r\nAfter a quick overview of the algorithm, we will cover some interesting properties on specific optimization problems, in particular the solution sparsity preserved throughout the whole optimization process.\r\nSparsity means in particular that the iterates are a convex combination of a low number of extreme points of the feasible set which can result in low-rank matrices, sparse arrays or other specific structures depending on the feasible set.\r\n\r\nIn the last part of the talk, we will cover some insight gained from the development of the package on building generic algorithms and in particular managing to handle vertices assuming a vector space but not necessarily finite dimensions.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1216, "code": "DK9KDB", "public_name": "Mathieu Besan\u00e7on", "biography": "Mathieu is a researcher in computational mathematics working at the Zuse Institute Berlin. His interests span mixed-integer, convex optimization, applications in engineering and statistics.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9648, "guid": "2546b133-918c-5264-9901-9076d763c899", "logo": "", "date": "2021-07-28T17:30:00+00:00", "start": "17:30", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9648-modelling-cryptographic-side-channels-with-julia-types", "url": "https://pretalx.com/juliacon2021/talk/TEKDX9/", "title": "Modelling cryptographic side-channels with Julia types", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "In cryptographic embedded systems, power-line or RF emissions can leak secrets. We use Julia to model both attacks and defenses. Some of our custom integer and array types record information observable by attackers, such as Hamming weights of values. Others implement counter-measures, such as masking values across randomized shares. Julia\u2019s parametric type system conveniently allows us to stack these types without syntactic overhead when exploring or teaching side-channel security.", "description": "In hardware security, side-channel attackers can monitor analog signals, like the per-instruction power consumed. They can record this data during the execution of a cryptographic algorithm to gain additional information. Such leakage data can depend on intermediate values of the cipher, which themselves depend on the secret key. Hence, with such side-channel data, reconstructing the key of the cipher may become feasible.\r\n\r\nIn this talk, we focus on using Julia\u2019s type system to create a framework for generating, analyzing and protecting such side-channel data. For this purpose, we create custom types that behave like integers or arrays. When passing values of these types to a Julia implementation of a cryptographic algorithm, multiple dispatch automatically produces an instrumented or transformed version of that algorithm. Usually, this process does not require modifications to the algorithm\u2019s original implementation.\r\n\r\nWe look in particular at two different functionalities that we can integrate via such custom types:\r\n- To simulate potential side-channel attacks, it is useful to generate data traces that depend on intermediate values. We will show how to construct types that log a trace of information about the values processed. This reduces the need for access to analog recording hardware, which is particularly useful when teaching side-channel security concepts in student practicals.\r\n- To explore protection against side-channel attacks, values that depend on the secret key should never appear in memory without protection. We explore how integer and array-like types can be created to implement a range of techniques for splitting register values into multiple shares, to reduce the dependence of leakage data on the actual values processed.\r\n\r\nJulia\u2019s parametric type system allows us to arbitrarily stack those types on top of each other. For instance, protection types can be stacked on top of logging types. This construction allows us to conveniently collect traces of protected data which can be, for example, used to verify the effectiveness of the protection.\r\n\r\nPackage: https://github.com/parablack/CryptoSideChannel.jl\r\n<br>Documentation: https://parablack.github.io/CryptoSideChannel.jl/dev/\r\n<br>Dissertation: https://github.com/parablack/CryptoSideChannel.jl/raw/master/diss.pdf", "recording_license": "", "do_not_record": false, "persons": [{"id": 10288, "code": "9CZU7T", "public_name": "Simon Schwarz", "biography": "Postgraduate computer science student at the University of Cambridge, currently working with Markus Kuhn.", "answers": []}, {"id": 10303, "code": "KXAMEK", "public_name": "Markus Kuhn", "biography": "Senior Lecturer (associate professor) with the University of Cambridge Department of Computer Science.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9261, "guid": "23aab436-1995-54fd-8817-27ab32d05aa9", "logo": "", "date": "2021-07-28T17:40:00+00:00", "start": "17:40", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9261-lattice-reduction-using-lllplus-jl", "url": "https://pretalx.com/juliacon2021/talk/7XFSZB/", "title": "Lattice Reduction using LLLplus.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Lattice reduction is used in post-quantumn cryptography, digital communication, and number theory. Lattice tools will be introduced with a focus on the Lenstra-Lenstra-Lovacsz (LLL) technique. The [LLLplus.jl](https://github.com/christianpeel/LLLplus.jl) package will be demoed and shown to work with  user-defined data types such as [BitIntegers.jl](https://github.com/rfourquet/BitIntegers.jl).", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 3821, "code": "YXRYYS", "public_name": "Chris Peel", "biography": "Chris ran the [Bay Area Julia Users](https://www.meetup.com/Bay-Area-Julia-Users/) group from 2016 to 2020.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9901, "guid": "bbd677ff-0c0a-5bd6-87e1-5178438ff5d9", "logo": "/media/juliacon2021/submissions/EWFRHW/Rosenbrock_example_EDNDXbr.png", "date": "2021-07-28T17:50:00+00:00", "start": "17:50", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9901-speedmapping-jl-implementing-alternating-cyclic-extrapolations", "url": "https://pretalx.com/juliacon2021/talk/EWFRHW/", "title": "SpeedMapping.jl: Implementing Alternating cyclic extrapolations", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "SpeedMapping.jl implements Alternating cyclic extrapolations: a new and fast algorithm for accelerating optimization algorithms. It may be used for a large class of problems requiring a solution to the mapping *F(x) = x*. It also performs multivariate optimization often faster than L-BFGS or the nonlinear conjugate gradient method, especially with box-constraints. It will be useful in statistics, computer science, physics, biology or economics and many other fields.", "description": "The talk will briefly explain the ideas behind the method and demonstrate its use with two examples: *i)* computing a dominant eigenvalue by accelerating the power iteration *ii)* minimizing a multivariate Rosenbrock function with or without constraint by providing only the objective or only the gradient. Benchmarks will show significant speed gains over the L-BFGS and the nonlinear conjugate gradient.\r\n\r\nA notebook for the talk may be downloaded at https://github.com/NicolasL-S/SpeedMapping.jl/blob/main/Resources/SpeedMapping_JuliaCon2021.ipynb\r\n\r\nSpeedMapping may be installed directly from the REPL, or downloaded here: https://github.com/NicolasL-S/SpeedMapping.jl\r\n\r\nThe Alternating cyclic extrapolation method is detailed in:\r\n\r\nN. Lepage-Saucier, _Alternating cyclic extrapolation methods for optimization algorithms_, arXiv:2104.04974 (2021). https://arxiv.org/abs/2104.04974\r\n\r\nThe paper also shows other applications, such as a logistic regression, a large set of CUTEst unconstrained problems, accelerating the expectation-maximization (EM) algorithm for Poisson mixtures and for a proportional hazards regression with interval censoring, for canonical tensor decomposition, and for the method of alternating projections (MAP) applied to regressions with high-dimensional fixed effects.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10486, "code": "ATTQ9J", "public_name": "Nicolas Lepage-Saucier", "biography": "Canadian economist currently living in Toulouse, France. I'm interested in many fields, including numerical methods. Scarred for life by the experience of waiting six months for my estimates to converge.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9460, "guid": "12001dce-f1cb-560a-967f-077230020a36", "logo": "/media/juliacon2021/submissions/BGLQ3U/cutebanner_s71wQmy.png", "date": "2021-07-28T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9460--pluto-jl-one-year-later", "url": "https://pretalx.com/juliacon2021/talk/BGLQ3U/", "title": "\ud83c\udf88 Pluto.jl \u2014 one year later", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "[Pluto.jl](https://github.com/fonsp/Pluto.jl) is a notebook IDE for Julia, with a focus on interactivity and education. In this talk, you'll learn about our work during the past year, and our future plans.", "description": "Hi! We're the developers of Pluto.jl, and we have been busy!\r\n\r\n[Pluto.jl](https://github.com/fonsp/Pluto.jl) is a notebook IDE for Julia, with a focus on interactivity and education. In this talk, you'll learn about our work during the past year, which includes:\r\n\r\n- Built-in package manager\r\n- Macro support\r\n- Static site export\r\n- Interactive site export!\r\n- Integration with many packages\r\n- Disabling reactivity?\r\n- Automatically run notebooks as REST APIs (also in separate talk)\r\n- Tools for university education (also in separate talk)\r\n\r\nWe will also talk a bit about experimental features and future plans!", "recording_license": "", "do_not_record": false, "persons": [{"id": 4400, "code": "ECC83Q", "public_name": "Fons van der Plas", "biography": "Computers are too difficult!\r\n\r\n[https://github.com/fonsp](https://github.com/fonsp)", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9735, "guid": "e4bff4c5-5e45-5b15-989f-cf38305e0904", "logo": "", "date": "2021-07-28T19:30:00+00:00", "start": "19:30", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9735-julia-in-vs-code-what-s-new", "url": "https://pretalx.com/juliacon2021/talk/AUYF3X/", "title": "Julia in VS Code - What's New", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We will highlight new features in the Julia VS Code extension that shipped in the last year and give a preview of some new work. The new features from last year that we will highlight are: 1) progress UI, 2) documentation browser, 3) package tagging functionality, 4) Jupyter notebook support, and 5) a new cloud hosted symbol indexing architecture.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 1038, "code": "7JQFVF", "public_name": "David Anthoff", "biography": "David Anthoff is an environmental economist who studies climate change and environmental policy. He co-develops the integrated assessment model FUND that is used widely in academic research and in policy analysis. His research has appeared in Nature, Science, the American Economic Review and other academic journals. He contributed a background research paper to the Stern Review and has advised numerous organizations (including US EPA and the Canadian National Round Table on the Environment and the Economy) on the economics of climate change.\r\n\r\nHe is an assistant professor in the Energy and Resources Group at the University of California, Berkeley. Previously he was an assistant professor in the School of Natural Resources and the Environment of the University of Michigan, a postdoc at the University of California, Berkeley and a postdoc at the Economic and Social Research Institute in Ireland. He also was a visiting research fellow at the Smith School of Enterprise and the Environment, University of Oxford.\r\n\r\nHe holds a PhD (Dr. rer. pol.) in economics from the University of Hamburg (Germany) and the International Max Planck Research School on Earth System Modelling, a MSc in Environmental Change and Management from the University of Oxford (UK) and a M.Phil. in philosophy, logic and philosophy of science from Ludwig-Maximilians-Universit\u00e4t M\u00fcnchen (Munich, Germany).", "answers": []}, {"id": 10370, "code": "RUJKSU", "public_name": "Zac Nugent", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9636, "guid": "40fba6af-72b0-541e-a421-a6ba3d1f4e9d", "logo": "", "date": "2021-07-28T20:00:00+00:00", "start": "20:00", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9636-web-application-for-atmospheric-dispersion-modeling-", "url": "https://pretalx.com/juliacon2021/talk/KD7MR7/", "title": "Web application for atmospheric dispersion modeling.", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Atmospheric dispersion models will be coupled with event-based response models to assess the impact of CBRN (Chemical, Biological, Radiological and Nuclear) releases. A user-friendly web-based tool is being developed using Genie.jl and will run on the cloud infrastructure of ECMWF. The event-based model will be implemented using the SimJulia.jl framework. Ensemble weather forecasts will then be used to give probabilistic quantification of the impacted area and of the appropriate response plan.", "description": "For both military and civilian purposes, the assessment of the impact of a CBRN agent release is crucial. To assess the area of contamination of an agent, atmospheric dispersion models can be used. The accuracy of such models particularly depends on high quality weather data. A joint project of Royal Military Academy of Belgium, ECMWF and Royal Meteorological Institute of Belgium aims to develop a web application that implements simple dispersion models with real-time weather forecast data from ECMWF. The idea is to provide quick assessments of the impact area of a CRBN release as well as response models to plan appropriate actions. The application will run on the ECMWF Weather Cloud so the input weather data for the models can be accessed quickly.\r\nA prototype of the application has already been developed. For the time being, it implements the very simple ATP-45 dispersion model from NATO, which basically draws various hazard area shapes on the map according to the wind speed at the release location. Some screenshots of the app are provided in attachment.\r\nThe more complex FLEXPART atmospheric model is currently being added to the application and other state-of-the-art models are foreseen to be implemented as well. The response model will also be added using event driven simulation to account for other external data (population density, topography etc.). Ultimately, it will be possible to use ensemble forecast data to produce ensemble dispersion modelling and introduce probabilistic quantification in the response model.\r\nThe choice of Julia for the implementation has been made because we want to use the SimJulia.jl package, maintained by Ben Lauwens and who is one of the supervisors of the project. We are currently using the Genie.jl web framework as backend for web development (Angular is used as frontend) and some other packages for the handling of meteorological data (GRIB.jl, packages from JuliaGeo...).\r\nThe presentation will cover:\r\n- A general description of the project\r\n- A live demo of the application\r\n- An Explanation about the role of Julia in the application\r\n- The future of the project", "recording_license": "", "do_not_record": false, "persons": [{"id": 9466, "code": "JFWGMZ", "public_name": "Tristan Carion", "biography": "Tristan Carion is a mechanical engineer from UCL (Universit\u00e9 Catholique de Louvain-la-Neuve) in Belgium. After graduating in 2016, he spent a few years working for the industry. He also spent some time traveling the world. He went back to the academic world in 2020 where he joined the Royal Military Academy of Belgium (RMA) as a researcher. He is working for a joint project of RMA, ECMWF and RMI (Royal Meteorological Institute of Belgium), which consists of implementing atmospheric dispersion models and response models on the ECMWF Weather Cloud and use the ensemble forecasts from ECMWF to produce ensemble dispersion modeling.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9911, "guid": "86e35189-44bf-5ee9-8e57-f31e518ab1b0", "logo": "", "date": "2021-07-28T20:10:00+00:00", "start": "20:10", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9911-hypertextliteral-performant-string-interpolation-for-html-svg", "url": "https://pretalx.com/juliacon2021/talk/9XJTRW/", "title": "HypertextLiteral : performant string interpolation for HTML/SVG", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "HypertextLiteral is a Julia package for generating HTML, SVG, and other SGML tagged content. It works similar to Julia string interpolation, appropriately escaping interpolated values and providing handy data conversions dependent upon context. The implementation compiles templates to functions, with a custom IO proxy for escaping.\r\n\r\nFor those building dynamic hypertext, HTL is fast: 40x faster than object-based serializations; 8x faster than naive list comprehensions with string interpolation.", "description": "Generating HTML + SVG output is a common requirement for applications, especially when building scientific dashboards. The faster the better. Being able to use proven hypertext fragments as templates is especially important. The ability to encapsulate and re-use these templates as functions is critical.\r\n\r\n`HypertextLiteral` (HTL) is a Julia package that satisfies these criteria, permitting complex hypertext output to be constructed server-side.  This package is inspired by its Javascript's namesake written by Mike Bostock, the creator of D3. It uses string literals along with list comprehension syntax. The `@htl` macro translates an HTML template into a function closure. Here is an example.\r\n\r\n```\r\nbooks = [\r\n (name=\"Who Gets What & Why\", year=2012, authors=[\"Alvin Roth\"]),\r\n (name=\"Switch\", year=2010, authors=[\"Chip Heath\", \"Dan Heath\"]),\r\n (name=\"Governing The Commons\", year=1990, authors=[\"Elinor Ostrom\"])]\r\n\r\nrender_row(book) = @htl(\"\"\"\r\n  <tr><td>$(book.name) ($(book.year))<td>$(join(book.authors, \" & \"))\r\n\"\"\")\r\n\r\nrender_table(books) = @htl(\"\"\"\r\n  <table><caption><h3>Selected Books</h3></caption>\r\n  <thead><tr><th>Book<th>Authors<tbody>\r\n  $((render_row(b) for b in books))</tbody></table>\"\"\")\r\n\r\ndisplay(\"text/html\", render_table(books))\r\n#=>\r\n<table><caption><h3>Selected Books</h3></caption>\r\n<thead><tr><th>Book<th>Authors<tbody>\r\n  <tr><td>Who Gets What &amp; Why (2012)<td>Alvin Roth\r\n  <tr><td>Switch (2010)<td>Chip Heath &amp; Dan Heath\r\n  <tr><td>Governing The Commons (1990)<td>Elinor Ostrom\r\n</tbody></table>\r\n=#\r\n```\r\n\r\n*HTL is contextual.* At macro expansion time, the string template is passed through a light-weight HTML/SGML lexer. This is used to track the context of each interpolated Julia expression: is it part of element content, an attribute value, or is it inside an element tag where several attributes might be expanded? There is also a rawtext context used when content is inside a `script` tag.\r\n\r\n*HTL is extensible.* With multiple dispatch, custom data types can provide their own contextual serialization. This permits us to omit boolean attributes that are false. It also lets us expand vectors differently dependent upon context: within element content, they are simply appended; while within attribute values, they are space separated.\r\n\r\n*HTL is fast.*  A template rendering that takes 500\u03bcs with HTL, takes 4.5ms with naive string interpolation and list comprehension. Object based alternatives, such as Hyperscript, take even longer (21ms). Memory usage of HTL is likewise low. It uses 1/3rd less memory than naive string approach, and 1/6th the memory of an object based approach.\r\n\r\nThis efficiency was achieved by emulating Julia's documentation system.  Each component of the template is converted into an object which prints its content to a given `IO`. During macro processing, we build a Julia program that relies upon three primitive structures:\r\n\r\n- *Bypass* is used for content that should be emitted as-is.\r\n- *Render* is used for content that should be properly escaped.\r\n- *Reprint* is a function closure used for composing content.\r\n\r\nAs the template is converted, leaf nodes are converted into either *Render* or *Bypass*, depending if they are part of the template, or part of variables that are to be escaped.  *Reprint* is used to concatenate adjacent components that appear in the template or are generated by a list comprehension.\r\n\r\n*HTL is safe.*  Escaping code is layered using an `IO` proxy. Each of the 3 primitives has their own dispatch with regard to this proxy. This way, so long as the template translation properly distinguishes between `Bypass` and `Render` chunks,  escaping is always performed. Handled as an exception, `<script>` content is checked to ensure it does not contain the `\"</script>\"` literal but is otherwise unescaped.\r\n\r\nHTL can serialize attribute sets from pairs, dictionaries or named tuples. Unlike its Javascript namesake, we don't get clever with `camelCase` attribute names, which must be left as-is for SVG. Instead, we only convert `snake_case` names to their `kebab-case` equivalent. Moreover, if attribute sets are constants, we can pre-compute their serialization at macro expansion time.\r\n\r\nIt is notable how nicely the Julia implementation flowed together.  Julia's excellent macro facility lets us easily convert embedded functions and list comprehensions into relevant template logic. Julia's handling of tiny function closures was outstanding: not only does it let us write code that is easy to read, the approach turned out to be surprisingly fast.  Julia's `IO` interface lets us easily insert a proxy that was trivial to write, and, yet again, surprisingly efficient. Finally, multiple dispatch enables user-defined types to have their own serialization. Kudos Julia.\r\n\r\nThis approach could be used to make similar template libraries for other structured notations, such as JSON.", "recording_license": "", "do_not_record": false, "persons": [{"id": 923, "code": "NWXJWH", "public_name": "Clark C. Evans", "biography": "Collaborator on YAML, HTSQL, DataKnots, and other projects that advance the usability of software systems.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9912, "guid": "4c4df793-8a92-5588-a487-a69b5e7bd07d", "logo": "", "date": "2021-07-28T20:20:00+00:00", "start": "20:20", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9912-pluto-jl-notebooks-are-web-apis-", "url": "https://pretalx.com/juliacon2021/talk/39ZFBF/", "title": "Pluto.jl Notebooks are Web APIs!", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "What if Pluto notebooks could become web APIs instantly? With the power of reactivity, Pluto\u2019s new \u201cWhat you see is what you REST\u201d features do just that: every global variable becomes an HTTP endpoint, and you can provide other global variables as URL parameters. These features not only provide a new paradigm for writing web APIs with Julia, but also open the door to a promising new form of inter-notebook communication all within Pluto.", "description": "Pluto is fundamentally built upon **reactivity**, and hence knowledge of how notebook cells interact is known. Therefore cells can update in response to other cells changing, which happens in a Pluto notebook every time you run a cell. But what if these intelligent updates could also happen on-demand programmatically? \r\n\r\nIntroducing the new, experimental \u201cWhat you see is what you REST\u201d feature! (*WYSIWYR* for short.) Every global variable becomes an HTTP endpoint, and you can provide other global variables as parameters. Instead of experimenting with a model inside Pluto and then moving your code to an API script, your notebook _is_ an API, using reactivity to automatically create an execution model for each endpoint.\r\n\r\nWith this feature, interacting with Pluto notebooks from both outside and inside of other Pluto notebooks is revolutionarily simple. Everything from sharing models to writing custom web APIs with Julia is now possible, entirely from within Pluto, without having to transition from notebook code to \u201cproduction code\u201d.\r\n\r\nThis talk will demonstrate how to get started with WYSIWYR and use it in your own projects. By also explaining how the feature works, we hope to get experienced users interested in the feature. Along the way, we will discover how its expansion to existing notebook interactivity features opens the door to more seamless inter-notebook communication, and even to building web applications and APIs all from inside Pluto notebooks.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10495, "code": "LNLWJE", "public_name": "Connor Burns", "biography": "Soon-to-be college student who loves everything related to computers and virtual reality", "answers": []}], "links": [], "attachments": [], "answers": []}], "Blue": [{"id": 9576, "guid": "527b11b1-d564-5a58-82c1-6029ba957d47", "logo": "/media/juliacon2021/submissions/RERJWC/mittlemannBD-1_YjDhEO3.png", "date": "2021-07-28T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9576-bifurcationkit-jl-bifurcation-analysis-of-large-scale-systems", "url": "https://pretalx.com/juliacon2021/talk/RERJWC/", "title": "BifurcationKit.jl: bifurcation analysis of large scale systems", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "`BifurcationKit.jl` is a package for the numerical bifurcation analysis of large scale problems. It incorporates automatic bifurcation diagrams (of equilibria) routines and efficient tools to study periodic orbits. Most of these tools run on GPU which makes it possible to study challenging problems. Its design allows an easy to interface with many packages such as `ApproxFun.jl`, `DifferentialEquations.jl`, `FourierFlows.jl`,...", "description": "In this talk, I will give a panorama of `BifurcationKit.jl`, a Julia package to perform numerical bifurcation analysis of large dimensional equations (PDE, nonlocal equations, etc) using Matrix-Free / Sparse Matrix formulations of the problem. Notably, numerical bifurcation analysis can be done **entirely** on GPU.\r\n\r\n`BifurcationKit` incorporates continuation algorithms (PALC, deflated continuation, ...) which can be used to perform **fully automatic bifurcation diagram** computation of stationary states. I will showcase this with the 2d Bratu problem. I will also show an example of neural network that runs entirely on GPU.\r\n\r\nAdditionally, by leveraging on the above methods, the package can also seek for periodic orbits of Cauchy problems by casting them into an equation of high dimension. It is by now, one of the only softwares which provides parallel (Standard / Poincar\u00e9) shooting methods and finite differences based methods to compute periodic orbits in high dimensions. I will present an application highlighting the ability to fine tune `BifurcationKit` to get performance.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10173, "code": "PGWM93", "public_name": "Romain VELTZ", "biography": "I am a researcher at INRIA Sophia Antipolis (France) with interest in Mathematical neurosciences, modeling synaptic plasticity and analysis of PDEs. Please, have a look at my [website](http://romainveltz.pythonanywhere.com).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9720, "guid": "315189d6-ffef-53d7-aa76-3d9ea901d3be", "logo": "/media/juliacon2021/submissions/E8SVYT/Agents_5poOwRo.png", "date": "2021-07-28T13:00:00+00:00", "start": "13:00", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9720-agents-jl-and-the-next-chapter-in-agent-based-modelling", "url": "https://pretalx.com/juliacon2021/talk/E8SVYT/", "title": "Agents.jl and the next chapter in agent based modelling", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Complex dynamical systems are comprised of many interacting sub-systems that couple together through multiple, varying (and many times non-linear) processes: creating emergent system properties as a consequence. Agents.jl provides a framework to work with such dynamics, through a bottom-up approach known as Agent Based Modelling. This talk provides an overview of the package, and discusses how the greater Julia ecosystem may provide the next paradigm shift in this well established research area.", "description": "Agent based modelling (ABM) is a simulation method in which autonomous agents react to their environment, given a predefined set of rules. It is a bottom-up approach for modelling and simulating complex systems, such as behavior, decision making, crowd dynamics and other socio-economic problems; as well as, but not limited to, complex natural sciences such as chemical reactions or biological processes.\r\nSince ABMs are not described by simple and concise mathematical equations, code that generates them is typically complicated, large, and slow. In addition, since many of these problems are very domain specific, a lot of ABMs are hand written from scratch.\r\nAgents.jl provides a solution to this complication. Acknowledging that ABM frameworks have existed for decades, we show that Agents.jl is not only the most performant, but also the least complicated software (in terms of lines of code written to implement well-known ABM test cases), providing the same (and sometimes more) features as competitors.\r\nThis enables rapid prototyping of your domain specific ABM, with tried and tested (but generic) tooling.\r\nThe talk will provide an introduction to many of these helpful features, as well as showcase how well it integrates with the entire Julia ecosystem. Interactive applications with Makie.jl, differential equations from DifferentialEquations.jl, parameter optimization from BlackboxOptim.jl, and more.\r\nTo conclude, we'll outline some of the big next-steps on the roadmap that other ABM frameworks will struggle to match in the absence of the Julia ecosystem.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10353, "code": "VFYSEH", "public_name": "Tim DuBois", "biography": "Head of Scientific Computing at Cervest, working on Climate Intelligence solutions which quantify climate risk on a per-asset level, globally.\r\n\r\nPhD in Physics from RMIT University in Melbourne, Australia; focusing on defects in the Josephson junctions of superconducting phase-qubits. Followed up by a postdoctoral position at Chalmers University in Gothenburg, Sweden investigating high energy laser-plasma interactions and fusion energy. More recently a researcher at the Stockholm Resilience Centre, with research areas concerning Planetary Boundaries, global climate-economy models, social ecological systems and other Earth system sciences.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9924, "guid": "eaa0f637-8089-547a-8943-9b05319a5346", "logo": "", "date": "2021-07-28T13:30:00+00:00", "start": "13:30", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9924-an-individual-based-model-to-simulate-coffee-leaf-rust-epidemics", "url": "https://pretalx.com/juliacon2021/talk/LHQEPZ/", "title": "An individual-based model to simulate Coffee Leaf Rust epidemics", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Coffee Leaf Rust (CLR) is an aggressive plant disease of high economic importance that has caused major production collapses worldwide. To explore how the management and long-term planning of a coffee farm can influence CLR epidemic outcomes over several years, we took advantage of Julia\u2019s multiple dispatch and distributed computing to develop and test an individual-based model of a coffee farm.", "description": "CLR is an active research topic in plant pathology and epidemiology. However, the overall effect of the use of shade trees on the development of the CLR disease has not yet been established. The introduction of shade trees in a farm produces local changes that can have positive or negative effects on the development of CLR epidemics, depending on the life cycle stage of present infections.\r\nIn an effort to integrate relevant pathology and ecology knowledge, we developed a spatially explicit individual-based model that allows us to simulate CLR epidemics at a farm scale and its effect on coffee productivity over several years. Using high-throughput computing, we explore different agricultural management strategies, including various patterns of shade-providing tree placement within the farm, and test their efficacy at controlling a potential CLR outbreak. This talk will show how Agents.jl and Distributed.jl facilitated our research.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10505, "code": "UVC9SM", "public_name": "Manuela Vanegas Ferro", "biography": "Manuela Vanegas Ferro is a PhD candidate in Biological Design at Arizona State University. She earned a Bachelor of Science degree in Biology and Microbiology and a Master of Science degree in Computational Biology from Universidad de los Andes in Colombia. Manuela has experience in modeling complex biological systems at different scales. Currently, she is developing an individual-based model that integrates biological features of coffee rust disease and socio-economic aspects of coffee farmers' management practices to find optimal long-term farming strategies.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9748, "guid": "8373b395-e14d-52e2-b1d0-f4db09027227", "logo": "", "date": "2021-07-28T13:40:00+00:00", "start": "13:40", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9748-hpf-md-jl-hybrid-particle-field-molecular-dynamics-simulation", "url": "https://pretalx.com/juliacon2021/talk/ECKGDE/", "title": "hPF-MD.jl: Hybrid Particle-Field Molecular-Dynamics Simulation", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We introduce an efficient framework of molecular-dynamics simulations (hPF-MD), using a density-functional-based formalism to compute the non-bonded interactions between particles. hPF.jl is motivated to leverage the advantages of Julia, an interpreted language designed to achieve high-performance, statically compiled programming languages and the extensive computing community.", "description": "In this talk, we will give (1) a brief overview of the hPF-MD method, (2) example systems compared with results from existing hPF-MD packages and standard MD method, and (3) advantages and extensibility of their Julia implementations. \r\n\r\nReferences:\r\n\r\n1. Milano, G.; Kawakatsu, T. Hybrid Particle-Field Molecular Dynamics Simulations for Dense Polymer Systems. The Journal of Chemical Physics 2009, 130 (21), 214106. https://doi.org/10.1063/1.3142103.\r\n2. Wu, Z.; Milano, G.; M\u00fcller-Plathe, F. Combination of Hybrid Particle-Field Molecular Dynamics and Slip-Springs for the Efficient Simulation of Coarse-Grained Polymer Models: Static and Dynamic Properties of Polystyrene Melts. J. Chem. Theory Comput. 2020. https://doi.org/10.1021/acs.jctc.0c00954.\r\n3. Caputo, S.; Hristov, V.; Nicola, A. D.; Herbst, H.; Pizzirusso, A.; Donati, G.; Muna\u00f2, G.; Albunia, A. R.; Milano, G. Efficient Hybrid Particle-Field Coarse-Grained Model of Polymer Filler Interactions: Multiscale Hierarchical Structure of Carbon Black Particles in Contact with Polyethylene. J. Chem. Theory Comput. 2021, https://doi.org/10.1021/acs.jctc.0c01095.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10375, "code": "8BCABC", "public_name": "Zhenghao Wu", "biography": "PhD student @ TU-Darmstadt", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9806, "guid": "5481718e-71ad-59cd-bf69-2eacc864a974", "logo": "", "date": "2021-07-28T13:50:00+00:00", "start": "13:50", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9806-enhanced-sampling-in-molecular-dynamics-simulations-with-julia", "url": "https://pretalx.com/juliacon2021/talk/EFYMME/", "title": "Enhanced Sampling in Molecular Dynamics Simulations with Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "When performing molecular dynamics simulations of materials in chemistry, physics and\r\nbiology, there exists a large gap between the time scales that can be probed\r\ncomputationally to the ones observed in experiments. Two strategies to tackle this\r\nproblem are both to develop algorithms to explore the simulation space more efficiently, and to\r\nemploy hardware accelerators. I would like to share my experience and perspectives using\r\nJulia to make faster developments in both fronts.", "description": "When performing molecular dynamics (MD) simulations of materials in chemistry, physics and\r\nbiology, there exists a large gap between the time scales that can be probed\r\ncomputationally to the ones observed in experiments. One strategy to approach this issue\r\nhas been to develop algorithms to enhance sampling over the simulated system's\r\nconfiguration space, overcoming the otherwise hard to surmount energetic barriers limiting\r\nthe observation of certain possible states. These algorithms themselves are not enough to\r\nreally push toward larger timescales, one also needs to implement them in hardware\r\naccelerators such as GPUs. In fact, a good number of the most recently developed\r\nalgorithms tend to become a bottleneck for molecular simulations accelerated on GPUs, as\r\nthey are commonly implemented in CPUs even when some of them heavily rely on machine\r\nlearning strategies.\r\n\r\nWithin our research group, we are trying to provide a library that can be hooked to\r\ndifferent molecular dynamics simulations packages, allowing the user to perform enhanced\r\nsampling simulations through a uniform interface without sacrificing the efficiency of the\r\nunderlying MD code. The library is currently located here:\r\nhttps://github.com/SSAGESLabs/PySAGES, and although it is a Python library it has\r\ncontinuously been prototyped in Julia. For example, here\r\nhttps://github.com/pabloferz/ReactionCoordinates.jl and here\r\nhttps://github.com/pabloferz/DLPack.jl are some of the pieces that we have built for such\r\npurpose. The prototypes, being written in Julia, are of course faster than the current\r\nPython implementation.\r\n\r\nI would like to share my experience and perspective using Julia to build these tools.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10406, "code": "B3DVHD", "public_name": "Pablo Zubieta", "biography": "I'm currently a postdoctoral researcher at the University of Chicago working on a class of strategies used to accelerate learning the properties of systems simulated with molecular dynamics.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9863, "guid": "aabbc82b-791c-5b56-84e8-c600ab1b8237", "logo": "", "date": "2021-07-28T17:00:00+00:00", "start": "17:00", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9863-vectorized-query-evaluation-in-julia", "url": "https://pretalx.com/juliacon2021/talk/CAMR3P/", "title": "Vectorized Query Evaluation in Julia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Modern databases can choose between two approaches to evaluating queries with high performance: Query Compilation compiles each query to optimized machine code, while Vectorization interprets queries using BLAS-style primitives.\r\n\r\nQuery compilation offers more optimization potential for LLVM, while vectorization doesn\u2019t require runtime compilation.\r\n\r\nWe explain how these techniques work and how we combine them, showcasing how Julia lets us have the best of both.", "description": "In modern (SQL) database query engines, there are two major approaches on how to evaluate user-provided queries in a highly performant manner (see e.g. [1]):\r\n\r\nQuery Compilation: Each pipeline of a query plan gets compiled into a single function that effectively fuses operators into a single (nested) for-loop. This function is then compiled to highly-optimized machine code. Operators process data tuple-at-a-time.\r\n\r\nVectorization: The query plan is interpreted, and each operator in the plan is mapped to a pre-compiled function. To offset the arising interpretation cost, each operator evaluates batches (\"vectors\") of, say, 1000 values in bulk on each step.\r\n\r\nQuery compilation offers more optimization potential for LLVM and is often effective at keeping values in registers, while vectorization enables shorter compilation times \u2014 for better support of interactive queries. As part of the production-grade RelationalAI Knowledge Graph Management System, we implemented both approaches in Julia.\r\n\r\nIn this presentation, we explain in greater detail how both of these fundamentally different techniques work, why we are implementing them, and how we aim to combine them. We showcase where Julia enabled us to implement highly performant code with ease, but also reveal where we had to spend non-trivial amounts of engineering effort to arrive at the desired performance.\r\n\r\n[1] https://www.vldb.org/pvldb/vol11/p2209-kersten.pdf", "recording_license": "", "do_not_record": false, "persons": [{"id": 10453, "code": "KUKVJF", "public_name": "Richard Gankema", "biography": "Richard Gankema is a Computer Scientist at RelationalAI, working on various systems-related topics such as data structures, memory management and query execution. Before joining RelationalAI he worked as a PhD candidate at CWI\u2019s Database Architectures group in Amsterdam, which sparked his interest in vectorization and other techniques for optimizing the performance of data-processing.", "answers": []}, {"id": 10519, "code": "JKQ7ND", "public_name": "Alex Hall", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9885, "guid": "d9ce6aa0-c31a-527b-b885-57d258bba2bd", "logo": "", "date": "2021-07-28T17:30:00+00:00", "start": "17:30", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9885-retest-jl-more-productive-testing", "url": "https://pretalx.com/juliacon2021/talk/KUVB9C/", "title": "ReTest.jl - more productive testing", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "[ReTest.jl](https://github.com/JuliaTesting/ReTest.jl) is a testing framework which is backward-compatible with the `Test` standard library, and offers few usability improvements, like nicer printing of results, filtering testsets according to their descriptions or running them in parallel. This talk is a tutorial motivating and demonstrating the main features of the package.", "description": "The main idea behind [ReTest.jl](https://github.com/JuliaTesting/ReTest.jl) is that its `@testset` macro does not run tests immedidately, but instead stores them for later execution, via a call to the `retest` function. This is what enables a lot of the provided features, two of which were the initial drive for the creation of the package:\r\n- filtering which testsets are run by matching their descriptions against a given regular expression;\r\n- the ability to write tests \"inline\" in source files, right next to the code implementing the tested behaviors.\r\n\r\nThe fact that `Test` and `ReTest` have the same macro name, `@testset`, makes it usually trivial to switch an existing test suite over to `ReTest`. So much so that there is an option to actually use `ReTest` on a test suite without changing a single line of code!\r\n\r\nAnd what if you could use `Revise` on your test files...?", "recording_license": "", "do_not_record": false, "persons": [{"id": 10474, "code": "ZY8YGR", "public_name": "Rafael Fourquet", "biography": "A random Julia enthusiast, occasional contributor.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11794, "guid": "14c078af-7fe8-5597-81ea-a02f4946e3c7", "logo": "", "date": "2021-07-28T17:40:00+00:00", "start": "17:40", "duration": "00:05", "room": "Blue", "slug": "juliacon2021-11794-sponsor-talk-invenia-", "url": "https://pretalx.com/juliacon2021/talk/7Q8P9D/", "title": "Sponsor Talk (Invenia)", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Sponsor talk.", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 11793, "guid": "ec1d43fb-0da3-54d2-94c8-621fa433181a", "logo": "", "date": "2021-07-28T17:45:00+00:00", "start": "17:45", "duration": "00:05", "room": "Blue", "slug": "juliacon2021-11793-sponsor-talk-kaust-", "url": "https://pretalx.com/juliacon2021/talk/EJP7SS/", "title": "Sponsor talk (KAUST)", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Sponsor talk.", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 11849, "guid": "4b35e90d-abd9-5e12-af20-aa1a9fac5f9e", "logo": "", "date": "2021-07-28T17:50:00+00:00", "start": "17:50", "duration": "00:05", "room": "Blue", "slug": "juliacon2021-11849-sponsor-talk-pumas-ai-", "url": "https://pretalx.com/juliacon2021/talk/NKSCDS/", "title": "Sponsor talk (Pumas AI)", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Sponsor talk.", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 11850, "guid": "e9b0e5b5-354b-5aab-91b1-56318f818811", "logo": "", "date": "2021-07-28T17:55:00+00:00", "start": "17:55", "duration": "00:05", "room": "Blue", "slug": "juliacon2021-11850-sponsor-talk-quera-", "url": "https://pretalx.com/juliacon2021/talk/RSPXSS/", "title": "Sponsor talk (Quera)", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Sponsor talk.", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 9375, "guid": "8b842f52-aee9-5a36-8620-760f7a81bea3", "logo": "", "date": "2021-07-28T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9375-changing-physics-education-with-julia", "url": "https://pretalx.com/juliacon2021/talk/KNWNHJ/", "title": "Changing Physics education with Julia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In many disciplines of physics, code is not explicitly discussed as part of the learning subject. Here I will focus on nonlinear dynamics, a discipline that suffers greatly from the disconnect between the mathematics and the coding. I will present our new approach in teaching this subject, based on JuliaDynamics and a new Springer textbook for nonlinear dynamics whose pages are interlaced with Julia code. I wish to demonstrate how Julia can fundamentally change the way physics is being taught.", "description": "In many disciplines of physics, code is not explicitly discussed as part of the learning subject. Here I will focus on nonlinear dynamics, a discipline that suffers greatly from the disconnect between the mathematics and the coding. In fact, this disconnect is largely what started the JuliaDynamics software organization, as a means to eliminate this disconnect.\r\n\r\nIn this talk I will present the numerous ways that we have employed in order to fundamentally change physics education for the better. And this change necessarily requires including coding as part of the learning subject. I will demonstrate how we created easy to read code using Julia, how to incorporate it into exercises, how to make interactive applications that enhance learning, and how to include scientific analysis using code as part of the learning subject. Our new approach to teaching nonlinear dynamics, which I will present here, is also published as a new textbook on the topic by Springer. The book explicitly includes real, runnable Julia code. A GitHub repository related with the book can be found here: https://github.com/JuliaDynamics/NonlinearDynamicsTextbook\r\n\r\nI believe that this new approach should be used by more and more branches of physics. When this is done, then finally coding will be viewed as an integral part of science, instead of some \"background business behind the curtains\", which is its current perception. Ultimately, this will lead not only to better science, but to actually reproducible science.", "recording_license": "", "do_not_record": false, "persons": [{"id": 3002, "code": "GB8WTV", "public_name": "George Datseris", "biography": "Postdoc in climate physics in the MPI for Meteorology (Hamburg) and professional drummer. Lead dev for JuliaDynamics and JuliaMusic.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9819, "guid": "2ecc060d-457c-554a-88fb-699cc54c6586", "logo": "", "date": "2021-07-28T19:40:00+00:00", "start": "19:40", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9819-open-and-interactive-computational-thinking-with-julia-and-pluto", "url": "https://pretalx.com/juliacon2021/talk/RXF8UK/", "title": "Open and interactive Computational Thinking with Julia and Pluto", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We will discuss goals, ideas, technical tools and outcomes for the open, online, interactive course on \"Computational Thinking with Julia\" that we have been teaching for the last two semesters. The Pluto notebook has allowed us to develop a new approach to write both an online interactive textbook and interactive problem sets with built-in solution checks.", "description": "During the Fall 2020 and Spring 2021 semesters we have been teaching an online, open, interactive course on Computational Thinking using Julia and the Pluto notebook. \r\n\r\nPreviously we had used the Jupyter notebook, but we decided to take the plunge with the then-brand-new Pluto notebook in the summer of 2020, when it was still in its early days. It has turned out to be an excellent -- although at times frustrating! -- decision.\r\n\r\nPluto has allowed us to develop a completely new approach to writing both an interactive online textbook, as well as interactive problem sets with beautiful built-in solution checks that make working on problems both more fun and more rewarding. \r\n\r\nIndeed, the capabilities of the Pluto notebook itself have developed together with the course, as we have collaborated on the required tools and ideas. Many recent features in Pluto have been added with this style of teaching in mind, and we hope to inspire more teachers to write interactive material.\r\n\r\nHalf-way through the second semester, each video lecture consistently receives over 2,000 views, and the course website receives 6,000 hits per month. The interactive and self-checking nature of Pluto homeworks is especially useful in an open course, where students have to work on the material independently. \r\n\r\nWe will discuss ideas and goals for teaching Julia, computational thinking, concepts from computer and applied mathematics mixed together, and how the technical features of Pluto enable and enhance one another.\r\n\r\nCourse homepage with online interactive textbook: https://computationalthinking.mit.edu/Spring21/", "recording_license": "", "do_not_record": false, "persons": [{"id": 1022, "code": "TJJRTG", "public_name": "David P. Sanders", "biography": "Professor of Computational Science at the Universidad Nacional Aut\u00f3noma de M\u00e9xico and visiting professor at MIT.\r\n\r\nInterested in computational science, interval arithmetic, and numeric-symbolic computing.\r\n\r\nAuthor of the JuliaIntervals suite of packages for interval arithmetic, and various tutorials on Julia.", "answers": []}, {"id": 10435, "code": "UCVDU3", "public_name": "Alan Edelman", "biography": null, "answers": []}, {"id": 4400, "code": "ECC83Q", "public_name": "Fons van der Plas", "biography": "Computers are too difficult!\r\n\r\n[https://github.com/fonsp](https://github.com/fonsp)", "answers": []}], "links": [], "attachments": [], "answers": []}], "Purple": [{"id": 9497, "guid": "c3f64b1f-6fbb-5412-a6b1-54ca0bd62acd", "logo": "", "date": "2021-07-28T12:30:00+00:00", "start": "12:30", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9497-clearing-the-pipeline-jungle-with-featuretransforms-jl", "url": "https://pretalx.com/juliacon2021/talk/GFHKV7/", "title": "Clearing the Pipeline Jungle with FeatureTransforms.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "The prevalence of glue code in feature engineering pipelines poses many problems in conducting high-quality, scalable research. In worst-case scenarios, the technical debt racked up by overgrown \u201cpipeline jungles\u201d can preclude further development and grind promising projects to a halt [1]. This talk will show how the FeatureTransforms.jl package can help make feature engineering a more sustainable practice for users without sacrificing the flexibility they desire.", "description": "Feature engineering is an essential component in all machine learning and data science workflows. It is often an exploratory activity in which the pipeline for a particular set of features tends to be developed iteratively as new data or insights are incorporated. \r\n\r\nAs the feature complexity grows over time it is very common for code to devolve into unwieldy \u201cpipeline jungles\u201d [1], which pose multiple problems to developers. They are often brittle, with highly-coupled operations that make it increasingly difficult to make isolated changes. The over-entanglement of such pipelines also means they are difficult to unit test and debug effectively, making them particularly error-prone. Since adding to this complexity is often easier than investing in refactoring it, pipeline jungles tend to be more susceptible to incurring technical debt over time, which can impact the project\u2019s long-term success.\r\n\r\nIn this talk, we will showcase some of the key features of the [FeatureTransforms.jl](https://github.com/invenia/FeatureTransforms.jl) package, such as the composability, reusability, and performance of common transform operations, that were designed to help mitigate the problems in our own pipeline jungles.. \r\n\r\n[FeatureTransforms.jl](https://github.com/invenia/FeatureTransforms.jl) is conceptually different from other widely-known packages that provide similar utilities for manipulating data, such as [DataFramesMeta.jl](https://github.com/JuliaData/DataFramesMeta.jl), [DataKnots.jl](https://github.com/rbt-lang/DataKnots.jl), and [Query.jl](https://github.com/queryverse/Query.jl). These packages provide methods for composing relational operations to filter, join, or combine structured data. However, a query-based syntax or an API that only supports one type are not the most suitable for composing the kinds of mathematical transformations, such as one-hot-encoding, that underpin most (non-trivial) feature engineering pipelines, which this package aims to provide.\r\n\r\nThe composability of transforms reflects the practice of piping the output of one operation to the input of another, as well as combining the pipelines of multiple features. Reusability is achieved by having native support for the Tables and AbstractArray interfaces, which includes tables such as [DataFrames](https://github.com/JuliaData/DataFrames.jl/), [TypedTables](https://github.com/JuliaData/TypedTables.jl), [LibPQ.Result](https://github.com/invenia/LibPQ.jl), etc, and arrays such as [AxisArrays](https://github.com/JuliaArrays/AxisArrays.jl), [KeyedArrays](https://github.com/mcabbott/AxisKeys.jl), and [NamedDimsArrays](https://github.com/invenia/NamedDims.jl). This flexible design allows for performant code that should satisfy the needs of most users while not being restricted to (or by) any one data type.\r\n\r\n[1] [Sculley, David, et al. \"Hidden technical debt in machine learning systems.\" Advances in neural information processing systems 28 (2015): 2503-2511](https://proceedings.neurips.cc/paper/2015/hash/86df7dcfd896fcaf2674f757a2463eba-Abstract.html).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10070, "code": "UBLH3G", "public_name": "Glenn Moynihan", "biography": "I'm a Research Software Engineer at InveniaLabs, UK.\r\nInterested in the application of Julia for scalable, sustainable, research.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9792, "guid": "76f63254-3aa0-5d51-b228-cd511b5baa36", "logo": "", "date": "2021-07-28T12:40:00+00:00", "start": "12:40", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9792-tiledviews-jl", "url": "https://pretalx.com/juliacon2021/talk/8VL9R7/", "title": "TiledViews.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "This class implements an 2N-dimensional tiled (copy-free) view of an `AbstractArray` of N dimensions. The tiling is specified by a `tile_size` and a `tile_overlap` leading to N inner coordinates (within each tile) and outer coordinates (tile index). The view is easily combined with windows and has `getindex`/`setindex `access. Applications range from deconvolution of large datasets to propagation of optical field amplitudes. Similarities and differences to `TiledIteration.jl` will be presented.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10334, "code": "CNV3SE", "public_name": "Rainer Heintzmann", "biography": "My research focuses on developing tools to image cellular function at high resolution. We develop techniques to measure multidimensional information in small biological objects such as cells, cellular organelles or other small structures of interest. Computer-based reconstruction methods, especially inverse-modeling based in automatic differentiation are of primary interest.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9928, "guid": "35bd2f79-aa60-5254-a829-a040815f0eb1", "logo": "", "date": "2021-07-28T12:50:00+00:00", "start": "12:50", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9928-structural-lambdas-for-generic-code-and-delayed-evaluation", "url": "https://pretalx.com/juliacon2021/talk/CBDFPN/", "title": "Structural lambdas for generic code and delayed evaluation", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We describe an [experimental package](https://github.com/goretkin/FixArgs.jl) that reifies lambda functions as a `Lambda(args, body)` and function calls as `Call(function, args)`, giving a new way to \"quote\" expressions. It generalizes types like `Base.Fix2`, `Base.Generators`, `Iterators.Filter` and possibly many others. It might be well-suited for the recurring pattern of deferred computation in Julia code.", "description": "Pervasive and performant multiple dispatch in Julia has led to the development of functions that convey generic meaning. Deciding on a name and settling on the meaning of these generic functions is challenging work, but it is essential for generic programming.\r\n\r\nFunctions can be used to direct dispatch. e.g.\r\n\r\n```julia\r\nreduce(vcat, [[1,2,3], [4,5], [6,7,8,9]])\r\n```\r\n\r\nThere is a fallback method of `reduce` that works for any binary operation, not just `vcat`. However, there is also a method specific to `vcat` that preallocates the result. Both the fallback and the specialization produce the same result, but the specialization is likely to perform better since it is inexpensive to calculate the size of the result.\r\n\r\nConsider e.g. `Base.filter` and `Base.Iterators.filter`. The second simply constructs a `Base.Iterators.Filter`, which is in essence nothing more than a lazy representation of `Base.filter(f, itr)`. We developed an experimental package [`FixArgs.jl`](https://github.com/goretkin/FixArgs.jl) to represent this:\r\n\r\n```julia\r\njulia> @xquote filter(iseven, $(1:5))\r\nCall(Some(filter), FrankenTuple((Some(iseven), Some(1:5)), NamedTuple()))\r\n```\r\n\r\nSuppose we want to define `eltype`, the same way it is defined for `Base.Iterators.Filter`. We can define an `eltype` method for `Call` for the specific parameter `filter`. `FixArgs.jl` defines a macro to help (but the ergonomics should still be improved):\r\n\r\n```julia\r\njulia> Base.eltype(filt::(@xquoteT filter(::F, ::I))) where {F, I} = eltype(something(filt.args[2]))\r\n\r\njulia> eltype(@xquote filter(iseven, $(1:5)))\r\nInt64\r\n```\r\n\r\n`FixArgs.jl` began as a generalization of `Base.Fix1` and `Base.Fix2`, but identifies a common pattern that could systematically replace many existing types and methods. e.g. Broadcasting relies on types to represent lazy function calls, and `materialize` to perform the computation (with e.g. dot fusion). `Base.Generator` and `collect` are analogous.\r\n\r\nInstead of generating a new name for a type, and attaching meaning to it, one can meaningfully compose a name from existing meaningful names. One straightforward example is to define `Rational{T}` as\r\n\r\n```julia\r\njulia> (@xquoteT ::T / ::T) where T\r\nFixArgs.Call{Some{typeof(/)}, FrankenTuples.FrankenTuple{Tuple{Some{T}, Some{T}}, (), Tuple{}}} where T\r\n```\r\n\r\nNote that `Rational{Int}` and (@xquoteT ::Int / ::Int) have identical memory layouts!\r\n(Also, occasionally, there is a need for a `Rational`-like type that does not constrain the numerator and denominator to have the same type. The type above would fit the bill).\r\n\r\nIn this case, `Rational` is in Base, but more generally packages have to depend on a common package (usually called `*Base.jl`) that defines types. If it is possible to define new types terms of existing types, then in a sense the types are structural and not nominal. This may reduces the need for these common packages and enable better package interoperability.\r\n\r\nAs another example, the type `Base.Generator(f, itr)` could be identical to `@xquote map(f, itr)` (though not exactly since the meaning of `map` and `collect` are currently conflated (https://github.com/JuliaLang/julia/issues/39628)\r\n\r\nThere are many other examples in the ecosystem, such as in `LazySets.jl`, `LazyArrays.jl`, `MappedArrays.jl`, `StructArrays.jl`, ... where types are defined to essentially represent lazy function calls ad-hoc. They each have a version of \"materialize\". Note that in most cases, these cannot be replaced directly since `Call` cannot e.g. subtype `AbstractArray` and `AbstractSet`.\r\n\r\n`Base.Fix1`, etc. is useful, even though one can already define a lambda function with the same behavior, because it is possible to dispatch on the structure of this lambda function as opposed to having an opaque name:\r\n\r\n```julia\r\njulia> x -> x > 2\r\n#3 (generic function with 1 method)\r\n\r\njulia> >(2)\r\n(::Base.Fix2{typeof(>),Int64}) (generic function with 1 method)\r\n```\r\n\r\n`FixArgs.jl` (which really should be called e.g. `StructuralLambdas.jl`) allows one to easily define these structural lambdas:\r\n\r\n```julia\r\njulia> @xquote x -> x > 2\r\nFix2(>,2)\r\n\r\njulia> typeof(@xquote x -> x > 2)\r\nFix2{typeof(>), Int64} (alias for FixArgs.Lambda{FixArgs.Arity{1, Nothing}, FixArgs.Call{Some{typeof(>)}, FrankenTuples.FrankenTuple{Tuple{FixArgs.ArgPos{1}, Some{Int64}}, (), Tuple{}}}})\r\n```\r\n\r\n(Better aesthetics would be necessary for usability.)\r\n\r\nSee https://goretkin.github.io/FixArgs.jl/dev/ for more motivation and details, including examples for replacing `Complex` and generalizing `FixedPointNumbers.jl`.\r\n\r\nPlease note that this talk is about an idea, not `FixArgs.jl` itself. It may turn out that the idea is not practical; e.g. it might pose immense challenges for compilation, or it might be too confusing to marry the meaning of functions and `Call`, or package interoperability will fail due to subtle differences. I hope the idea holds promise. A great way to find out is at JuliaCon 2021.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1215, "code": "N9TKUU", "public_name": "Gustavo Nunes Goretkin", "biography": "I am a late-stage Ph.D. student in Robotics at MIT CSAIL, and I first used \"Julia\" in 2012!", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9584, "guid": "8264c8e7-77a7-5111-88e0-0e7ff88eae84", "logo": "", "date": "2021-07-28T13:30:00+00:00", "start": "13:30", "duration": "00:30", "room": "Purple", "slug": "juliacon2021-9584-dictionaries-jl-for-improved-productivity-and-performance", "url": "https://pretalx.com/juliacon2021/talk/WRNAEN/", "title": "Dictionaries.jl - for improved productivity and performance", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "[*Dictionaries.jl*](https://github.com/andyferris/Dictionaries.jl) presents an alternative interface for dictionaries in Julia, for improved productivity and performance. During this talk we'll learn how to use Julia's data manipulation tools (such as indexing, broadcasting, `map`, `filter`, `reduce`, etc) with dictionaries and explore some implementation decisions made in this package. We will end with applications, including recent work on tabular data with primary and/or grouping keys.", "description": "This talk will be divided into roughly three sections.\r\n\r\n### Motivation\r\n\r\nJulia is an awesome language for manipulating data, with excellent built-in functionality that is easy to extend by packages and users. Arrays, sets and dictionaries form the basis of core data structures necessary for a wide range of workloads. Of the three, Julia's `AbstractArray` interface is most extensive \u2014 supporting a wide range of data structures *and* a rich set of operations, designed around the same core set of functionality (primarily, indexing and iteration).\r\n\r\nOn the other hand, `AbstractSet` and `AbstractDict` do not support such a wide range of operations (like broadcasting, `map`, or `reduce`) and the interface for a user to create a new, fully-functional `AbstractDict` is not as clear cut or simple as it is for an array. *Dictionaries.jl* is an attempt to remedy this situation, by applying the learnings of the `AbstractArray` interface to create a new `AbstractDictionary` interface. By using *Dictionaries.jl*, users can experience improved programmer productivity as well as signficantly faster execution for many operations (especially with analytics-style workloads).\r\n\r\n### Implementation\r\n\r\nA *Dictionaries.jl* `AbstractDictionary` differs from Julia's `AbstractDict` in three main ways:\r\n\r\n 1. Dictionaries iterate values, like an array, instead of key-value pairs.\r\n 2. The indices (or `keys`) of dictionary are a special kind of dictionary, much like the indices (or `keys`) of an array is a special kind of array.\r\n 3. Dictionaries (and their indices) by default iterate in a well-defined order based on insertion, rather than quasi-randomly based on how the hashmap was constructed.\r\n\r\nSince the indices of a dictionary are distinct, they naturally form a set (in the mathematical sense). In *Dictionaries.jl* this type is represented by `AbstractIndices <: AbstractDictionary` (unlike for `Dict`, there was no obvious alternative spelling of `Set` available). Every `AbstractIndices` has the special property that it's values are the same as it's keys, so if `i \u2208 indices` then `indices[i]` is just `i`.\r\n\r\nFrom these alone, natural definitions of `broadcast`, `map`, `filter` and `reduce` follow, for both indices (i.e. \"sets\") or dictionaries. For example, the `map` operation preserves the indices and maps the values to new values. You can even `map` a set of indices/keys into a new dictionary.\r\n\r\nThis property leads to *Dictionaries.jl*'s primary efficiency gain. The indices of dictionaries (i.e. the expensive part) can be shared between different dictionaries. For example, the provided hashmap `Dictionary` can share its hash `Indices` with other dictionaries. The values are stored in a (mostly) dense array, so operating on all the values with an operation like `map`, `filter` and `reduce` is as fast as it is for a similarly sized array. One can use `map` or `broadcast` with multiple similar dictionaries (i.e. those that share compatible \"tokens\"), co-iterating values together at speed and with zero hash lookups.\r\n\r\n### Applications\r\n\r\nWe will turn our attention to some example applications of this interface, first highlighting the convenience and speed of `Dictionary` for some common analytics tasks.\r\n\r\nWe will then see how *Dictionaries.jl* is used in conjunction with other packages, for example how *SplitApplyCombine.jl*'s `group` operation now supports a simple and easy split-apply-combine workflow.\r\n\r\nFinally, we will explore recent work in *TypedTables.jl* which uses *Dictionaries.jl* to provide a table with a primary key (enabling easy lookup of rows based on data rather than an array index). The idea is similarly extended to grouped/partitioned data tables and their grouping keys.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1230, "code": "XWRVMT", "public_name": "Andy Ferris", "biography": "I first used Julia to perform research during postdocs in quantum simulation, before using it in industry with a team working on various geospatial applications. Nowadays we use Julia at [ELARA AI](https://www.elaraai.com) to simulate, analyze and optimize real-world businesses. I have contributed packages including *StaticArrays*, *CoordinateTransformations*, *Rotations*, *TypedTables*, *SplitApplyCombine*, *AcceleratedArrays* and *Dictionaries*.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9675, "guid": "38bbee6a-4a8c-57c7-904c-8928352941a0", "logo": "/media/juliacon2021/submissions/N9JPV7/JuliaImagingPackages_v3_WJ8MTEK.png", "date": "2021-07-28T16:30:00+00:00", "start": "16:30", "duration": "00:30", "room": "Purple", "slug": "juliacon2021-9675-tomographic-image-reconstruction-with-julia", "url": "https://pretalx.com/juliacon2021/talk/N9JPV7/", "title": "Tomographic Image Reconstruction with Julia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In this talk we show how Julia can be used to develop tomographic image reconstruction algorithms. These involve the solution of large scale ill-posed inverse problems where usually the imaging operator does not fit into the main memory and in-turn matrix-free methods need to be applied. The talk captures how Julia has been used to form a package ecosystem for two different tomographic imaging methods and outlines the advantageous compared to mature C/C++ libraries in the field.", "description": "Tomographic imaging plays a major role in clinical routine and has revolutionized the diagnosis and treatment of serious diseases such as stroke, heart attack and cancer. Tomographic techniques such as magnetic resonance imaging (MRI), computed tomography or the new imaging modality magnetic particle imaging (MPI) make it possible to look inside the human body without surgical intervention, simply by measuring indirect signals which allow reconstruction of an image of the inside of the body.  Medical imaging is an interdisciplinary field involving physicians, physicists, engineers, mathematicians and computer scientists to develop a tomographic imaging system. While the technical development of modalities such as MRI are approaching limits with respect to the optimization of signal quality, the potential on the side of image reconstruction algorithms has not yet been fully exploited. As a consequence, numerous innovations from the fields of mathematics, signal processing and computer science have found their way into tomography research within the last decade.\r\n\r\nTraditionally, algorithm development within the imaging community has been divided into two parts. Researchers who primarily work on mathematical methods often implement these using a high-level language such as Matlab and occasionally Python. As a result, the application of these algorithms is often limited to selected datasets, which validate the feasibility and the accuracy of the method. On the other hand, application-oriented researchers often use highly optimized program libraries, implemented in a low-level language such as C/C++, to apply algorithmic innovations to larger datasets that are acquired in clinical trials. Some of the larger C/C++ software packages such as the MRI reconstruction framework BART and Gadgetron use such a low-level approach and additionally provide Python bindings to make the framework accessible also to researchers who prefer using a high-level programming language. In practice, this hybrid approach, where low-level and high-level code is mixed leads to the well-known two-language problem since the presence of bindings still does not allow for an easy transition of new algorithmic ideas into the core of these packages.\r\n\r\nThis presentation of the current state of software tools in the imaging community shows that there is great potential for a modern programming language like Julia to close the gap between theoretically orientated and applied researchers.  The speaker of this talk will outline the Julia package infrastructure for two different imaging modalities that have been devel-oped since 2015. The packages cover a wide range of functionality, namely:\r\n\r\n- File handling for raw data files acquired with tomographic imaging systems. \r\n- Preprocessing of raw data to make it suitable for image reconstruction.\r\n- Routines for setting up dense and matrix-free image operators\r\n- Iterative solvers for solving the reconstruction problem, including a flexible system for applying regularization to incor-porate prior knowledge about the solution\r\n- Visualization methods for slicing, coloring, and merging tomographic images\r\n\r\nInstead of putting all of this functionality into a single software package, the opposite approach is taken with the philosophy of reusing as much functionality from existing Julia packages as possible (see attached figure). This has the advantage of keeping imaging-specific functionality small and allows to share common methods across different imaging modalities. Julia's powerful package manager allows for small packages, making this form of fine-granular modularization feasible. An interesting opportunity that arises by solving the two-language problem is that the software becomes much more accessible since a user can not only use the provided interface but also access internals easily. In the imaging packages MRIReco.jl and MPIReco.jl we have exploited this advantage by providing the user direct access to different abstraction layers of the reconstruction pipeline. In this way a user can either perform standard reconstruction using ready-to-use high-level building blocks or the user can develop a custom reconstruction pipeline based on the available building blocks. While this flexibility can also be achieved in two-language solutions, it arises very naturally in Julia, without much additional effort on the developer side.\r\n\r\nSince tomographic image reconstruction is a computationally intensive task one needs efficient algorithms to determine the image in short enough time. The talk outlines how the package MRIReco.jl has been designed to match the efficiency of a highly tuned C/C++ libraries even in a multi-threading scenario, based on the parallel task runtime support available since Julia 1.3.\r\n\r\nCore packages being presented: \r\n- https://github.com/MagneticResonanceImaging/MRIReco.jl\r\n- https://github.com/MagneticParticleImaging/MPIReco.jl", "recording_license": "", "do_not_record": false, "persons": [{"id": 10315, "code": "PM3B8U", "public_name": "Tobias Knopp", "biography": "Tobias Knopp received his Diplom degree in computer science in 2007 and his PhD in 2010, both from the University of L\u00fcbeck with highest distinction. For his PhD on the tomographic imaging method Magnetic Particle Imaging (MPI) he was awarded with the Klee award from the DGBMT (VDE) in 2011. From 2010 until 2011 he led the MAPIT project at the University of L\u00fcbeck and published the first scientific book on MPI. In 2011 he joined Bruker Biospin to work on the first commercially available MPI system. From 2012 until 2014 he worked at Thorlabs in the field of Optical Coherence Tomography (OCT) as a software developer. Since 2014, Tobias Knopp is a professor for Biomedical Imaging at the University Medical Center Hamburg-Eppendorf and the Hamburg University of Technology in Hamburg, Germany. Beside his work as a researcher in the field of tomographic imaging method Tobias Knopp is an open-source developer and part of the Julia community since 2012.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9445, "guid": "9b8de1fe-24d1-53db-8a0a-1a7b65b34319", "logo": "", "date": "2021-07-28T17:10:00+00:00", "start": "17:10", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9445-deconvoptim-jl-microscopy-image-deconvolution", "url": "https://pretalx.com/juliacon2021/talk/8UR3U3/", "title": "DeconvOptim.jl: Microscopy Image Deconvolution", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "A microscope capturing incoherent light emitted by a specimen always introduces some blur to the image which can be described as a convolution of the object with the point spread function (PSF) of the optical system. \r\nDeconvolution is an algorithm which tries to reverse this blurring process providing a sharper image.\r\nWe offer a flexible deconvolution toolbox called DeconvOptim.jl to solve deconvolution for multidimensional signals.", "description": "In our package DeconvOptim.jl we address deconvolution through an optimization problem.\r\nHowever, deconvolution is, due to the band limit of the PSF, an ill-conditioned inverse problem which cannot be solved directly.\r\nThe forward model is convolution of the PSF with our estimation. The PSF is the mathematical description of the optical system which introduces the blur.\r\nBased on an initial estimation we minimize an exchangeable loss function (for microscopy Poisson loss is widely used) with respect to a reconstruction being a consistent solution to the inverse problem. \r\nTo ensure certain constraints we allow that regularizers like Total Variation (TV) can be used. These regularizers are assembled before the optimization via metaprogramming and Tullio.jl.\r\nThe gradient of the full inverse problem pipeline is calculated by Zygote.jl and the optimization by Optim.jl (currently L-BFGS). Despite having microscopy images in mind the toolbox can be used for any type of signal deconvolution due to its flexibility. We also offer GPU/CUDA.jl support to a certain extend.\r\nThe full source code is available at [GitHub](https://github.com/roflmaostc/DeconvOptim.jl).", "recording_license": "", "do_not_record": false, "persons": [{"id": 9921, "code": "U3YH9P", "public_name": "Felix Wechsler", "biography": "[Felix Wechsler](https://felixwechsler.science) studied Physics and Informatics at the Technical University of Munich in Germany. For his master studies in Photonics he moved to Jena (city of light). Currently he finishes his master thesis in the field of computational microscopy at the [Biomedical Imaging Group of Leibniz Institute of Photonic Technology](https://nanoimaging.de/) under the joint supervision of Rainer Heintzmann and Ivo Ihrke.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9902, "guid": "95cf4949-a99d-54ed-8e74-462bd0763581", "logo": "", "date": "2021-07-28T17:20:00+00:00", "start": "17:20", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9902-matlab-to-julia-hours-to-minutes-for-mri-image-analysis", "url": "https://pretalx.com/juliacon2021/talk/WT8PHT/", "title": "Matlab to Julia: Hours to Minutes for MRI Image Analysis", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Magnetic resonance imaging (MRI) research has quickly entered the big data regime: hardware and software advances have given rise to (3+1)-dimensional MRI images which consist of 32-64 volumes with dimensions 250x250x250 or more, making non-trivial image processing computationally expensive. In this talk, we describe our experience translating an MRI image post-processing technique from Matlab to Julia (https://github.com/jondeuce/DECAES.jl), reducing computation times from 2 hours to 2 mins.", "description": "Like most fields of science, in magnetic resonance imaging (MRI) our appetite for data is never satiated \u2013 spatiotemporal resolution and signal-to-noise ratio can never be too high, and MRI scan times can never be too low. But, with big data comes big compute. MRI image reconstruction, for example, often involves parallel acquisition of multiple (3+1)D MRI images as measured by each of the 32+ scanner readout coils which are then combined through a complex series of iterative optimization problems. These types of algorithms are typically prototyped in high-level programming languages like Matlab or Python, and subsequently translated to C/C++ for deployment. The Julia community is familiar with this old story, though \u2013 in fact the fantastic package MRIReco.jl (https://github.com/MagneticResonanceImaging/MRIReco.jl) by Knopp et al. provides Julia implementations of MRI reconstruction algorithms which are competitive with C/C++. Post-processing these reconstructed MRI images faces similar computational challenges, and in this talk, we will describe our experience of implementing a parameter inference algorithm from the MRI subfield of myelin water imaging (MWI) in Julia.\r\n\r\nIn MWI, one analyses (3+1)D time series of image volumes acquired on cartesian spatiotemporal grids with dimensions 250x250x250x64 or more. The MRI time signals acquired in each voxel, which exhibit multi-exponential decay, are decomposed into a spectrum of decay rates. These decay rates are used to compute, among other useful metrics, the myelin water fraction (MWF) which is known to correlate with local myelin content in the brain. This inverse Laplace transform-like computation involves fitting an MRI signal model \u2013 the extended phase graph (EPG) model \u2013 to each time signal by solving an L2 regularized nonnegative least squares (NNLS) optimization problem. Note that, with images typically consisting of 10^7 voxels or more, this computation requires solving upwards of 10^7 optimization problems.\r\n\r\nPrior to this work, the NNLS procedure used for MWI was implemented in Matlab \u2013 a closed-source high-level programming language \u2013 as is common in MRI research. This computation is particularly poorly suited for Matlab, however. First, similar to the Python library numpy, Matlab encourages computations on vectors or matrices, as opposed to explicit for-loops, in order to call out to BLAS or LAPACK libraries and ameliorate the overhead of the Matlab interpreter. For this reason, the EPG algorithm \u2013 which is most efficiently expressed in terms of nested for-loops \u2013 was previously implemented in terms of sparse matrix-vector products in order to avoid Matlab\u2019s slow loops. Second, while the solving of independent optimization problems from each voxel is embarrassingly parallel, Matlab provides little control over multiprocessing optimizations such as reusing thread-local memory buffers and task scheduling. Lastly, Matlab does not provide a statically sized array type, which would be beneficial for micro-optimizing 3x3 matrix-vector products present in the EPG algorithm.\r\n\r\nJulia excels in these types of computations. In the DEcomposition and Component Analysis of Exponential Signals (DECAES.jl) package (https://github.com/jondeuce/DECAES.jl, https://doi.org/10.1016/j.zemedi.2020.04.001), we provide optimized procedures for computing MWI which address the aforementioned limitations of Matlab, and additionally include command line and Matlab interfaces for ease of interoperability. In all, DECAES.jl reduced computation times approximately 60X from 1.5-2.5 hours down to 1.5-2.5 mins. This large speedup demonstrates that it is possible to perform this analysis directly on the MRI scanner, removing the need for researchers to (manually) process the acquired data.\r\n\r\nAmong the many additional benefits from the Julia translation is the synergy with other Julia packages: we experimented with explicit SIMD vectorization in the EPG algorithm using the SIMD.jl package; we make liberal use of statically sized vectors and matrices using the StaticArrays.jl package; we use a pure-Julia implementation of NNLS using the NNLS.jl package. Furthermore, the EPG algorithm is independently useful outside of MWI, and can e.g. be efficiently differentiated trivially using the automatic differentiation packages ForwardDiff.jl or Zygote.jl.\r\n\r\nIn conclusion, we have found that the combination of high-performance and high-expressibility present in Julia is well suited to MRI research, particularly in comparison to existing Matlab-based workflows, and we believe that our experience will resonate with the scientific computing community more broadly. We look forward to the opportunity to share our experience.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10487, "code": "MJ9ECN", "public_name": "Jonathan Doucette", "biography": "MRI physics PhD student at the University of British Columbia. I study brain tissue microstructure by simulating MRI signals and using Bayesian learning for fast parameter inference.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9695, "guid": "04e7fdf7-caad-5d03-9632-c6f7d4df4fb0", "logo": "", "date": "2021-07-28T17:40:00+00:00", "start": "17:40", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9695-genify-jl-transforming-julia-into-gen-for-bayesian-inference", "url": "https://pretalx.com/juliacon2021/talk/PPG3CY/", "title": "Genify.jl: Transforming Julia into Gen for Bayesian inference", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Many Julia libraries implement stochastic simulators of natural and social phenomena, but they are not generally amenable to Bayesian inference. In this talk, we present Genify.jl, which transforms these simulators into the Gen probabilistic programming system via compiler injection, allowing us to compute likelihoods,  constrain random variables to specific values, and update these values for Monte Carlo inference, thereby enabling Bayesian inference over a wide range of existing Julia code.", "description": "A wide variety of libraries written in Julia implement stochastic simulators of natural and social phenomena for the purposes of computational science. However, these simulators are not generally amenable to Bayesian inference, as they do not provide likelihoods for execution traces, support constraining of observed random variables, or allow random choices and subroutines to be selectively updated in Monte Carlo algorithms.\r\n\r\nTo address these limitations, we present Genify.jl, an approach to transforming plain Julia code into generative functions in Gen, a universal probabilistic programming system with programmable inference. We accomplish this via lightweight transformation of lowered Julia code into Gen\u2019s dynamic modeling language, combined with a user-friendly random variable addressing scheme that enables straightforward implementation of custom inference programs.\r\n\r\nWe demonstrate the utility of this approach by transforming an existing agent-based simulator from plain Julia into Gen, and designing custom inference programs that increase accuracy and efficiency relative to generic SMC and MCMC methods. This performance improvement is achieved by proposing, constraining, or re-simulating random variables that are internal to the simulator, which is made possible by transformation into Gen.\r\n\r\nGenify.jl is available at: https://github.com/probcomp/Genify.jl", "recording_license": "", "do_not_record": false, "persons": [{"id": 10333, "code": "CFLQJP", "public_name": "Xuan (Tan Zhi Xuan)", "biography": "Xuan (Sh-YEN, IPA: \u0255\u0265\u025bn) is a PhD student at MIT in the Computational Cognitive Science and Probabilistic Computing research groups. Their current research focuses on inferring the hidden structure of human motivations by modeling agents as probabilistic programs, in the hope of aligning AI with the higher-order goals, values, and principles that humans strive (in part) to live by.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9703, "guid": "a0592e61-2cf2-5ebe-8440-223be0c8b125", "logo": "/media/juliacon2021/submissions/HVSAW9/general_oW2Lvi8.png", "date": "2021-07-28T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Purple", "slug": "juliacon2021-9703-code-docs-and-tests-what-s-in-the-general-registry-", "url": "https://pretalx.com/juliacon2021/talk/HVSAW9/", "title": "Code, docs, and tests: what's in the General registry?", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "The General registry is the collection of open source packages that makes up the Julia package ecosystem. Here, we take a survey: what fraction of packages have tests? CI? Docs? An open source license? How big are most packages? What's the biggest one? Are there many tiny packages? We will explore these questions and more with charts, plots, and discussion. We'll also show how to use PackageAnalyzer.jl to collect the data for yourself or take a look at a particular package (perhaps your own!).", "description": "We know that Julia is a modern language that makes adopting best programming practices, like documentation and testing, very simple, lowering the entry barriers for newcomers... but is that true?  We developed a package called [`PackageAnalyzer.jl`](https://github.com/JuliaEcosystem/PackageAnalyzer.jl) to try to answer this question and get more information about packages in the Julia ecosystem.\r\n\r\n[`PackageAnalyzer.jl`](https://github.com/JuliaEcosystem/PackageAnalyzer.jl) lets you statically inspect the content of a package and collect information about the use of documentation, testing suite, continuous integration, as well as the licenses used, the number of lines of code and the number of contributors.\r\n\r\nIn this talk we will show how to use [`PackageAnalyzer.jl`](https://github.com/JuliaEcosystem/PackageAnalyzer.jl) with your own package, and then iterate the analysis over any collection of packages, including all those in the General registry.  We will present plots and statistics about the open source packages in the Julia ecosystem.  We will be able to see what is the adoption of practices like documentation and testing, what are the most popular licenses and continuous integration services, what are the largest packages and in what languages they are written.  Additionally, we will have a look into the Julia community: how many users contributed to the Julia ecosystem and how many people work on a single package, on average?", "recording_license": "", "do_not_record": false, "persons": [{"id": 2405, "code": "ST7KZT", "public_name": "Mos\u00e8 Giordano", "biography": "Research Software Developer at UCL during the day, binary builder during the night.", "answers": []}, {"id": 4363, "code": "GBSYWE", "public_name": "Eric P. Hanson", "biography": "I recently finished my PhD in quantum information theory at the University of Cambridge. I\u2019m now a Research Scientist working at Beacon Biosignals, trying to make brain monitoring easily accessible, interpretable, and actionable.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9830, "guid": "c18d5a6c-6d21-5319-84d1-d1e0505caf14", "logo": "", "date": "2021-07-28T19:30:00+00:00", "start": "19:30", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9830-using-optimization-to-make-good-guesses-for-test-cases", "url": "https://pretalx.com/juliacon2021/talk/3LMU3W/", "title": "Using optimization to make good guesses for test cases", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Some applications seem untestable because they are slow to run, with too many options. One approach chooses tests carefully using an optimization algorithm to find the smallest set of tests that are likely to exercise all the parts of the code. In this talk, we introduce the UnitTestDesign.jl package for combinatorial testing and show how it integrates with Julia's test framework using Julia's system of artifacts and scratch spaces.", "description": "I'm developing the largest inference application I have ever seen. For any population, it estimates morbidity and mortality from disease, cast against a background of mortality, but this is measured across years for multiple ages. There are seven web pages of settings, and it can take a day to run. In some way, it's easy to test because it's an inverse problem, so I can create a correct answer, generate data, and see if the application finds the correct answer. What I want is a defensible claim that I've tested the seven pages of settings.\r\n\r\nMy first approach is to write tests for some important cases. These paradigmatic tests have to pass, and they tell stakeholders that the basics work well. I add to these some tests I know challenge the system. Beyond these two classes of tests are another set of less common techniques that help look for bugs where I don't expect them. These include random testing, concolic testing, and property-based testing. For this problem, let's focus on a simpler technique, combinatorial testing.\r\n\r\nCombinatorial testing is a careful selection of test arguments, designed to likely have good code coverage. If we picture a page of code, then any one call to a function will walk through that code, skipping parts of it when it fails an if-condition. A thorough set of tests should, at least, execute different parts of if-conditions. There must be some choice of inputs to the application that lead to every branch of the code. Some branches depend on two input arguments multiplied pairwise. Others may depend on a particular combination of three or four input arguments. It would be helpful to test each value of each option and, somehow, walk through all possible pairs of arguments or all possible triples of arguments, in order to cover all branches.\r\n\r\nIf we have twenty different options, each of which can take one of four values, we don't have to run twenty-times-four tests to try every value. We can pack them into only a few tests. What if we wanted to try all pairs of the first two values? For each pair, that's four-choose-two, or twelve, combinations of arguments, to make twelve tests for each pair, and there are twenty-choose-two pairs, but we can pack these together, too, so that each test case explores a lot of the code.\r\n\r\nThe algorithms in UnitTestDesign.jl use greedy optimization to construct short test suites to pack all-pairs testing into as few arguments as possible. For twenty arguments with four values each, it can pack every possible pair of arguments into thirty-seven test cases. There is some research support that all-pairs testing will do a good job of finding faults in code, but the same package can generate tests with higher coverage, where higher means all triples or quadruples of input values are included in test cases.\r\n\r\nMost implementations of all-pairs algorithms aren't easy to run in a unit-testing framework because they are web-based or proprietary. There are a few reasons for this. These algorithms need to deal with different argument types. They need to give the tester a way to say that, if a flag is false, then another argument can't take certain values, so they need a little domain-specific language. Julia handles those problems naturally and, further, is efficient at the greedy optimization to determine test cases. These can take time to generate.\r\n\r\nFor applications with many options, or functions with many arguments, generating a good set of test cases can be computationally intensive, so we rely on the testing framework to help us generate values when needed, save them, and load them later. In Julia, the packages for scratch space and artifacts give us a workflow for testing where we generate combinatorial values, save them to scratch, and upload them as artifacts for others to use.\r\n\r\nThe resulting approach is to create a set of tests, save them for reuse, and run them many times. Given the challenging problem of testing a large, slow application, we've begun to describe a paradigm from the field of test automation. The general approach is to create a bunch of tests, measure their coverage, select a set to run, and respond to failing tests by refining those tests until we've narrowed down the fault at their source. Parts of this general approach can be seen in random testing, concolic testing, and property-based testing. Compared with these, combinatorial testing is the art of starting with a really good guess.", "recording_license": "", "do_not_record": true, "persons": [{"id": 10417, "code": "9XHN8U", "public_name": "Andrew Dolgert", "biography": "Andrew Dolgert is a computational scientist at the University of Washington. He has been a high-performance computing consultant for many years, working on diverse projects such as parallelization of molecular dynamics, immersive visualization of fracture mechanics, provenance for the Large Hadron Collider, and time series analysis of the world's global health. His recent work is on continuous-time, discrete-event simulation and on testing of scientific code.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11102, "guid": "26881760-bc76-5ef8-8ceb-911c60574d07", "logo": "", "date": "2021-07-28T19:40:00+00:00", "start": "19:40", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-11102-building-interactive-repl-based-visualizations-in-gridworlds-jl", "url": "https://pretalx.com/juliacon2021/talk/DX7DCQ/", "title": "Building Interactive REPL-based Visualizations in GridWorlds.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Visualization often plays an important role in several disciplines. For example, in reinforcement learning, visualization tools are indispensable for testing environment logic and analyzing agent behavior. Using the GridWorlds.jl package as an example, I will explain some fundamental concepts and techniques to enable anyone to easily build their own terminal-based visualizations from scratch, and demonstrate how they can be leveraged to create productive workflows inside the Julia REPL.", "description": "Resources:\r\nRepository for this talk: https://github.com/Sid-Bhatia-0/JuliaCon2021Talk\r\nGridWorlds.jl: https://github.com/JuliaReinforcementLearning/GridWorlds.jl\r\n\r\nA good visualization can sometimes drastically speed up the understanding of a program. Plots are an obvious example of this. Additionally, in reinforcement learning, for example, other forms of visualizations are often used to test out an environment, and also to analyze the behavior of an agent in the environment at various points during its training process.\r\n\r\nWhile developing complex programs, it often pays off well to write visualization tools from an early stage, especially when the correctness of a program cannot be verified via writing test cases alone. Reinforcement learning environments, or any kinds of games for that matter, are a good example of this. In many cases, people may overestimate the cost of creating such tools relative to the value they provide, and might perceive such a task to be more challenging than it actually is. I am here to show you that in some cases, it is much easier than you might think.\r\n\r\nThe Julia REPL offers several valuable features, often making it an indispensable part of a Julia user\u2019s workflow in some form or another. It is possible to take this one step further and create interactive terminal-based visualizations that unlock even more productive workflows while using the REPL.\r\n\r\nI will showcase some relevant features from the GridWorlds.jl package as a concrete example of increased developer productivity using interactive terminal-based visualizations in the REPL. In this package, plain keyboard inputs allow one to rapidly test and debug tile-based reinforcement learning environments by directly visualizing and playing them inside the terminal. One can instantly switch back and forth between testing an environment and debugging it in the REPL in the same REPL session without losing the local state. Additionally, one can also record these interactions and replay them inside the REPL by stepping through the individual frames. This feature also proves extremely handy when analyzing the behavior of an agent at various points during training.\r\n\r\nI will deconstruct the essential pieces necessary to create and run such a visualization inside the terminal and explain how it can be built from scratch, only utilizing things that already ship with Julia.\r\n\r\nThe techniques and tricks explained in this talk are much more generally applicable. I encourage everyone to think about how you can creatively augment your current workflow to make it even more productive and engaging for your domain.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11534, "code": "SYTUPE", "public_name": "Siddharth Bhatia", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9729, "guid": "2314c66e-c3e9-5aaf-8e83-611e6921b75e", "logo": "", "date": "2021-07-28T19:50:00+00:00", "start": "19:50", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9729-catwalk-jl-a-profile-guided-dispatch-optimizer", "url": "https://pretalx.com/juliacon2021/talk/FZ99RD/", "title": "Catwalk.jl: A profile guided dispatch optimizer", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Catwalk.jl can speed up long-running Julia processes by minimizing the overhead of dynamic dispatch. It is a JIT compiler that continuosly re-optimizes dispatch code based on data collected at runtime.\r\nIt features a low overhead statistical profiler and a tunable cost model to drive recompilation decisions.\r\n\r\nI will talk about its target use case, performance characteristics, some implementation details and its connections to the Julia ecosystem.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10357, "code": "AFFMXZ", "public_name": "Kriszti\u00e1n Sch\u00e4ffer", "biography": "Working on a sparse-AI actor runtime, researching decentralized algorithms, playing with runtime code generation.", "answers": []}], "links": [], "attachments": [], "answers": []}], "BoF/Mini Track": [{"id": 9628, "guid": "eecf877f-fec9-5f4c-8f02-3cf9d417d8d9", "logo": "", "date": "2021-07-28T12:30:00+00:00", "start": "12:30", "duration": "01:30", "room": "BoF/Mini Track", "slug": "juliacon2021-9628-building-a-chemistry-and-materials-science-ecosystem-in-julia", "url": "https://pretalx.com/juliacon2021/talk/ZQJAW3/", "title": "Building a Chemistry and Materials Science Ecosystem in Julia", "subtitle": "", "track": null, "type": "Birds of Feather", "language": "en", "abstract": "Julia has a growing presence in the computational chemistry and materials science communities, already exhibiting best-in-class performance in several domains. However, a common set of tools, datatypes, and norms are largely lacking at present. In this session, we will have discussions to build consensus around a vision for such tools, with an emphasis on reusable structures/workflows, such as I/O for common file types, bindings for widely-used codes from other languages, and mathematical tools.", "description": "Julia is a natural choice for computational chemists and materials scientists, primarily due to its excellent computational performance combined with ease of code sharing and extensibility within and between packages. Unsurprisingly, interest in and use of Julia within this community is growing \u2013 in particular, at JuliaCon 2020, several packages were introduced (such as JuliaChem and DFTK) that generated substantial \u201cbuzz\u201d in the community, and despite being quite young (O(1) developer-year of invested effort), these packages are already matching or even exceeding best-in-class performance for some use cases!\r\n\r\nThis BoF session aims to continue this momentum, as well as to set some longer-term goals and norms for the community as a whole. To our knowledge, there has not yet been a broad discussion of this kind, and an informal proposal on Julia Discourse (see discourse.julialang.org/t/interest-in-chemistry-focused-bof ) indicated enthusiasm from a variety of developers and users.\r\n\r\nIn particular, at present, standards such as how to represent certain ubiquitous types of data and perform common tasks is lacking, which can lead to inadvertent duplication of effort. As interest in and use of Julia in these communities grows, the impact of establishing such norms multiplies. In this session, we plan to host a community discussion aimed at building consensus around these topics. Some specific examples include, but are not necessarily limited to:\r\n\r\n1. I/O for common structure file types (e.g. .cif, .xyz) and Julia data types for representing these structures (examples of Python versions of such systems include those provided by the Atomic Simulation Environment and pymatgen)\r\n2. Frequently-invoked mathematical procedures such as integration on common types of grids or using common sets of basis functions utilized within quantum chemical simulation approaches such as density functional theory and (post-)Hartree-Fock\r\n3. Julia bindings for widely-used codes in other languages (primarily C, C++, and Python) that are not worth duplicating in Julia in the short term but which provide functionality such as parsing outputs of simulation codes as well as some of the mathematical operations described above.\r\n\r\nWe are optimistic that the discussions in this session will both help to strengthen ties within this small but growing community as well as help to amplify its productivity and impact!", "recording_license": "", "do_not_record": false, "persons": [{"id": 9646, "code": "BKJLVX", "public_name": "Rachel Kurchin", "biography": "Usually writing code (or docs!) or triathlon-ing.\r\n\r\nMore at [my website](https://rkurchin.github.io).", "answers": []}, {"id": 3526, "code": "DZ7WHZ", "public_name": "Michael F. Herbst", "biography": "By training a chemist, who got more and more twisted towards the \"dark side\" of numerical analysis. Now working as a PostDoc at the [Applied and Computational Mathematics](http://www.acom.rwth-aachen.de) lab of RWTH Aachen University, Germany. Lead developer of [DFTK](https://dftk.org), a Julia code for mathematical research in on density-functional theory (a quantum chemistry method).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9831, "guid": "77c1d3bc-939f-5c99-b1cc-f93ea44e1305", "logo": "", "date": "2021-07-28T16:30:00+00:00", "start": "16:30", "duration": "02:00", "room": "BoF/Mini Track", "slug": "juliacon2021-9831-set-propagation-methods-in-julia-techniques-and-applications", "url": "https://pretalx.com/juliacon2021/talk/DRMPLU/", "title": "Set Propagation Methods in Julia: Techniques and Applications", "subtitle": "", "track": null, "type": "Minisymposium", "language": "en", "abstract": "This minisymposium presents modern approaches to analyze a variety of mathematical systems in Julia, via set propagation techniques: dynamical systems, cyber-physical systems, probabilistic systems, and neural networks. To deploy those systems in the real world there is an increasing demand for safe and reliable models. The speakers represent a broad cross-section of work from different fields that build on set-based techniques and global optimization to address such challenges.", "description": "- Organisers: Marcelo Forets (@mforets) and Christian Schilling (@schillic)\r\n\r\n- Moderator: David P. Sanders (@dpsanders)\r\n\r\nA new generation of algorithms is addressing the fundamental challenge of how to exhaustively explore all possible scenarios for simulation of dynamical systems under model uncertainties. Moreover, deep neural networks play an increasing role in control and safety-critical applications, although it is often not known how to guarantee that they will behave correctly and safely under all circumstances. This minisymposium will host applications of set-based techniques and global optimization in Julia that address these questions.\r\n\r\nWe have made sure to reach out to several different groups who are working on set propagation techniques and their application in a wide range of areas, to present a broad overview of the area.\r\n\r\nPlan: 1 introductory talk (non-Julia-specific), 5 regular talks, 1 Q&A panel.\r\n\r\n- Introduction by Goran Frehse (Hybrid Systems Semantics group, Computer Science and System Engineering Laboratory (U2IS), ENSTA Paris. [Homepage](https://sites.google.com/site/frehseg/home).\r\n\r\n- **Using Set Propagation and the Finite Element Method For Time Integration in Transient Solid Mechanics Problems.**  By Jorge P\u00e9rez Zerpa (speaker), Marcelo Forets and Daniel Freire Caporale. The Finite Element Method (FEM) is the gold standard for numerical simulation in transient solid mechanics problems. Several time-integration algorithms have been developed in recent decades; however, it is still a challenging problem to completely describe the family of dynamically-feasible behaviors from given sets of initial states. In this talk we take a set-based approach and conclude that it has a lot of potential to efficiently solve such problems.\r\n\r\n- **Dionysos.jl: Optimal Control of Cyber-Physical Systems.** By Benoit Legat, Guillaume Berger, Julien Calbert (speaker) and Rapha\u00ebl Jungers. [Dionysos.jl](https://github.com/dionysos-dev/Dionysos.jl) is software produced by the ERC project Learning to Control (L2C). In view of the Cyber-Physical Systems (CPS) revolution, the only sensible way of controlling these complex systems is by discretizing the different variables, thus transforming the model into a simple combinatorial problem on a finite-state automaton, called an abstraction of this system. Our goal is to transform this approach into an effective, scalable, cutting-edge technology that will address the challenges of CPS and unlock their potential.\r\n\r\n- **Solving Optimization Problems with Embedded Dynamical Systems.** By Matthew Wilhelm (speaker) and Matthew Stuber. We will discuss our recent work at [PSORLab](https://github.com/PSORLab): EAGODynamicOptimizer.jl and DynamicBounds.jl packages. These extend our EAGO.jl nonconvex optimizer to address formulations containing embedded dynamical systems. We highlight a series of approaches for constructing the requisite convex and concave relaxations of differential equations in the original decision space and discuss the use of such techniques in a global optimization context. These methods may readily be composed with existing McCormick relaxation approaches, which allows for the solution of general nonlinear formulations to certified global optimality. Use cases relevant to hybrid data-driven process modeling, parameter estimation, and worst-case robust design are discussed.\r\n\r\n- **Computing with sets of probabilities in Julia.** By Ander Gray. There are many ways to mathematically define a set of probability distributions, including: intervals, possibility distributions, random sets and probability boxes (p-boxes). These structures were discovered independently from one another, but are often synonymous and can be translated. Imprecise Probability theory links all these theories into one. In this presentation, we present [ProbabilityBoundsAnalysis.jl](https://github.com/AnderGray/ProbabilityBoundsAnalysis.jl) (PBA) a numerical implementation of p-box arithmetic in Julia, which gives an arithmetic of random variables where both marginal distributions and dependencies may be partially defined. We show how PBA may be used to rigorously propagate distributions and p-boxes in reachability problems using [ReachabilityAnalysis.jl](https://github.com/JuliaReach/ReachabilityAnalysis.jl).\r\n\r\n- **Methods to Soundly Verify Deep Neural Networks.** By Tomer Arnon. Deep neural networks are widely used for nonlinear function approximation, with applications ranging from computer vision to control. Although these networks involve the composition of simple arithmetic operations, it can be very challenging to verify whether a particular network satisfies certain input-output properties. [NeuralVerification.jl](https://github.com/sisl/NeuralVerification.jl) implements several methods that have emerged recently for soundly verifying such properties. We discuss fundamental differences between existing algorithms and compare them on a set of benchmark problems.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10415, "code": "V93HYB", "public_name": "Marcelo Forets", "biography": "[Marcelo Forets](https://github.com/mforets) is an Applied Mathematician that works as Assistant Professor at Universidad de la Rep\u00fablica (Uruguay). Born in Uruguay (Montevideo, 1988), he graduated in Physics and in Electrical Engineering, then moved to France for a PhD in Mathematics and Informatics (Univ. Joseph Fourier,  France) on the quantum random walk, a model of particular interest to Quantum Computing. He was a post-doc researcher at VERIMAG laboratory of Universit\u00e9 Grenoble Alpes (France) under the supervision of Oded Maler and Goran Frehse, where he started to develop what is now the [JuliaReach](http://juliareach.com) package ecosystem. His research has to do with developing innovative numerical tools that impact decisions regarding reliability, correctness and safety of control systems, hybrid dynamical systems, and robustness analysis of neural networks.", "answers": []}, {"id": 10444, "code": "HB7CMX", "public_name": "Christian Schilling", "biography": "[Christian Schilling](https://www.christianschilling.net/) received his Ph.D. degree in computer science from the University of Freiburg, Germany, in 2018 under the supervision of Andreas Podelski.  He was a postdoctoral research fellow at IST Austria in the group of Thomas A. Henzinger.  Since 2020 he is the interim professor for cyber-physical system at the University of Konstanz, Germany.  Christian's research in the area of formal methods is focused on the analysis, verification, and synthesis of systems with dynamical or machine-learned components. He is a co-lead developer in the JuliaReach ecosystem.", "answers": []}, {"id": 10454, "code": "ZQLCJF", "public_name": "Ander Gray", "biography": "Ander Gray received \u202fan MSci in Physics from Queen\u2019s University Belfast (2017). Since then, he has been a PhD student at the University of Liverpool and \u202fCulham \u202fCentre for Fusion Energy, studying Uncertainty Quantification. For his thesis work, Ander \u202fresearches \u202fmethods for efficiently propagating uncertainty in radiation transport simulations. He is also involved in developing methods and software for calibrating and propagating uncertainties through computational models, in the form of imprecise probabilities.", "answers": []}, {"id": 1022, "code": "TJJRTG", "public_name": "David P. Sanders", "biography": "Professor of Computational Science at the Universidad Nacional Aut\u00f3noma de M\u00e9xico and visiting professor at MIT.\r\n\r\nInterested in computational science, interval arithmetic, and numeric-symbolic computing.\r\n\r\nAuthor of the JuliaIntervals suite of packages for interval arithmetic, and various tutorials on Julia.", "answers": []}, {"id": 10458, "code": "8HFHCB", "public_name": "Matthew Wilhelm", "biography": "Matthew E. Wilhelm received a B.S. in Applied Mathematics from the University of North Carolina at Greensboro, Greensboro, NC, USA (2009), and a M.S. in Chemical Engineering from Columbia University, New York, NY, USA (2011). He is currently a PhD Candidate in Chemical and Biomolecular Engineering at the University of Connecticut where his research interests include: nonconvex optimization, dynamic simulation and optimization, mathematical biology, and engineering & STEM pedagogy.", "answers": []}, {"id": 10463, "code": "9G8UXL", "public_name": "Goran Frehse", "biography": "Goran Frehse has a Diploma in Electrical Engineering and Information Technology from Karlsruhe Institute of Technology, Germany, and a PhD in Computer Science from Radboud University Nijmegen, the Netherlands. From 2006 to 2018, he was an associate professor at the University Grenoble Alpes, from which he obtained a habilitation in 2016. From 2016 to 2018, he held a research chair (Chaire Initiative Universitaire Alpes) at the Univ. Grenoble Alpes. Since 2018, he is a professor at ENSTA Paris, where he continues his research on safe cyber-physical systems.", "answers": []}, {"id": 10462, "code": "PC8YRX", "public_name": "Jorge P\u00e9rez Zerpa", "biography": "Jorge P\u00e9rez Zerpa obtained a Doctorate in Engineering degree by Universidad de la Rep\u00fablica in Uruguay, a MSc in Mechanical Engineering degree by Universidade Federal de Rio de Janeiro in Brazil, and did a stage at INRIA's TAO team in France. He is Assistant Professor at the Structures Department of the School of Engineering in Universidad de la Rep\u00fablica, and Researcher level 1 at ANII.uy . His research work includes the development and application of numerical methods in computational modelling of solids and structures, with focus in constitutive parameter identification methods. He leads the development of the Open Nonlinear Structural Analysis Solver (onsas.org) based in the application of the Finite Element Method.", "answers": []}, {"id": 10464, "code": "PCUKUA", "public_name": "Deleted User", "biography": "", "answers": []}, {"id": 10465, "code": "UBWNWX", "public_name": "Julien Calbert", "biography": "Ph.D. candidate at the Institute of Information and Communication Technologies, Electronics and Applied Mathematics (ICTEAM) of Universit\u00e9 Catholique de Louvain (UCL), Louvain-la-Neuve, Belgium.", "answers": []}, {"id": 10468, "code": "FMXGKD", "public_name": "Tomer Arnon", "biography": "Ph.D. candidate at the Stanford Intelligent Systems Laboratory, Stanford (USA).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9687, "guid": "ce8367cc-3d16-5ac5-a748-2609fe21cf11", "logo": "", "date": "2021-07-28T19:00:00+00:00", "start": "19:00", "duration": "01:30", "room": "BoF/Mini Track", "slug": "juliacon2021-9687-fancy-arrays-bof-2", "url": "https://pretalx.com/juliacon2021/talk/A93QFU/", "title": "Fancy Arrays BoF 2", "subtitle": "", "track": null, "type": "Birds of Feather", "language": "en", "abstract": "This is the second of two BoFs planned several years ago, to replace AxisArrays.jl.\r\nPer the original plan, we would go away and make many packages to try many ideas. Come back and touch base in 2020, and then draw conclusions in 2021.\r\nThe goal this year is to determine a final plan to either get down to a small number of packages, or establish a common interface.", "description": "Notes from [last years discussions can be found here](https://docs.google.com/document/d/1imBX3k0EEejauWVyXONZDRj8LTr0PeLOJNGEgo6ow1g/edit#heading=h.qrm4q6q56yxm).\r\n\r\nSince then it has emerged clarity of 3 packages that can basically replace AxisArrays.jl with a more modern and idiomatic interface. \\\r\nIn approximate order of power and also complexity (both for users and for maintainers) they are:  [AxisKeys.jl](https://github.com/mcabbott/AxisKeys.jl), [AxisIndices.jl](https://github.com/Tokazama/AxisIndices.jl/), and [DimensionalData.jl](https://github.com/rafaqz/DimensionalData.jl) (the former two building upon [NamedDims.jl](https://github.com/invenia/NamedDims.jl/) for naming axes). \\\r\nSince last year, [IndexedDims.jl](https://github.com/invenia/IndexedDims.jl/) has been deprecated in favour of  [AxisKeys.jl](https://github.com/mcabbott/AxisKeys.jl).\r\n\r\nAn ideal outcome of this BoF session would be an agreement to deprecate an additional package for one of  the others, or even deprecating two leaving one. \\\r\nA less ideal, but still very good outcome of the BoF is to discuss a common API (like [Tables.jl](https://github.com/JuliaData/Tables.jl)), which each package can extend, and to direct someone to lead the establishment of this API, and ensure that it gets rolled out.\r\n\r\nWe'll be using a [google doc](https://docs.google.com/document/d/1RPQw3zMGRVm8cayUrQhFGzlKV5hp-1DJMUE32H_-bgo/edit?usp=sharing) to organize speaking turns during the call.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1095, "code": "ECUZBT", "public_name": "Lyndon White", "biography": "Lyndon White (@oxinabox) is a research software engineer at Invenia Labs (Cambridge, UK). He helps researchers use machine learning, constrained optimization, and generally tools from the technical computing domain to optimize the power grid. He get to do all the best parts of being a software developer and all the best parts of being a researcher, its great.\r\nHe works a lot on the Julia AutoDIff code, and is the leader of the ChainRules project.", "answers": []}, {"id": 12549, "code": "UAYRQP", "public_name": "Rory Finnegan", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}], "JuMP Track": [{"id": 9899, "guid": "12fc533f-c47c-5f31-aa66-1fd1fdba86ef", "logo": "", "date": "2021-07-28T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-9899-the-state-of-jump", "url": "https://pretalx.com/juliacon2021/talk/X7QCPU/", "title": "The state of JuMP", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "JuMP is a modeling language and collection of supporting packages for mathematical optimization in Julia. JuMP makes it easy to formulate and solve linear programming, semidefinite programming, integer programming, convex optimization, constrained nonlinear optimization, and related classes of optimization problems.\r\n\r\nIn this talk, we discuss the state of JuMP, preview some recently added features, and discuss our plans for the future.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10481, "code": "QREN8R", "public_name": "Oscar Dowson", "biography": "Oscar Dowson is a core-developer of JuMP and member of the JuMP steering committee.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10862, "guid": "015b1fca-0de2-53dd-b88d-1614329e5937", "logo": "", "date": "2021-07-28T13:00:00+00:00", "start": "13:00", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10862-what-s-new-in-cosmo-", "url": "https://pretalx.com/juliacon2021/talk/UDWSEC/", "title": "What's new in COSMO?", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In this talk we describe two recent improvements to the COSMO solver. The first improvement is an automatic clique merging strategy which allows COSMO to solve large sparse SDPs more effectively. The second improvement is a safeguarded acceleration method that wraps around the solver's ADMM algorithm. We show that this leads to a significant improvement in  both convergence and solve time to higher accuracy solutions. We tested the method on more than 500 QPs and SDPs from various applications.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 11318, "code": "CLJWR7", "public_name": "Michael Garstka", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10867, "guid": "33825325-2dab-5162-b848-4950c67c0f82", "logo": "", "date": "2021-07-28T13:30:00+00:00", "start": "13:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10867-conic-optimization-example-problems-in-hypatia-s-examples-folder", "url": "https://pretalx.com/juliacon2021/talk/7KECGM/", "title": "Conic optimization example problems in Hypatia's examples folder", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Hypatia is a conic interior point solver written in Julia, with a generic cone interface. In Hypatia's examples folder, we have implemented around three dozen applied examples from a wide variety of domains (see https://chriscoey.github.io/Hypatia.jl/dev/examples/). In this talk, we summarize Hypatia's examples, scripts, and the results of our computational comparisons on thousands of conic instances generated from our examples.", "description": "Most of these examples have multiple formulation options, and together these formulations cover all of Hypatia's several dozen predefined cone types (see https://chriscoey.github.io/Hypatia.jl/dev/api/cones/#Predefined-cone-types). Using scripts in Hypatia's scripts folder, we use these examples to (1) compare the performance of Hypatia's algorithmic options/enhancements, and (2) to assess the value of low-dimensional natural formulations versus standard conic formulations that only use cones currently recognized by other conic solvers.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11321, "code": "ZBXW73", "public_name": "Chris Coey", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10921, "guid": "fa282bde-7285-567d-982d-38beeed7453b", "logo": "", "date": "2021-07-28T16:30:00+00:00", "start": "16:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10921-symmetry-reduction-for-sum-of-squares-programming", "url": "https://pretalx.com/juliacon2021/talk/L8DTE3/", "title": "Symmetry reduction for Sum-of-Squares programming", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In this talk we discuss a symmetry reduction approach relying on the invariance of the polynomial under a group of actions. From the algebraic properties of the group, the SymbolicWedderburn package determines a change of basis that enables the decomposition of the constraints into smaller bases, some of them being equal which further reduces the problem. We show how to specify the group symmetry to allow SumOfSquares to perform this reformulation automatically.", "description": "Sum-of-Squares or semidefinite programming allows to provide guaranteed bounds on remarkably many problems. Although several efficient algorithms exist to solve these programs, their space and time complexity and even their numerical robustness do not scale well with the size of the polynomial basis or semidefinite matrix. To alleviate this problem different methods have been developed to reduce constraints with a large basis or matrix into smaller ones.\r\nThese exploit sign symmetry or sparsity structure using chordal decomposition.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10452, "code": "MLJG3F", "public_name": "Beno\u00eet Legat", "biography": "Beno\u00eet Legat is a postdoctoral associate at MIT with Prof. Pablo Parrilo\r\nin the Laboratory for Information and Decision Systems (LIDS).\r\nHe received his Ph.D. degree in applied mathematics from the UCLouvain, Belgium, in 2020.\r\nHis research interests include mathematical optimization, invariant set computation and\r\noptimal control.", "answers": []}, {"id": 12289, "code": "RYTVJE", "public_name": "Marek Kaluba", "biography": "I'm a mathematician, researcher in geometric group theory at KIT (Karlsruhe, Germany); I received my PhD in pure mathematics in 2014 and since then changed my scientific focus to aspects including more computational problems. I've been coding in julia since 2016, mostly around group theory, mathematical optimization and certified computation.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9927, "guid": "a69f3c76-6ea9-523c-b6bd-ef8b8fa566e5", "logo": "", "date": "2021-07-28T17:10:00+00:00", "start": "17:10", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-9927-sparse-matrix-decomposition-and-completion-with-chordal-jl", "url": "https://pretalx.com/juliacon2021/talk/8E9BAK/", "title": "Sparse Matrix Decomposition and Completion with Chordal.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We will introduce Chordal.jl, which includes several extensible algorithms for sparse matrices with a chordal sparsity pattern. We will overview the algorithms in this package and showcase their application in sparse semidefinite programming.", "description": "In this talk, we will introduce chordal graphs and some of their core properties. These properties enable many otherwise difficult problems, such as minimum vertex coloring, to be solved efficiently. Furthermore, they lead to several decomposition results for sparse matrices. \r\n\r\nWe will introduce Chordal.jl, a package for working with sparse matrices that have a chordal sparsity pattern. We will overview the algorithms implemented in this package and their applications, including Euclidean distance matrix completion and optimization with sparse data. \r\n\r\nWe will conclude by using Chordal.jl to dramatically reduce the solve time of a sparse semidefinite program (SDP). Solving large, sparse semidefinite programs (SDPs) remains computationally prohibitive for many existing solvers, and this application largely motivated the development of this package.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10507, "code": "H8VVYE", "public_name": "Theo Diamandis", "biography": "Theo Diamandis is a PhD student studying optimization at MIT.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10861, "guid": "2da7eaf7-5773-597c-b578-eb10dcc5ca7e", "logo": "", "date": "2021-07-28T17:20:00+00:00", "start": "17:20", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-10861-automatic-dualization-with-dualization-jl", "url": "https://pretalx.com/juliacon2021/talk/8YGNYU/", "title": "Automatic dualization with Dualization.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "In this talk, we present Dualization.jl, an extension that allows users to dualize optimization problems defined in JuMP. The dual formulation can be used to better suit the description of the optimization problem to the format expected by the conic solver. Moreover, automatic dualization can be used to model bilevel problems by automatically building some of the KKT conditions.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 4268, "code": "PCLZTQ", "public_name": "Guilherme Bodin", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10882, "guid": "6a166125-c081-5e61-8c77-cc36ab7b2728", "logo": "", "date": "2021-07-28T17:30:00+00:00", "start": "17:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10882-modeling-bilevel-optimization-problems-with-bileveljump-jl", "url": "https://pretalx.com/juliacon2021/talk/WULB78/", "title": "Modeling Bilevel optimization problems with BilevelJuMP.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In this talk, we present BilevelJuMP.jl an extension that makes it straightforward for users to write bilevel problems just like JuMP made it easy to write optimization problems. BilevelJuMP.jl uses Dualization.jl to generate the dual constraints of KKT conditions and has multiple formulations for complementarity constraints such as SOS1, Fortuny-Amat, quadratic programming, and actual complementarity constraints.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 11335, "code": "LRPWKX", "public_name": "Joaquim Dias Garcia", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10880, "guid": "cc0b4045-9d25-5685-a8c1-db7df584da33", "logo": "", "date": "2021-07-28T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10880-infinite-dimensional-optimization-with-infiniteopt-jl", "url": "https://pretalx.com/juliacon2021/talk/YVCM8B/", "title": "Infinite-Dimensional Optimization with InfiniteOpt.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We present InfiniteOpt.jl which facilitates a coherent unifying abstraction for characterizing infinite-dimensional optimization problems rigorously through a common lens. This decouples models from discretized forms and promotes the use of novel transformations. This new perspective encourages new theoretical crossover and novel problem formulations (creating new disciplines like random field optimization).", "description": "Infinite-dimensional optimization problems are a challenging problem class that cover a wide breadth of optimization areas and embed complex modeling elements such as infinite-dimensional variables, measures, and derivatives. Typical modeling approaches (e.g., those behind Gekko and Pyomo.dae) often only consider discretized formulations and do not provide a unified paradigm across the various disciplines.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11334, "code": "YNHAFQ", "public_name": "Joshua Pulsipher", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10872, "guid": "4822d631-f153-5808-bcc8-a2f3c958a416", "logo": "", "date": "2021-07-28T19:30:00+00:00", "start": "19:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10872-hybrid-strategies-using-piecewise-linear-decision-rules", "url": "https://pretalx.com/juliacon2021/talk/CEFANG/", "title": "Hybrid Strategies using Piecewise-Linear Decision Rules", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In this talk, we discuss planned extensions to the features provided by JuMPeR via the following three attributes: (1) introduction of new policy type to the adaptive decisions, (2) introduction of the stochastic programming objective function paradigm and (3) introduction of moving/folding horizon simulator features to assess the robust/stochastic affine policies. The third attribute is closely related to what is known as pareto optimality of robust adaptive solutions.", "description": "Decision rules offer a rich and tractable framework for solving certain classes of multistage adaptive optimization problems. Recent literature has shown the promise of using linear and nonlinear decision rules in which wait-and-see decisions are represented as functions, whose parameters are decision variables to be optimized, of the underlying uncertain parameters.  Despite this growing success, solving real-world stochastic optimization problems can become computationally prohibitive when using nonlinear decision rules, and in some cases, linear ones. Consequently, decision rules that offer a competitive trade-off between solution quality and computational time become more attractive. Whereas the extant research has always used homogeneous (i.e., either linear or piecewise-linear) decision rules, the major contribution of this paper is a computational exploration of hybrid decision rules combining the benefits of the two classes of decision rules. We also demonstrate a case where, unexpectedly, a linear decision rule is superior to a more complex piecewise-linear decision rule within a simulator. This observation bolsters the need to assess the quality of decision rules obtained from a look-ahead model within a simulator rather than just using the optimal look-ahead objective function value.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11326, "code": "ZXG8YP", "public_name": "Said Rahal", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9316, "guid": "6870de82-539d-502a-89e8-4fa25f694463", "logo": "", "date": "2021-07-28T20:00:00+00:00", "start": "20:00", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-9316-flexible-set-projections-with-mathoptinterface", "url": "https://pretalx.com/juliacon2021/talk/X9BNQV/", "title": "Flexible set projections with MathOptInterface", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "MathOptInterface has become a pillar of constrained optimization in Julia, defining a common language unifying multiple branches of mathematical optimization. We will present MathOptSetDistances.jl, a package to compute distances to and projections onto sets, and the differentiation of these operations. We will cover the motivation behind it, how it started and highlight learned lessons on the way.", "description": "This talk introduces the main abstractions of MathOptInterface.jl, the central interface for expressing constrained optimization problems in Julia and explains how an extension for distances and projections.\r\n\r\nMathOptSetDistances.jl defines an API for projecting points onto sets and computing distances from a point to a given set defined in MathOptInterface.jl. It has become a toolbox used by other packages built on top of MathOptInterface.jl and opens new features accessible to Convex.jl, JuMP.jl, and their extensions. Computing distances and projections is central to many optimization algorithms, to compute the violation of a constraint or projecting back onto a feasible set.\r\n\r\nOne challenge that arose from distance computation is designing an interface with a consistency guarantee on the definition of distances while allowing alternative distance implementations for some sets.\r\n\r\nThe projections and distances operators are also differentiable and implement both a full Jacobian computation and the ChainRules API, which we will illustrate on some sets.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1216, "code": "DK9KDB", "public_name": "Mathieu Besan\u00e7on", "biography": "Mathieu is a researcher in computational mathematics working at the Zuse Institute Berlin. His interests span mixed-integer, convex optimization, applications in engineering and statistics.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10978, "guid": "dd962ab6-36de-555d-91fc-798f99204d83", "logo": "", "date": "2021-07-28T20:10:00+00:00", "start": "20:10", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-10978-solving-optimization-problems-at-fonterra", "url": "https://pretalx.com/juliacon2021/talk/3F88PP/", "title": "Solving optimization problems at Fonterra", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "In this talk we discuss how the Data Science team at Fonterra, a New Zealand dairy co-operative responsible for 30% of the world trade in dairy exports,  use JuMP to solve planning problems relating to organic milk production.", "description": "Solving optimization problems in a business setting can be a significant challenge. There is a constant tension between delivering quick prototypes to prove value and building robust tools.  \r\n\r\nAt Fonterra, a New Zealand dairy co-operative, one of our planning problems concerns organic milk production. Due to low volumes or organic-certified milk, organic production planning takes place outside the usual planning process.  The constraints around organic problems are complex, and there is considerable value to be derived from a quality plan. These factors make organic planning a perfect candidate for a stand-alone optimization project within the business. \r\n\r\nDuring this project, JuMP has been an invaluable tool in several ways. Using JuMP, it has been trivial to develop quick prototypes and experimental features, without sacrificing the robustness of the end-product.  JuMP enables our team to be creative during the process and try new things on the fly. We can quickly respond to feedback from end users, which helps build a close relationship and ensure the continued success of the project. JuMP is also a reliable tool for building larger optimization applications, enabling the Data Science team at Fonterra to easily incorporate different multi-objective optimization approaches, optional cuts and complex conditional constraints into the model. \r\n\r\nThanks to JuMP, we have been able to mitigate the problem outlined at the start of the abstract, and secure key user engagement through continuous proof of value while delivering robust software.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11427, "code": "8YXJSG", "public_name": "Oleg Barbin", "biography": "Oleg is a data scientist at Fonterra, a New Zealand Dairy Co-operative.  Much of his work concerns milk production planning problems.  Previously, he worked at Suez, who supply systems for the control of water utilities based on integer programming.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10877, "guid": "596401df-6a50-5c51-a206-8f7f031f8486", "logo": "", "date": "2021-07-28T20:20:00+00:00", "start": "20:20", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-10877-tssos-jl-exploiting-sparsity-in-polynomial-optimization", "url": "https://pretalx.com/juliacon2021/talk/XFC73Y/", "title": "TSSOS.jl: exploiting sparsity in polynomial optimization", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "TSSOS.jl helps polynomial optimizers solve large-scale problems with sparse input data. The underlying algorithmic framework is based on exploiting correlative and term sparsity to obtain a new moment-SOS hierarchy involving  potentially much smaller positive semidefinite matrices. TSSOS can be applied to numerous problems ranging from power networks to eigenvalue and trace optimization of noncommutative polynomials, involving up to tens of thousands of variables and constraints.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 11331, "code": "8GS7FH", "public_name": "Jie Wang", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}]}}, {"index": 10, "date": "2021-07-29", "day_start": "2021-07-29T04:00:00+00:00", "day_end": "2021-07-30T03:59:00+00:00", "rooms": {"Green": [{"id": 9765, "guid": "7c0be19d-b949-5a1e-a247-0e39c96274ac", "logo": "/media/juliacon2021/submissions/UKASBZ/SmartTensorsNew_F3yKYby.png", "date": "2021-07-29T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9765-smarttensors-unsupervised-machine-learning", "url": "https://pretalx.com/juliacon2021/talk/UKASBZ/", "title": "SmartTensors: Unsupervised Machine Learning", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Demonstrate SmartTensors (http://tensors.lanl.gov; https://github.com/SmartTensors): a toolbox for unsupervised machine learning based on matrix/tensor factorization constrained by penalties enforcing robustness and interpretability (e.g., nonnegativity; physics and mathematical constraints; etc.). SmartTensors has been applied to analyze diverse datasets related to a wide range of problems: from COVID-19 to wildfires and climate.", "description": "The world\u2019s most valuable resource is no longer oil. It is data. SmartTensors (http://tensors.lanl.gov; https://github.com/SmartTensors) is a toolbox for unsupervised machine learning based on matrix/tensor factorization constrained by penalties enforcing robustness and interpretability (e.g., nonnegativity; physics and mathematical constraints; etc.). SmartTensors has been applied to analyze diverse datasets related to a wide range of problems: from COVID-19 to wildfires and climate. The workshop will demonstrate how SmartTensors can be easily applied to these and other application areas. The workshop will include hands-on real-time demonstrations of already existing case studies. The workshop will be designed to be suitable and useful for anyone regardless of their machine learning experience by providing materials at introduction, intermediate and expert levels.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10383, "code": "PMRGDL", "public_name": "Velimir Vesselinov", "biography": "My expertise is in applied mathematics, computer science and engineering. My research is in the general area of data analytics, model diagnostics and machine learning. I am the inventor and lead developer of a series of novel theoretical methods and computational related to machine learning, data analytics, model diagnostics, and data inference tools. I am also a co-inventor of LANL-patented machine-leaning methodology. Over the years, I have been the principal investigator of several projects for machine learning, model development, model analyses, uncertainty quantification and decision support", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9536, "guid": "a3d5f9e6-020b-5093-a1d2-e037d67f7962", "logo": "", "date": "2021-07-29T13:00:00+00:00", "start": "13:00", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9536-finding-an-effective-strategy-for-automl-pipeline-optimization", "url": "https://pretalx.com/juliacon2021/talk/FHGWBQ/", "title": "Finding an Effective Strategy for AutoML Pipeline Optimization", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "One of the main problems in AutoML implementation is finding the best strategy to search the most optimal pipeline in prediction or classification tasks. This problem is commonly known as CASH (Combined Algorithm Selection and Hyperparameter Optimization). This talk will show competitive results with significantly shorter computation time by just focusing the search in the model selection and structure of the pipeline without the need of hyperparameter optimization.", "description": "The CASH problem can be decomposed into three major components:\r\n- searching the optimal __m__ model with n(m) search space\r\n- searching the optimal order of __p__ preprocessing elements with n(p) search space\r\n- searching the optimal __h__ hyperparameters with n(h) search space \r\n\r\nThe most popular approaches involve simultaneous search of these three components with time complexity of n(p) x n(m) x n(h). An alternative method is to perform the search sequentially starting with __m__ using surrogates __p__ and __h__ followed by searching for __p__ using optimal __m__ and surrogate __h__, and finally searching for __h__ using optimal __p__ and __m__ found. This alternative technique only involves n(p) + n(m) + n(h) search space which is significantly smaller than simultaneously searching __p__, __m__, and __h__. We find in our experiments using the [AutoMLPipeline](https://github.com/IBM/AutoMLPipeline.jl) package, that in many cases, it is sufficient to just search for __m__ and __p__ to achieve competitive performance with those of other optimal algorithms that searches all three components simultaneously.\r\n\r\nRelevant Julia Packages used in the talk:\r\n- [AutoMLPipeline.jl](https://github.com/IBM/AutoMLPipeline.jl)\r\n- [AMLPipelineBase.jl](https://github.com/IBM/AMLPipelineBase.jl)\r\n- [Lale.jl](https://github.com/IBM/Lale.jl)\r\n- [Hyperopt.jl](https://github.com/baggepinnen/Hyperopt.jl)", "recording_license": "", "do_not_record": false, "persons": [{"id": 1072, "code": "3EKCYY", "public_name": "Paulito Palmes, PhD", "biography": "I am a research scientist at the IBM Research working on the following areas: AutoML, AutoAI, RL/ML Optimization, and Decision Optimization.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9577, "guid": "17ab8a9f-9c1f-5c15-b60c-71db8cdc8ca1", "logo": "/media/juliacon2021/submissions/X9RATL/MLJC_JuliaCon_7OI5NDz.png", "date": "2021-07-29T13:30:00+00:00", "start": "13:30", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9577-physics-informed-ml-simulator-for-wildfire-propagation", "url": "https://pretalx.com/juliacon2021/talk/X9RATL/", "title": "Physics-Informed ML Simulator for Wildfire Propagation", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "The aim of this work is to evaluate the feasibility of re-implementing some key parts of the widely used Weather Research and Forecasting WRF-SFIRE simulator by replacing its core differential equations numerical solvers with state-of-the-art physics-informed machine learning techniques to solve ODEs and PDEs implemented in Julia, in order to transform it into a real-time simulator for wildfire spread prediction.", "description": "The study we carried out has the goal to investigate the applicability of the recently developed field of Scientific Machine Learning on climate, wildfire in particular, models. We have outlined some results that tell us that many improvements are needed in order to transform this into a validated product, but also show the big potential of our approach. We need to add further refinements to the implementation in order to carry out a precise time comparison between our approach and the standard numerical solvers, but the results obtained thus far show promising evidence.\r\nThe encouraging outcome inspires us to continue our work by improving the architectures and possibly employ them in different fields of research.\r\nWe hope that this line of research will be a small step towards a more effective cohesiveness between Machine Learning and Physical Models in Climate Sciences, and thus further explored by other researchers.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10175, "code": "PZLRAZ", "public_name": "Francesco Calisto", "biography": "I am in the second year of the Bachelor Degree in Physics at the University of Turin. I am mainly interested in the theoretical and mathematical aspects of physics. I also conduct research in machine learning, with a particular interest towards the connection between machine learning and physics. Recently I have worked in the field of Scientific Machine Learning using Julia libraries, such as NeuralPDE.jl.", "answers": []}, {"id": 10176, "code": "M938SQ", "public_name": "Simone Azeglio", "biography": null, "answers": []}, {"id": 10177, "code": "NGFW3E", "public_name": "Valerio Pagliarino", "biography": "Valerio is a student in Physics (Bachelor) at the University of Turin. He is interested in electronics, embedded systems, computing and signal processing as tools for investigating physics, such as the technology of  the detectors employed in high energy physics.", "answers": []}, {"id": 10290, "code": "NARPBB", "public_name": "Luca Bottero", "biography": "I am an undergraduate physics student at the University of Turin. I have a strong interest in many aspects of physics, ranging from theoretical physics to HEP and cosmology. Currently I am doing my undergraduate thesis about the study of the properties of the hypertriton nuclei with ALICE's data using machine learning techniques. Meanwhile, I am one of the co-founder of MLJC, a student association that focuses on ML research and know-how sharing. My interest are mainly on scientific ML, NLP & NLU, and the theoretical aspects of ML. One of my strongest motivation is to help accelerating pure sciences using ML approaches. I participated in the ProjectX 2020 competition held by the University of Toronto in the UniTo team.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9790, "guid": "ba407884-62c9-5fd6-aced-cef53c5c227d", "logo": "", "date": "2021-07-29T13:40:00+00:00", "start": "13:40", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9790-bias-audit-and-mitigation-in-julia", "url": "https://pretalx.com/juliacon2021/talk/KNDFHC/", "title": "Bias Audit and Mitigation in Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "This talk introduces Fairness.jl, a toolkit to audit and mitigate bias in ML decision support tools. We shall introduce the problem of fairness in ML systems, its sources, significance and challenges. Then we will demonstrate Fairness.jl structure and workflow.", "description": "Machine Learning is involved in a lot of crucial decision support tools. Use of these tools range from granting parole, shortlisting job applications to accepting credit applications. There have been numerous political and policy developments during the past one year that have pointed out the transparency issues and bias in these ML based decision support tools. Thus it has become crucial for the ML community to think about fairness and bias. Eliminating bias  isn't easy due to the existence of various trade-offs. There exist various performance-fairness, fairness-fairness (various definitions of fairness might not be compatible) trade-offs.\r\n\r\nIn this talk we shall we shall discuss\r\n- Challenges in mitigating bias\r\n- Metrics and fairness algorithms offered by Fairness.jl and the workflow with the package\r\n- How Julia's ecosystem of packages (MLJ, Distributed) helped us in performing a large systematic benchmarking of debiasing algorithms, which helped us understand their [generalization properties](https://arxiv.org/abs/2011.02407).\r\n\r\nRepository: [Fairness.jl](https://github.com/ashryaagr/Fairness.jl)\r\n\r\nDocumentation is available [here](https://ashryaagr.github.io/Fairness.jl/dev/), and introductory blogpost is available [here](https://nextjournal.com/ashryaagr/fairness/)", "recording_license": "", "do_not_record": false, "persons": [{"id": 10394, "code": "RYYMUN", "public_name": "Ashrya Agrawal", "biography": "Senior year CS undergraduate at BITS Pilani - Pilani campus India. As a JSOC '20 student I worked on Fairness.jl . I am interested in fairness in machine learning, causality, counterfactual fairness and reinforcement learning. Lately, I have been exploring Quantum AI and causal RL. Happy to chat at ashryaagr@gmail.com or julia slack :-)\r\nTo know more about me, visit www.ashrya.in", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9645, "guid": "98edeb5b-70e2-5901-9934-c00cab2643c5", "logo": "", "date": "2021-07-29T13:50:00+00:00", "start": "13:50", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9645-data-driven-insight-into-fish-behaviour-for-aquaculture", "url": "https://pretalx.com/juliacon2021/talk/Y9XWLM/", "title": "Data driven insight into fish behaviour for aquaculture", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Aquaculture, or the farmed production of fish and shellfish, has grown rapidly, from supplying just 7% of fish for human consumption in 1974 to more than half in 2016. Sustaining this rapid expansion requires data-driven management of the production process and environmental impacts. This talk presents a machine-learning-based exploration of environmental and fish behaviour datasets collected at three salmon farms in Norway, Scotland, and Canada using AutoML tools in Julia.", "description": "Data generated on modern aquaculture farms extend across a wide variety of forms. In situ sensors sample large numbers of environmental variables such as temperature, current velocity, dissolved oxygen (DO), chlorophyll and salinity. Remotely-sensed environmental data can sample much larger spatial domains and can be at the bay-scale \u2013 from land-based sensors such as CODAR-type HF radar \u2013 or at the global scale from satellite-based monitoring system. Informing on farm operations also requires sampling of animal variables such as size, clustering behaviour, and movement, and this is typically done using underwater technologies such as hydroacoustic technology, video monitoring, and aerial drone imagery. Further, there are large datasets of pertinent variables that are generated by numerical models such as weather or ocean circulation products. These datasets constitute huge data volumes with distinct characteristics. Integrating and extracting information from these disparate data sources (in scalable manner) are key to encapsulating the full dynamics of the farm environment and enabling effective management. \r\n\r\nThis paper presents an analysis of environmental and fish behaviour datasets collected at three salmon farms in Norway, Scotland, and Canada. Information on fish behaviour were collected using hydroacoustic sensors that sampled the vertical distribution of fish in a cage at high spatial and temporal resolution, while a network of environmental sensors characterised local site conditions. We present an analysis of the environmental and hydroacoustic datasets using the Julia open-source packages we developed: data were preprocessed and curated into time-aligned matrix form using TSML (https://github.com/IBM/TSML.jl), and machine learning pipelines were identified and implemented using Lale (https://github.com/IBM/Lale.jl). \r\n\r\nAnalysis enabled a quantitative investigation of the effects of environmental conditions on fish response together with information on drivers of anomalous fish response. Results demonstrated pronounced temporal variations in fish distribution as dictated by factors such as diurnal patterns, dynamics (currents and winds), and oxygen and temperature variations. Diurnal patterns driven by natural changes in light intensity were broadly similar across sites although this trend was ameliorated at the Norwegian site which was located inside the Arctic circle and experience 24 hours of daylight during summer months. Generally, fish occupied a deeper position in the cage during the day and were more tightly clustered; while at night, fish utilised more of the cage volume and were at a higher average position. \r\nAnalysis indicated that temperature was the primary environmental driver at two of the three sites. Temperature in the warmer summer months exhibited pronounced stratification before returning to a well-mixed temperature profile in September and October. During these stratified periods there was a tendency for fish to cluster to the warmer, upper portion of the cage and avoid colder temperatures. On the other hand, in reasonably homogeneous environments where temperature varies little with depth (such as at the Canada site during autumn), temperature did not influence the vertical distribution of salmon.\r\n\r\nVariation in oxygen levels were most pronounced at the Canada site which showed consistently lower values than at other sites. Feature importance analysis indicated that dissolved oxygen values were the most important contributor to fish behaviour and in particular during periods of lower oxygen levels, a pronounced response was noted. Analysis indicated that fish moved towards the surfaces when values drop below 7mgL-1 which is in line with literature which reports reduced appetites and feeding in Atlantic salmon when values drop below this threshold. \r\n\r\nResults presented in this paper indicate pronounced differences between sites and the need to consider these variations for farm management. One could readily use this analysis to quantify the difference between sites, and further to identify the fundamental drivers to these variations. This could be particularly valuable when comparing different farm systems such as inshore and offshore and the associated operational implications.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10282, "code": "98LQ9B", "public_name": "Fearghal O'Donncha", "biography": "Fearghal O\u2019Donncha is a research scientist at IBM Research \u2014 Ireland. His work focuses on applying simulation models, analytics, and machine learning techniques to assist industry operations. This encompasses developing and deploying simulation-based models, integrating sensor data from a variety of IoT platforms, developing AI-based models that extract value from sensor or expert data, and optimizing these tools to a variety of HPC and cloud-based platforms. He is an adjunct faculty member at the National University of Ireland, Galway.", "answers": []}, {"id": 1072, "code": "3EKCYY", "public_name": "Paulito Palmes, PhD", "biography": "I am a research scientist at the IBM Research working on the following areas: AutoML, AutoAI, RL/ML Optimization, and Decision Optimization.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9877, "guid": "7e56a34b-40df-5ab9-bee6-4e947cb1575e", "logo": "", "date": "2021-07-29T14:30:00+00:00", "start": "14:30", "duration": "00:45", "room": "Green", "slug": "juliacon2021-9877-state-of-julia", "url": "https://pretalx.com/juliacon2021/talk/UJUE8P/", "title": "State of Julia", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Placeholder for State of Julia talk.", "description": "Placeholder for State of Julia talk.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1138, "code": "9NNRE7", "public_name": "Stefan Karpinski", "biography": "Julia co-creator & co-founder of [Julia Computing](https://juliacomputing.com).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11701, "guid": "8f21deb3-d552-5ae2-983d-25ba7f6bb8de", "logo": "", "date": "2021-07-29T15:15:00+00:00", "start": "15:15", "duration": "00:45", "room": "Green", "slug": "juliacon2021-11701-keynote-xiaoye-sherry-li-", "url": "https://pretalx.com/juliacon2021/talk/YS9RUZ/", "title": "Keynote (Xiaoye (Sherry) Li)", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Interplay of linear algebra, machine learning, and HPC", "description": "In recent years, we have seen a large body of research using hierarchical\r\nmatrix algebra to construct low complexity linear solvers and preconditioners.\r\nNot only can these fast solvers significantly accelerate the speed of\r\nlarge scale PDE based simulations, but also they can speed up many AI and\r\nmachine learning algorithms which are often matrix-computation-bound.\r\nOn the other hand, statistical and machine learning methods can be used\r\nto help select best solvers or solvers' configurations for specific problems\r\nand computer platforms. In both of these fields, high performance computing\r\nbecomes an indispensable cross-cutting tool for achieving real-time solution\r\nfor big data problems. In this talk, we will show our recent developments\r\nin the intersection of these areas.\r\n\r\n\r\nBIO\r\nSherry Li is a Senior Scientist in the Computational Research Division,\r\nLawrence Berkeley National Laboratory. She has worked on diverse problems\r\nin high performance scientific computations, including parallel computing,\r\nsparse matrix computations, high precision arithmetic, and combinatorial\r\nscientific computing. She is the lead developer of SuperLU, a widely-used\r\nsparse direct solver, and has contributed to the development of several other\r\nmathematical libraries, including ARPREC, LAPACK, PDSLin, STRUMPACK, and XBLAS. She earned Ph.D. in Computer Science from UC Berkeley and B.S. in Computer Science from Tsinghua Univ. in China. She has served on the editorial boards of the SIAM J. Scientific Comput. and ACM Trans. Math. Software, as well as many program committees of the scientific conferences. She is a Fellow of SIAM and a Senior Member of ACM.", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 9627, "guid": "fcef36c1-cb77-5a6d-bba5-23344dfc6a67", "logo": "", "date": "2021-07-29T16:30:00+00:00", "start": "16:30", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9627-invertiblenetworks-jl-memory-efficient-deep-learning-in-julia", "url": "https://pretalx.com/juliacon2021/talk/EVR3HZ/", "title": "InvertibleNetworks.jl - Memory efficient deep learning in Julia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We present InvertibleNetworks.jl, an open-source package for invertible neural networks and normalizing flows using memory-efficient backpropagation. InvertibleNetworks.jl uses manually implement gradients to take advantage of the invertibility of building blocks, which allows for scaling to large-scale problem sizes. We present the architecture and features of the library and demonstrate its application to a variety of problems ranging from loop unrolling to uncertainty quantification.", "description": "Invertible neural networks (INNs) are designed around bijective building blocks that allow the evaluation of (deep) INNs in both directions, which means that inputs into the network (and all internal states) can be uniquely re-computed from the output. INNs were popularized in the context of normalizing flows as an alternative approach to generative adversarial networks (GANs) and variational auto-encoders (VAEs), but their property of invertibility is also appealing for discriminative models, as INNs allow memory-efficient backpropagation during training. As hidden states can be recomputed for INNs from the output, it is in principle not required to save the state during forward evaluation, thus leading to a significantly lower memory imprint than conventional neural networks. However, existing backpropagation libraries that are used in TensorFlow or PyTorch do not support the concept of invertibility and therefore require work arounds to benefit from them. For this reason, current frameworks for INNs such as FrEIA or MemCNN use layer-wise AD, in which backpropagation is performed by first re-computing the hidden state of the current layer and then using PyTorch's AD tool (Autograd) to compute the gradients for the respective layer. This approach is computationally not efficient, as it performs an additional forward pass during backpropagation.\r\n\r\nWith InvertibleNetworks.jl, we present an open-source Julia framework (MIT license) with manually implemented gradients, in which we take advantage of the invertibility of building blocks. For each invertible layer, we provide a backpropagation layer that (re-)computes the hidden state and weight updates all at once, thus not requiring an extra (layer-wise) forward evaluation. In addition to gradients, InvertibleNetworks.jl also provides Jacobians for each layer (i.e. forward differentiation), or more precisely, matrix-free implementations of Jacobian-vector products, as well as log-determinants for normalizing flows. While backpropagation and Jacobians are implemented manually, InvertibleNetworks.jl integrates seamlessly with ChainRules.jl, so users do not need to manually define backward passes for implemented networks. Additionally, InvertibleNetworks.jl is compatible with Flux.jl, so that users can create networks that consist of a mix of invertible and non-invertible Flux layers. In this talk, we present the architecture and features of InvertibleNetworks.jl, which includes implementations of common invertible layers from the literature, and show its application to a range of scenarios including loop-unrolled imaging, uncertainty quantification with normalizing flows and large-scale image segmentation.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10165, "code": "LSJRYM", "public_name": "Philipp A. Witte", "biography": "Philipp A. Witte is a researcher at Microsoft Research for Industry (RFI), a new initiative within Microsoft for developing innovative research solutions for industry-related problems ranging from AI/ML to edge- and high-performance computing. Prior to Microsoft, Philipp received his B.Sc. and M.Sc. in Geophysics from the University of Hamburg and his Ph.D. in Computational Science and Engineering from the Georgia Institute of Technology. During his Ph.D., Philipp worked with Professor Felix J. Herrmann at the Seismic Laboratory for Imaging and Modeling (SLIM) on computational aspects of least squares seismic imaging and full-waveform inversion. He has authored and contributed to multiple open-source software packages, including Devito, the Julia Devito Inversion framework (JUDI) and InvertibleNetworks.jl, a Julia framework for deep learning with normalizing flows.", "answers": []}, {"id": 10249, "code": "UUDHSP", "public_name": "Mathias Louboutin", "biography": "Post Docotoral Fellow at Georgia Institute of technology. \r\nMy main research focuses on high-performance computing for large-scale PDE constraints optimization (medical imaging, seismic imaging) on standard clusters and in the Cloud. In particular I work intensively on open source solutions in Julia and Python and high-level abstractions for high-performance computing such as Devito (Finite difference DSL) or JUDI.jl (linear algebra abstraction for PDE constraint optimization).\r\nMy secondary research project is aimed at computational and algorithmic solutions for large-scale machine learning.", "answers": []}, {"id": 10250, "code": "8HWGRT", "public_name": "Ali Siahkoohi", "biography": "I am pursuing a Ph.D. in Computational Science and Engineering at Georgia Institute of Technology. Currently, my research is mainly focused on applications of deep learning in inverse problems and uncertainty quantification.", "answers": []}, {"id": 10251, "code": "8LWHMV", "public_name": "Felix J. Herrmann", "biography": "Felix J. Herrmann graduated from Delft University of Technology in 1992 and received his Ph.D. in engineering physics from that same institution in 1997. After research positions at Stanford University and the Massachusetts Institute of Technology, he became back in 2002 faculty at the University of British Columbia. In 2017, he joined the Georgia Institute of technology where he is now a Georgia research Alliance Scholar Chair in Energy, cross-appointed between the Schools of Earth & Atmospheric Sciences, Computational Science & Engineering, and Electrical & Computer Engineering. His cross-disciplinary research program spans several areas of computational imaging including seismic, and more recently, medical imaging. Dr. Herrmann is widely known for tackling challenging problems in the imaging sciences by adapting techniques from randomized linear algebra, PDE-constrained and convex optimization, high-performance computing, machine learning, and uncertainty quantification. Over his career, he has been responsible for several cost-saving innovations in industrial time-lapse seismic data acquisition and wave-equation based imaging. In 2019, he toured the world presenting the SEG Distinguished Lecture \"Sometimes it pays to be cheap \u2013 Compressive time-lapse seismic data acquisition\". In 2020, he was the recipient of the SEG Reginald Fessenden Award for his contributions to seismic data acquisition with compressive sensing. At Georgia Tech, he leads the Seismic Laboratory for Imaging and modeling and he is co-founder/director of the Center for Machine Learning for Seismic (ML4Seismic), designed to foster industrial research partnerships to drive innovations in artificial-intelligence assisted seismic imaging, interpretation, analysis, and time-lapse monitoring.", "answers": []}, {"id": 10252, "code": "EXN8D7", "public_name": "Gabrio Rizzuti", "biography": "Postdoc at Utrecht University", "answers": []}, {"id": 10270, "code": "UHXALN", "public_name": "Bas Peters", "biography": "Bas Peters is visiting assistant professor in the mathematics department at Emory University. Previously, Bas worked for Computational Geosciences Inc as a research scientist, and received his PhD degree from the University of British Columbia in 2019. His main research interests are constrained optimization; design, optimization, and regularization of deep neural networks, geoscientific and geospatial applications, inverse problems, reinforcement learning, image processing, and numerical linear algebra.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9727, "guid": "ae6cbb80-bf2c-5719-8ff6-2ece1439a63a", "logo": "", "date": "2021-07-29T17:00:00+00:00", "start": "17:00", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9727-composable-bayesian-modeling-with-soss-jl", "url": "https://pretalx.com/juliacon2021/talk/SLHLHX/", "title": "Composable Bayesian Modeling with Soss.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Soss is a probabilistic programming language (PPL) with first-class composable models. Through dynamic code generation, Soss can achieve speedup of several orders of magnitude in some models, for example using symbolic simplification of the log-density.\r\n\r\nIn this talk, we'll discuss the goals and design choices in Soss that distinguish it from other PPLs, followed by an overview of upcoming work.", "description": "# First-Class, Composable Models\r\nSoss models can be used and composed similarly to working with functions. This allows models to be built up from smaller, reusable components. In some cases, these can be developed and tested independently.\r\n\r\n# Dynamic Code Generation\r\nSoss uses runtime code generation for efficient inference primitives. These are specialized for model and input types. New primitives can easily use arbitrary data structures; the system is very flexible. Models are fully generative and determine joint distributions. In particular, models have `rand` and `logdensity` methods like any other measure. \r\n\r\n# Model Transformations\r\nInternally, models are represented as a directed graph with an AST (a Julia `Expr`) at each node. This makes it easy to transform one model into another based on its dependencies or AST structures. We can compute Markov blankets or reparameterizations, or change a model to output the latent conditional distributions used along the way.\r\n\r\n# MeasureTheory.jl\r\nSoss uses MeasureTheory.jl and allows falling back to Distributions.jl when needed, so it inherits the benefits of MeasureTheory. For example, fewer type constraints on constructors means Soss can evaluate a log-density symbolically. Coupled with codegen, this enables generation of highly optimized code.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1004, "code": "A7PDM3", "public_name": "Chad Scherrer", "biography": "Hi, I'm Chad. My interests range from applied problems through \"technology transfer\", to applied research. I've been involved in probabilistic programming for the last ten years, and have led design of a few prototype systems. Since 2015 I've been very interested in Julia, resulting in Soss.jl and MeasureTheory.jl, as well as some utility packages around these.\r\n\r\nMost recently I've founded Informative Prior, where I'm available for contract consulting work involving teaching, development, or application of probabilistic modeling software.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9801, "guid": "c270fc5a-f757-5083-a3dc-0be3efbb2495", "logo": "", "date": "2021-07-29T17:10:00+00:00", "start": "17:10", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9801-chaotic-time-series-predictions-with-reservoircomputing-jl", "url": "https://pretalx.com/juliacon2021/talk/NDQTSP/", "title": "Chaotic time series predictions with ReservoirComputing.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Are you interested in how machine learning can be used to predict the behavior of the \"unpredictable\" chaotic systems? This talk will be a deep dive into ReservoirComputing.jl (https://github.com/SciML/ReservoirComputing.jl), a package in the SciML ecosystem focused on a class of stabilized machine learning specialized for handling learning these difficult dynamical systems.", "description": "Chaoticity is by definition hard to predict or to reproduce using forecasting models. With the advent of Deep Learning (DL) a lot of effort has been dedicated to this problem, with the default approaches being represented by Recurrent Neural Networks (RNNs) and Long Short Term Memory networks (LSTMs). More recently a new family of models has proved more effective in tackling chaotic systems, namely Reservoir Computing (RC) models. Given the relative infancy of the RC paradigm it is not simple to find an implementation of such models, let alone a full library. With ReservorComputing.jl we want to propose a Julia package that allows the user to quickly get started with a fast growing range of RC models, ranging from the standard Echo State Networks (ESNs) to the more exotic Reservoir Computing with Cellular Automata (RECA). In this talk a brief introduction to the concept of RC will be given and afterwards the capabilities of ReservoirComputing.jl will be illustrated using interactive examples.\r\n\r\nReservoir Computing models work by expanding the input data into a higher dimensional space, called reservoir. After this expansion the resulting states are collected and the model is trained against the desired input as a linear regression problem. This approach allows for fast training times, and solves several problems of Neural Networks training, like the vanishing gradient. Not only are the models in the RC family faster and safer to train, but, as mentioned before, it has been shown that they are also better in the prediction and reproduction of chaotic systems. RC models are mainly composed of three sections: an input to reservoir coupler, the reservoir, and a reservoir to output coupler. The last section is the result of the training process, and is dependent on the training method that one chooses to utilize. It is easy to see that using different constructions for these elements is possible to obtain different results in the task at hand. To properly explore the RC models a quick way to access these layers is needed in their implementation. \r\n\r\nAt a high level, the implementation of ReservoirComputing.jl gives the user the appropriate tools needed for a quick setup of the desired model, allowing an exploration of these family of models for the prediction of a given time series. Otherwise if one chooses to delve more deeply into the customization of the model, the implementation of ReservoirComputing.jl follows a modularity designed to leave users with the freedom to fully customize the system they intend to train and use for predictions. This not only helps with possible recombinations of layers already implemented in the library, but allows for expansions with the aid of external libraries or custom code. Leveraging the great package ecosystem of Julia the user could decide to train the RC system using not yet implemented regression approaches with an external package. At the same time it is possible to use a reservoir matrix construction not present in the library, either by custom construction, or again by using other packages, like LightGraphs.jl. \r\n\r\nAfter the brief introduction of the RC paradigm the talk intends to illustrate the concepts defined above using concrete examples. It will be shown both the ease of use of the package and some of the possible variations included that can be explored. Finally a demonstration of possible customizations will be illustrated, both by custom defined layers and by leveraging other libraries of the Julia ecosystem.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10403, "code": "NGLZHC", "public_name": "Francesco Martinuzzi", "biography": "I am a PhD student enrolled at the University of Leipzig working with the Remote Sensing Center for Earth System Research and funded by the Center for Scalable Data Analytics and Artificial Intelligence. I am interested in data-driven exploration of extreme events and their consequences. At the moment my focus is mainly in Reservoir Computing approaches.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9861, "guid": "1facc955-725d-51bc-82a7-c1b9694a02a1", "logo": "", "date": "2021-07-29T17:20:00+00:00", "start": "17:20", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9861-airborne-magnetic-navigation-enhanced-with-neural-networks", "url": "https://pretalx.com/juliacon2021/talk/NYNJMJ/", "title": "Airborne Magnetic Navigation Enhanced with Neural Networks", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Using the earth\u2019s magnetic field for navigation of aircraft has shown promise as a viable alternative to GPS. An airborne magnetic navigation system collects magnetic field data and uses predetermined magnetic maps to estimate location. A challenge arises when the measured data contains magnetic signals from both the (desired) earth field and (undesired) aircraft field. This work explores several approaches for obtaining a clean magnetic signal that is usable for navigation.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10451, "code": "VAWVFX", "public_name": "Albert Gnadt", "biography": "PhD candidate at MIT AeroAstro", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9914, "guid": "c4ef744a-d59e-5f41-893a-bb0bdcfb48db", "logo": "", "date": "2021-07-29T17:40:00+00:00", "start": "17:40", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9914-generative-models-with-latent-differential-equations-in-julia", "url": "https://pretalx.com/juliacon2021/talk/QEANKW/", "title": "Generative Models with Latent Differential Equations in Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Scientific Machine Learning (SciML) is the branch of scientific computing that combines domain-aware and interpretable models with powerful machine learning techniques. The Julia language has been a key enabler of this burgeoning field, thanks to its unique SciML ecosystem. In this talk, we will present a contribution in this direction: an easy and flexible implementation of generative latent differential equations models.", "description": "Scientific Machine Learning (SciML) is a very promising and exciting field that has been emerging in the past few years, with particular strength within the Julia community given the thriving SciML ecosystem. It consists of a growing set of diverse tools focused on combining traditional scientific modeling with novel machine learning (ML) techniques. The former is usually based on the long-established field of differential equations (DE) models, while the latter,  though more recent, provides powerful general-purpose tools, and has demonstrated remarkable achievements in many applications.\r\n\r\nBoth approaches, of course, have their advantages and drawbacks: traditional modeling is far from trivial, since building an adequate model for a given problem usually requires educated guesses and approximations based on a deep understanding of the system being studied. Often in practice, it is only possible to build partial models and have access only to an incomplete set of the considered variables, sometimes even in a different unknown coordinate system. On the other hand, using orthodox ML models on poor-quality and scarce scientific data can be disadvantageous because of the lack of interpretability of these models, and the dependence on large amounts of training data to achieve good generalization. \r\n\r\nSciML is a bridge between these two worlds, taking the best from each. A perfect example of such hybrid solutions is the case of Universal Differential Equations [1], where prior scientific insight is used to build some parts of a DE model, filling the unknown terms with neural networks (NN). They jointly optimize the DE parameters and NN weights using automatic differentiation and sensitivity analysis algorithms. This powerful approach was developed by members of the Julia community and is readily available to use in the DiffEqFlux.jl package. However, this method only works when one has direct measurements of the state variables of the DEs models, which is not always the case.\r\n\r\nThere exists a class of approaches that tackles this issue by constructing latent DE models, where other NN layers learn transformations from the input space to a latent DE space, usually with lower dimensionality. Some examples of this approach are LatentODEs [2,3] and GOKU-nets [4]. In a broad view, these models consist of a Variational Autoencoder structure with DEs inside. Their decoders contain the DEs, whose initial conditions (and in some cases, parameters) are sampled from distributions learned by the encoders. In the case of LatentODEs, NNs are used to approximate the latent ODE, while in the case of GOKU-nets, one can use prior knowledge to provide some ODE model for the latent dynamics.\r\n \r\nCurrently, Flux.jl and the SciML ecosystem have all the functionalities to build these latent DE models, but this process can be time-consuming and possibly has a steep learning curve for people without a background in machine learning. Our goal is to provide a package that makes latent differential equation models readily accessible with high flexibility in architecture and problem definition.\r\n\r\nIn this presentation, we will introduce the basic background and concepts behind latent differential equation models, in particular, presenting the GOKU-net architecture. We will then show our implementation structure via a simple example: given videos of pendulums of different lengths, learn to reconstruct them by passing through their latent DE representation. We anticipate that our presentation shall be a user-friendly introduction to latent differential equations models for the Julia community. \r\n\r\n\r\nWork done in collaboration with:\r\n\r\nJean-Christophe Gagnon-Audet\u00b9*  \r\nMahta Ramezanian\u00b9  \r\nVikram Voleti\u00b9  \r\nIrina Rish\u00b9 \r\nPranav Mahajan\u00b2 \r\nGuillermo Cecchi\u00b3  \r\nSilvina Ponce Dawson\u2074  \r\nGuillaume Dumas\u00b9\r\n\r\n*creator of the beautiful diagrams that you will see in the presentation   \r\n\u00b9 Mila & Universit\u00e9 de Montr\u00e9al  \r\n\u00b2 University of Pilani  \r\n\u00b3 IBM Research  \r\n\u2074 CONICET & University of Buenos Aires  \r\n\r\n[1] Rackauckas, C., Ma, Y., Martensen, J., Warner, C., Zubov, K., Supekar, R., ... & Edelman, A. (2020). Universal differential equations for scientific machine learning. arXiv preprint arXiv:2001.04385.\r\n\r\n[2] Chen, R. T., Rubanova, Y., Bettencourt, J., & Duvenaud, D. (2018). Neural ordinary differential equations. arXiv preprint arXiv:1806.07366.\r\n\r\n[3] Rubanova, Y., Chen, R. T., & Duvenaud, D. (2019). Latent odes for irregularly-sampled time series. arXiv preprint arXiv:1907.03907.\r\n\r\n[4] Linial, O., Eytan, D., & Shalit, U. (2020). Generative ODE Modeling with Known Unknowns. arXiv preprint arXiv:2003.10775.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10472, "code": "VLASWP", "public_name": "Germ\u00e1n Abrevaya", "biography": "PhD student in Physics at University of Buenos Aires.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9915, "guid": "969b215b-e2fb-598f-a2f3-7803f4e70031", "logo": "", "date": "2021-07-29T17:50:00+00:00", "start": "17:50", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9915-compositionalnetworks-jl-a-scaling-glass-box-neural-network", "url": "https://pretalx.com/juliacon2021/talk/BSTFEQ/", "title": "CompositionalNetworks.jl: a scaling glass-box neural network", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Interpretable Compositional Networks (ICN), a variant of neural networks, that allows the user to get interpretable results, unlike regular artificial neural networks. An ICN is a glass-box producing functions composition that scale with the size of the input, allowing a learning phase on relatively small spaces.\r\nThis presentation covers the different Julia packages and paradigms involved, a set of use-case, current limitations, future developments, and hopefully possible collaborations.", "description": "The *JuliaConstraints* GitHub organization was born last fall and aims to improve collaborative packages around the theme of Constraint Programming (CP) in Julia. \r\nAs for many fields of optimization, there is often a trade-off between efficiency and the simplicity of the model. **CompositionalNetworks.jl** was designed to smooth that trade-off. One could make a parallel with not having to choose between the speed of C and the simplicity of Python (among others).\r\nAn Interpretable Compositional Networks (ICN) takes any vector (of arbitrary size) as an input and outputs a (non-negative) value that corresponds to a user given metric. For instance, consider an error function network in Constraint Programming, one can choose a Hamming distance metric to evaluate the distance between a configuration of the variables\u2019 values and the closest satisfying values. It provides the minimum number of variables to change to reach a solution. \r\nA usual constraint showing the modeling power of Constraint Programming is the `AllDifferent` constraint which ensures that all the variables take different values. One can model a Sudoku problem with only such constraints. \r\nAn ICN, in its most basic form, is composed of four layers: transformation, arithmetic, aggregation, and composition layers. Weights between the layers are binary, meaning that neurons (operations) are either connected to, or disconnected from each other neuron in adjacent layers. These simple boolean weights allow a straightforward composition of the operations composing an ICN, and provide a result that is interpretable by a human. The user can then, either verify and use the composition directly, or use it as an inspiration for a handmade composition.\r\nAn ICN learning on a small space of 4 variables with domain [1, 2, 3, 4] can extract the following function: \r\n```\r\nicn_all_different(x::AbstractVector) = x |> count_eq_left |> count_positive |> identity\r\n```\r\nwhere `count_eq_left` is the function that counts the number of elements of `x` smaller than `xi` for each `i`, and `count_positive` counts the number of elements `xi>0`. This output is equivalent to the best known handmade error function for the `AllDifferent` constraint. Furthermore, it is fully scalable to any vector length.\r\n \r\nIn CompositionalNetworks.jl, we generate the code of the composed function directly. We can even compile it on the fly due to the meta programming capabilities of Julia. Moreover, we can also export the compositions to human-readable language or other programming languages. \r\nUsers can check and modify the function composed by an ICN to adapt or improve the output to its needs and requirements. Of course, the function can also be used directly.\r\n \r\nDuring this talk, we will cover an out-of-the-box use of CompositionalNetworks.jl along with the different julian and non-julian key aspects to the development of this package. Among others, the use of other julian packages as dependencies such as  the genetic algorithm in Evolutionary.jl to fix the Boolean weights of an ICN, or the generation of compositions in either programming code or mathematical language through Julia efficient meta programming.\r\nThe versatility of the Julia version of ICN mixed with metaprogramming allows a much broader practical use cases for any user of ICN compared to the original C++ version, where modifying the code is a much harder task, and metaprogramming is not possible (and usually not recommended for (pre)compiled languages)\r\n \r\nWhile we provide a basic ICN use-case as error function networks in Constraint Programming, it is straightforward for the user to provide additional operations, or even layers. The type of functions learned and composed is more versatile than our use case. We hope this package can have some use for, but not limited to, the people in the Constraint Programming and the Julia communities.\r\n \r\nAlthough our current applications are mainly within some packages of *JuliaConstraints*, we hope to exchange with the community for other methods to compose functions, apply them to other problems, and improve our understanding of Julia for Interpretable Compositional Networks.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10498, "code": "ZDLC3M", "public_name": "Khalil CHRIT", "biography": "PhD student in the University of \u00c9vora", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11884, "guid": "8ea895a5-9ca8-5ec0-8eee-16ae5ca6dd7e", "logo": "", "date": "2021-07-29T18:00:00+00:00", "start": "18:00", "duration": "01:00", "room": "Green", "slug": "juliacon2021-11884-gathertown-social-break", "url": "https://pretalx.com/juliacon2021/talk/VGHALK/", "title": "GatherTown -- Social break", "subtitle": "", "track": null, "type": "Social hour", "language": "en", "abstract": "Join us on Gather.town for a social hour.\r\n\r\nIt is a virtual location where we will facilitate the poster sessions, social gatherings, and hackathon. You can join the space using the URL: https://gather.town/invite?token=3QYkt8gX.\r\n\r\nYou should have received the password through Eventbrite", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 9780, "guid": "e114c8fc-4cc5-58b2-bff6-d6b8f27d5978", "logo": "", "date": "2021-07-29T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9780-modeling-the-economy-during-the-pandemic", "url": "https://pretalx.com/juliacon2021/talk/BEEHC8/", "title": "Modeling the Economy During the Pandemic", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Macroeconomic modeling during the COVID-19 pandemic, and the switch to a new monetary policy framework, has required rapid adjustments to the DSGE.jl package, made possible by Julia\u2019s flexible typing and efficient matrix computations. We review the new features in DSGE.jl that allow users to model periods of large economic shifts and uncertainty. As an illustration, we also explain how the Federal Reserve Bank of New York solved and estimated a model with these features during the recession.", "description": "In this talk, we will discuss how the Federal Reserve Bank of New York (FRBNY) uses Julia for forecasting. We will focus on how the FRBNY adjusted its dynamic stochastic general equilibrium (DSGE) model for the rapid changes in economic conditions brought about by the COVID-19 pandemic. These changes, which are available publicly through DSGE.jl, include the ability to solve and estimate an economic model with multiple regimes (where regimes differ in the equations that describe the economy). Regime-switching allows the FRBNY DSGE to better capture the economic effects of COVID-19 as well as the switch to the new interest rate policy of average inflation targeting (AIT) announced by the Federal Reserve (Fed) in August 2020. In modeling the impact of this policy change it is assumed that the introduction of the new reaction function is only partially incorporated by the agents in forming expectations. Specifically, these are formed using a convex combination of forecasts obtained under the old and the new policy reaction functions. We write the code generically, so other forms of exogenous regime-switching and imperfect credibility about policy rules are accommodated.\r\n\r\nIn addition, we will demonstrate how this new model is estimated. New features in DSGE.jl, SMC.jl, and ModelConstructors.jl provide a user-friendly API for estimating parameters that change over time. We then show how to estimate this new model in an \u201conline\u201d manner that uses estimation results from an older model trained on data until before the pandemic. This method speeds up estimation times and can be applied even when the model has new COVID-specific parameters.\r\n\r\nThroughout the talk, we will discuss how Julia\u2019s functionalities and runtime performance enabled us to implement and use these changes quickly, which was crucial in forecasting during the rapidly-changing economic conditions over the last year.\r\n\r\nThese advances in DSGE.jl will be useful to any Julia users who are interested in flexibly modeling the economy, particularly in crisis situations as during the recession in 2020. It will also be useful to anyone who regularly conducts Bayesian estimation and is interested in re-using the results from an old estimation to efficiently estimate a new model or with new data.\r\n\r\nDisclaimer: This talk reflects the experience of the authors and does not represent an endorsement by the Federal Reserve Bank of New York or the Federal Reserve System of any particular product or service. The views expressed in this talk are those of the authors and do not necessarily reflect the position of the Federal Reserve Bank of New York or the Federal Reserve System. Any errors or omissions are the responsibility of the authors.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10390, "code": "T9LFAY", "public_name": "Shlok Goyal", "biography": "Shlok is a Senior Research Analyst at the Federal Reserve Bank of New York working on the DSGE team in the Research group. He holds a B.S. in Economics and a B.S. in Statistics and Machine Learning from Carnegie Mellon University. He is interested in using Julia to develop scalable models for macroeconomic forecasting and spatial economics research.", "answers": []}, {"id": 10391, "code": "J9CLTY", "public_name": "Alissa Johnson", "biography": "Alissa is a first year research analyst at the Federal Reserve Bank of New York. She has a B.A. from Grinnell College, double-major in Economics and Computer Science.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9464, "guid": "cf2fde1e-d228-58f9-99d0-b7a5be5ba404", "logo": "", "date": "2021-07-29T19:30:00+00:00", "start": "19:30", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9464-highfrequencycovariance-estimating-covariance-matrices-in-julia", "url": "https://pretalx.com/juliacon2021/talk/NXJYHT/", "title": "HighFrequencyCovariance: Estimating Covariance Matrices in Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "High frequency data typically exhibit asynchronous trading and microstructure noise, which can bias the covariances estimated by standard estimators. While a number of specialised estimators have been developed, they have had limited availability in open source software. HighFrequencyCovariance is the first Julia package which implements specialised estimators for volatility, correlation and covariance using high frequency financial data.", "description": "This talk will briefly cover the challenges of using high frequency data for covariance matrix estimation. Then a number of algorithms will be discussed. Then we will demonstrate the use of the HighFrequencyCovariance package to estimate covariance matrices.\r\n\r\nGeneral content is in this paper: https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3786912\r\nAnd this package: https://github.com/s-baumann/HighFrequencyCovariance.jl", "recording_license": "", "do_not_record": false, "persons": [{"id": 10022, "code": "LTPLMY", "public_name": "Stuart Baumann", "biography": "I hold a PhD Economics from the University of Edinburgh. I work in London as a quantitative research in cash equities. I have done a few open source numerical mathematics packages mainly in fixed point acceleration and shape preserving splines.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9619, "guid": "a1ad3250-5bbf-5d92-a89a-2eedcb47dcc5", "logo": "", "date": "2021-07-29T19:40:00+00:00", "start": "19:40", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9619-using-julia-to-study-economic-inequality-and-taxation", "url": "https://pretalx.com/juliacon2021/talk/THTPGL/", "title": "Using Julia to study economic inequality and taxation", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "In this talk, I illustrate a Julia workflow to study economic inequality and taxation in the United States. My workflow centers around Taxsim.jl which allows to answer a large number of research questions related to the US tax system. First, I import a widely used survey dataset to show how high and low before-tax incomes evolved since 1960. Next, using Taxsim.jl, I impute taxes paid to compare the evolution of after-tax incomes and to measure the redistributive effect of the tax system.", "description": "Many consider economic inequality the biggest social challenge of the 21st century. Indeed, the distribution of disposable incomes, i.e. earned income (wages and salaries) minus income taxes, has become more unequal in recent years and a larger share is captured by the top 1%. Yet, it is a challenge to measure if this development is driven by changes in the distribution of earned income itself or if governmental efforts to redistribute from the rich to the poor have weakened. Accordingly, there are conflicting views among scientists on how to address increasing economic inequality. \r\n\r\nIn this talk, I show how to use Julia to study the evolution of earned income and disposable income in the United States (US). While most researchers in the social sciences use software such as R and STATA for this purpose, my talk demonstrates that Julia is a superb alternative. To illustrate a concrete application, I use a new Julia package, Taxsim.jl, to investigate if the US tax system has become more or less redistributive during the last decades; income taxes paid are not reported in survey datasets and Taxsim.jl allows to impute them efficiently by uploading data from the Julia workspace to the tax calculator of the National Bureau of Economic Research (NBER). The calculator then computes a number of tax variables (income taxes, tax credits, etc.) and Taxsim.jl downloads them back into Julia.\r\n\r\nMy talk has three elements. First, I give a brief introduction to the NBER tax calculator and describe its input and return variables. Second, I use CSV.jl and DataFrames.jl to import and inspect information on individual incomes contained in publicly available and easily accessible survey datasets (ACS, CPS, Census). Finally, I apply Taxsim.jl to impute income taxes paid via a simple function call and I compare the evolution of before- and after-tax household incomes in the United States since 1960 to measure the redistributive effects of the US tax system. Thus, my talk uses Julia to answer a question which is at the center of public debates on inequality.\r\n\r\nThe Julia workflow I present can be adjusted to suit a large range of applications. Moreover, Taxsim.jl allows to investigate many aspects of the US tax system, such as the role of tax credits, deductions, state tax policies, etc. Hence, beyond the general Julia user community, the particular target group of this talk are researchers in quantitative social sciences (economics, finance, sociology, public policy etc).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10215, "code": "KUUWQU", "public_name": "Johannes Fleck", "biography": "I am a PhD candidate in economics at the European University Institute in Florence, a guest researcher at the University of Oslo and a visiting scholar at the University of Minnesota and the Federal Reserve Bank of Minneapolis.\r\n\r\nMy research interests are macroeconomics, fiscal policy and computational methods. I also work on household finance and machine learning.\r\n\r\nhttps://www.jofleck.com  //  https://twitter.com/_jofleck", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9777, "guid": "6f5e5f0e-81d8-5f93-aa47-118589aa1259", "logo": "", "date": "2021-07-29T19:50:00+00:00", "start": "19:50", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9777-diversity-and-inclusion-in-the-julia-community", "url": "https://pretalx.com/juliacon2021/talk/VM7PSF/", "title": "Diversity and Inclusion in the Julia community", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "It takes the entire community to promote diversity and inclusion. This talk will focus on the current plans underway to promote diversity and inclusion in the Julia Community as well as give an updated look at the state of diversity and inclusion in our community.", "description": "This talk is designed as a primer for the upcoming Diversity and Inclusion BoF (Birds of Feathers, session where community members come together to talk about a specific topic) and will provide all of the diversity data we have access to, in order to pain the full picture about the current state of the community with respect to D&I.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1032, "code": "UNR7XZ", "public_name": "Logan Kilpatrick", "biography": "Logan is the Community Manager for the Julia Language. Get in contact with him here: https://twitter.com/OfficialLoganK", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9766, "guid": "bf7e7e86-9da0-59df-aea1-f9f1d004c740", "logo": "", "date": "2021-07-29T20:00:00+00:00", "start": "20:00", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9766-improving-gender-diversity-in-the-julia-community", "url": "https://pretalx.com/juliacon2021/talk/CLRKFC/", "title": "Improving Gender Diversity in the Julia Community", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "The Julia community aims to be welcoming, diverse, inclusive towards people from all backgrounds. However, the 2020 Julia User & Developer Survey found that only 3% of respondents were women, and reported no respondents who were non-binary or another gender. We, Julia Gender Inclusive, believe this needs to change. In this talk, we will share our ideas and initiatives for improving gender diversity among Julia users and developers, including outreach, community building, and mutual support.", "description": "More information about Julia Gender Inclusive can be found in our announcement post here: https://discourse.julialang.org/t/announcing-julia-gender-inclusive/63702\r\n\r\nInterested community members can sign up here to be added to our Slack workspace, and to join our regular coffee meet-ups: https://forms.gle/tGhCckZqhzvAHoQFA", "recording_license": "", "do_not_record": false, "persons": [{"id": 10385, "code": "E3TDSM", "public_name": "Kim Louisa Auth", "biography": "I am a PhD student in Computational Mechanics at Chalmers University of Technology (Sweden), where I use Julia for doing Finite Element simulations.", "answers": []}, {"id": 10333, "code": "CFLQJP", "public_name": "Xuan (Tan Zhi Xuan)", "biography": "Xuan (Sh-YEN, IPA: \u0255\u0265\u025bn) is a PhD student at MIT in the Computational Cognitive Science and Probabilistic Computing research groups. Their current research focuses on inferring the hidden structure of human motivations by modeling agents as probabilistic programs, in the hope of aligning AI with the higher-order goals, values, and principles that humans strive (in part) to live by.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11164, "guid": "1bf0407a-d42a-56e5-9732-7e4356d72f16", "logo": "", "date": "2021-07-29T20:10:00+00:00", "start": "20:10", "duration": "00:10", "room": "Green", "slug": "juliacon2021-11164-julia-developer-survey-results", "url": "https://pretalx.com/juliacon2021/talk/WDFZWG/", "title": "Julia Developer Survey Results", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Results from the annual Julia Developer survey will be shared.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 2362, "code": "3HK3M7", "public_name": "Viral B. Shah", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11723, "guid": "52abfd68-ad66-50c8-85ea-80f35312f9ef", "logo": "", "date": "2021-07-29T20:20:00+00:00", "start": "20:20", "duration": "00:10", "room": "Green", "slug": "juliacon2021-11723-publish-your-research-code-the-journal-of-open-source-software", "url": "https://pretalx.com/juliacon2021/talk/BRG8Z3/", "title": "Publish your research code: The Journal of Open Source Software", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "JOSS, the Journal of Open Source Software (https://joss.theoj.org/) is a venue for publishing research software packages.  This provides a mechanism for the large time investment required to develop open-source research software to be included within traditional systems for academic credit.\r\n\r\nA JOSS paper is meant to be a short description of the contribution provided by the research software,\r\nwith the main content being in the (archived) software repository itself.", "description": "The peer review process, run by volunteers via GitHub issues, and automated using a bot as much as possible, is designed mainly to review and improve the software itself, including documentation and tests.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1022, "code": "TJJRTG", "public_name": "David P. Sanders", "biography": "Professor of Computational Science at the Universidad Nacional Aut\u00f3noma de M\u00e9xico and visiting professor at MIT.\r\n\r\nInterested in computational science, interval arithmetic, and numeric-symbolic computing.\r\n\r\nAuthor of the JuliaIntervals suite of packages for interval arithmetic, and various tutorials on Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11885, "guid": "4f4ce68b-862e-53b4-a91d-dd7fe1c4251a", "logo": "", "date": "2021-07-29T20:30:00+00:00", "start": "20:30", "duration": "01:00", "room": "Green", "slug": "juliacon2021-11885-gathertown-social-break", "url": "https://pretalx.com/juliacon2021/talk/Q78RW3/", "title": "GatherTown -- Social break", "subtitle": "", "track": null, "type": "Social hour", "language": "en", "abstract": "Join us on Gather.town for a social hour.\r\n\r\nIt is a virtual location where we will facilitate the poster sessions, social gatherings, and hackathon. You can join the space using the URL: https://gather.town/invite?token=3QYkt8gX.\r\n\r\nYou should have received the password through Eventbrite", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}], "Red": [{"id": 9758, "guid": "3e4f187a-863f-56f3-9232-193b830972b8", "logo": "/media/juliacon2021/submissions/88EDGD/SIIP_energy_J9TJT4l.png", "date": "2021-07-29T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9758-scalable-power-system-modeling-and-analaysis", "url": "https://pretalx.com/juliacon2021/talk/88EDGD/", "title": "Scalable Power System Modeling and Analaysis", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "The [Scalable Integrated Infrastructure Planning (SIIP) initiative at NREL](https://www.nrel.gov/analysis/siip.html) has developed a set of high-performance power system simulation capabilities with PowerSystems.jl and PowerSimulations.jl. This talk will demonstrate these capabilities with interactive examples using large realistic datasets, and provide theoretical background for software design choices.", "description": "This talk will provide practical modeling examples and theoretical justification for design choices made in the [Scalable Integrated Infrastructure Planning (SIIP) Initiative](https://www.nrel.gov/analysis/siip.html) at the National Renewable Energy Lab (NREL). We will demonstrate the suite of power systems focused packages \u2013 [SIIP::Power](https://github.com/NREL-SIIP) to perform large-scale power systems modeling and analysis activities. In particular, this talk will highlight:\r\n- [InfrastructureSystems.jl](https://github.com/nrel-siip/infrastructuresystems.jl): for enabling large-scale infrastructure system data set management and access\r\n- [PowerSystems.jl](https://github.com/nrel-siip/powersystems.jl): for specifying quasi-static and dynamic power systems data\r\n- [PowerSimulations.jl](https://github.com/nrel-siip/powersimulations.jl): for enabling optimization based power systems modeling, including production cost modeling and optimal power flow using [PowerModels.jl](https://github.com/lanl-ansi/powermodels.jl)\r\n- [PowerGraphics.jl](https://github.com/nrel-siip/powergraphics.jl): for visualizations of results generated by PowerSystems.jl and PowerSimulations.jl\r\n\r\nExamples will focus on standard modeling practice and highlight opportunities to customize and extend capabilities to meet individual needs.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4151, "code": "KUWVG3", "public_name": "Clayton Barrows", "biography": "Clayton Barrows is a member of the Forecasting and Modeling Group at the National Renewable Energy Laboratory. His research focuses on improving the technical and economic efficiency of energy systems through advanced computation and analysis. At NREL, Clayton leads a team in developing and utilizing energy and infrastructure systems models to gain new insights into pathways towards system modernization. In his research, Clayton draws upon deep experience in applying the tools of network science and optimization to improve the fidelity and scalability of infrastructure systems models. He has applied these techniques to inform policy in studies and applications around the world.", "answers": []}, {"id": 1070, "code": "ZWPRXJ", "public_name": "Dheepak Krishnamurthy", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9646, "guid": "b974e74f-7565-5dd0-9b2d-99653551179c", "logo": "/media/juliacon2021/submissions/F8BBVZ/Power_Models_Distribution_Jjb2tkT.png", "date": "2021-07-29T13:00:00+00:00", "start": "13:00", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9646-unbalanced-power-flow-optimization-with-powermodelsdistribution", "url": "https://pretalx.com/juliacon2021/talk/F8BBVZ/", "title": "Unbalanced Power Flow Optimization with PowerModelsDistribution", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "With the recent advancements in power distribution, e.g., higher penetration of distributed energy resources (DERs), there is a significant demand for optimization tools to solve a variety of complex operational and planning problems, such as optimal dispatch, load shedding, and on-load tap changing. We have developed an optimization-focused approach to phase unbalanced power distribution modeling called PowerModelsDistribution, the design and usage of which we will introduce in this talk.", "description": "PowerModelsDistribution (PMD) is an optimization focused toolkit for power distribution networks modeling, designed using JuMP, which allows for a decoupling of the various problems, power flow formulations, and optimization solvers, for easy exploration and application of a variety of power flow problem types and mathematical formulations related to multi-phase quasi-steady-state optimization. PMD includes several nonlinear AC formulations, linear approximations, and relaxations, all based on state-of-the-art peer-reviewed research, and has native support for both single-period and multi-period (time series) problems, the latter of which is especially relevant due to the larger number of energy storage components appearing in power distribution networks. PMD includes a native Julia OpenDSS data format parser, allowing us to validate the results of AC power flow against OpenDSS using a number of IEEE distribution test feeders, and provides a simple avenue to support existing data models for a broad collection of distribution system components such as photovoltaic systems and energy storage.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10285, "code": "MBYSCD", "public_name": "David M Fobes", "biography": "David Fobes (Ph.D.) is a scientist at Los Alamos National Laboratory in the Information Systems and Modeling group. Prior to joining LANL in 2015, he obtained a PhD in physics from Tulane University. At LANL, he specializes in development and implementation of algorithms for critical infrastructure systems, focusing on optimization of unbalanced multi-phase electric distribution systems, and post-event system evaluation and restoration, and has served on multiple projects for DOE and DHS in these areas. He is the lead developer of PowerModelsDistribution, a critical library for distribution system optimization relied upon by several ongoing projects, and has led and participated in a variety of other software development efforts in the infrastructure modeling space, including serving as Scrum Master and developer for a team focused on modeling the inter-dependencies between electric and natural gas infrastructure systems using co-simulation. He is an author of over 43 peer reviewed journal and conference publications, is a certified Scrum Master, and has received multiple awards for his infrastructure optimization works.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9558, "guid": "7421b161-630c-5c3f-a3a2-4b57007a0233", "logo": "", "date": "2021-07-29T13:10:00+00:00", "start": "13:10", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9558-powermodelsdistributionstateestimation-jl", "url": "https://pretalx.com/juliacon2021/talk/UDTRW3/", "title": "PowerModelsDistributionStateEstimation.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "This talk is about a registered Julia package: PowerModelsDistributionStateEstimation.jl, that allows easy benchmark and design of state estimation models for power distribution systems. The goal is to accelerate the use of this technique in research and real-life settings. State estimation is formulated as a mathematical optimization problem using JuMP.jl and can be solved with off-the-shelf solvers. Different modeling options are featured, and the package is designed to be easily extensible.", "description": "Distribution networks are the final stage of the delivery of power from generation to consumers, and they have traditionally been managed with a fit-and-forget approach. This has been appropriate until recent years, given the predictable behavior and underutilization of these networks. However, several developments are changing the state of affairs, e.g., electric vehicles, PV panels, etc. These devices increase utilization, unpredictability, and the risk of voltage and congestion problems, but also provide a potential source of flexibility and control.\r\nTo understand the impact of these technologies and, potentially, to perform control actions, it is necessary to monitor distribution systems. State estimation (SE) is a monitoring tool that determines the most-likely state of the system given a set of measurements. \r\nIn this talk/poster, a (registered) Julia package is presented, PowerModelsDistributionStateEstimation.jl, which has been developed as a SE design facilitator. The main goal is to provide a flexible tool that allows researchers or other interested users to easily and rapidly design and benchmark SE techniques. This, in turn, has the potential to accelerate the real-life deployment of monitoring and control routines, which can play an important role in the management and operation of future power grids.\r\nThe package is an extension of PowerModelsDistribution.jl (https://github.com/lanl-ansi/PowerModelsDistribution.jl), and it allows to formulate SE as a constrained optimization problem. Usually, SE is not addressed in a strict mathematical optimization sense, but the latter is a more general way to describe the problem, which encapsulates the different methods available in the literature, making benchmarking easier. \r\nThe biggest challenge in the comparison of SE methods is that the solving algorithm is an inherent part of the SE model. This means that changes in the model-defining equations often require changes in the subsequent solving steps, making it very labor-intensive and time-consuming to test even a limited number of modeling options. With this package we break this paradigm, by splitting the modeling and solver layer, which is possible by using JuMP.jl. This allows users to focus on the design of a suitable SE model, letting an off-the-shelf solver, e.g., Ipopt, take care of the solving part. \r\nA potential drawback is that solve times are longer than with a customized algorithm. However, numerical experiments with available solvers show solve times that seem acceptable for experimental and real-life use. If a better performance is required, the package can still be used to quickly find the optimal SE design, which the user can augment with a customized solver at a later stage. \r\nSeveral SE modeling options (e.g., measurement types, power flow equations), are available in the package, which is easy to extend to include more. \r\nThe talk will give a short overview on the concept of SE, to then introduce the package in detail and provide some numerical examples to demonstrate its functionalities.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10156, "code": "ZGSAME", "public_name": "Marta", "biography": "Ph.D. student in Electrical Engineering @KU Leuven and @Energyville, Belgium.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9581, "guid": "97eeb918-6427-50b0-b9a9-ed5894febc03", "logo": "/media/juliacon2021/submissions/DTJYAC/logo_q21EgHE.png", "date": "2021-07-29T13:20:00+00:00", "start": "13:20", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9581-latticeqcd-jl-simulation-of-quantum-gauge-fields", "url": "https://pretalx.com/juliacon2021/talk/DTJYAC/", "title": "LatticeQCD.jl: Simulation of quantum gauge fields", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We present our code (LatticeQCD.jl) for quantum chromo-dynamics (QCD), which describes microscopic world inside of nucleons.\r\nQCD calculation has been implemented by Fortran and C++ on supercomputers or GPU clusters because it requires huge numerical resource, i.g. Monte-Carlo with inversions of matrices with 10^16 x 10^16, and has been succeeded to calculate crucial numbers used in experiments. We implemented a code for QCD in Julia, which achieves compatible speed with a Fortran code.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10178, "code": "XHFFLZ", "public_name": "Akio Tomiya", "biography": "I got PhD in 2015 about physics, particle physics, in Osaka university in Japan. From June 2021, I am a faculty member of International Professional University of Technology in Osaka in Japan. September 2018 - May 2021, a postdoc in Riken Brookhaven research center in the USA. October 2015 - August 2018, a postdoc in central china normal university in China. I am interested in application of machine learning on lattice QCD and physics. I published a book \"Deep Learning and Physics\" from springer.", "answers": []}, {"id": 10181, "code": "8GZWHW", "public_name": "Yuki Nagai", "biography": "Ph.D. Senior Scientist, Japan Atomic Enegy Agency", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9795, "guid": "02a82cb1-a940-531f-9780-25535d560c63", "logo": "", "date": "2021-07-29T13:30:00+00:00", "start": "13:30", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9795-juliaspice-a-composable-ml-accelerated-analog-circuit-simulator", "url": "https://pretalx.com/juliacon2021/talk/QUCAK3/", "title": "JuliaSPICE: A Composable ML Accelerated Analog Circuit Simulator", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Analog circuit simulation is widely used to design and verify analog circuits before they are manufactured.  We present a novel, composable SPICE simulator written entirely in Julia, called JuliaSPICE.", "description": "Modern analog design and verification requires semi-custom and complex flows that are difficult to construct with commercial tools since they are built around rigid command-line batch flows. In comparison, JuliaSPICE is built from the ground up for flexibility with a full Julia API so users can automate complex tasks without using slow disk IO and parsers.  User-defined measurements or checks, written in Julia, can be executed inline with the simulator allowing the designer to dynamically alter the simulation and make on-the-fly measurements  JuliaSPICE is also advancing the latest ML techniques with surrogate models and is funded by a DARPA award with the goal of delivering a 1000x speed-up over traditional approaches. The composability of a Julia solution will be demonstrated from within a Pluto notebook, showing interactive analyses not available in other simulators.  The user will leave with a much better understanding of how Julia can be leveraged in an environment to accelerate their workflows, whether performing analog simulations or other tasks.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10398, "code": "LSR3KJ", "public_name": "Glen Hertz", "biography": "Glen Hertz has spent 15 years as a field applications engineer supporting customers of commercial SPICE simulators.  He joined Julia Computing as the Principal EDA Solutions Architect in 2021 to direct the JuliaSPICE product.", "answers": []}, {"id": 10428, "code": "DFVU3S", "public_name": "Pepijn de Vos", "biography": "Software developer, electrical engineer, IC designer. Author of Apicula FPGA tools and Mosaic IC design software.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9816, "guid": "b02a2717-d789-5738-8ca2-d115d061f1d7", "logo": "/media/juliacon2021/submissions/SB7HWT/OrbitalTrajectories_ROmQOV5.png", "date": "2021-07-29T16:30:00+00:00", "start": "16:30", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9816-designing-spacecraft-trajectories-with-julia", "url": "https://pretalx.com/juliacon2021/talk/SB7HWT/", "title": "Designing Spacecraft Trajectories with Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "This talk briefly presents OrbitalTrajectories.jl, a library providing tools for the analysis of orbital trajectories for space mission design. Making use of the Julia scientific modeling ecosystem to easily define and extend high-fidelity simulations of spacecraft motion, we demonstrate how key techniques including meta-programming, symbolic computation, non-linear optimisation, and automatic differentiation work towards generating, analysing, and stabilising orbital trajectories.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10411, "code": "TPQNLW", "public_name": "Dan Padilha", "biography": "Dan Padilha is a Masters (Aerospace Engineering) student at The University of Tokyo and JAXA Institute of Space & Astronautical Science (ISAS). He has a background in computer science and 6 years of professional experience as a software systems and research engineer in quantum computing (at Rigetti in London), machine learning (at QxBranch in Adelaide), and embedded systems (at NICTA in Sydney). He has been involved in two successful start-up companies, presented at high-performance computing and emerging technologies conferences, run software workshops at over a dozen multinational corporations and universities, and led technical engagements designing novel algorithms and analytics platforms. He is currently a member of the Tsuda Laboratory at ISAS, working on software tools for astrodynamics research.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9931, "guid": "5cbc64f2-ea96-59ba-8926-59d040d52ecb", "logo": "", "date": "2021-07-29T16:40:00+00:00", "start": "16:40", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9931-atomicsets-jl", "url": "https://pretalx.com/juliacon2021/talk/P7KQMT/", "title": "AtomicSets.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We present `AtomicSets.jl`, a Julian framework for structured convex optimization. Algorithms for structured optimization build up a solution from a set of prescribed _atoms_ that represent simple structures. The atoms that participate in the final solution often represent key explanatory components of a model. We use Julia's dispatch system to implement a calculus of convex sets and their functional representations that compiles to efficient machine code.", "description": "_AtomicSets.jl was developed by Michael Friedlander, Zhenan Fan and Mia Kramer at the University of British Columbia._\r\n\r\nWe say a set is convex if, for every pair of points in the set, the line between those points is also contained in the set. This is a generalization of the notion of convex that most of us would have learned in grade school for polygons: the set doesn't have any \"caves\" or \"dents\". We similarly call a function convex if its _epigraph_\u2014the set of points \"above\" the function if it were plotted\u2014is convex. Some common examples of useful convex sets are the _one ball_\u2014the set of all points with 1-norm less than or equal to one, and the _nuclear ball_\u2014the set of all matrices that can be written as an outer product of unit norm vectors. We care about convexity because it guarantees some useful properties for optimization. For exampe: any local minimum of a convex function is also a global minimum. Combinations of these properties can give us efficient algorithms with strong convergence guarantees.\r\n\r\nSuppose we are trying to solve a problem where our answer is a vector, and we expect it to be sparse. In general, computing with exact sparsity is difficult, but let's take a step back. To say that a vector is sparse is to say it should be constructed from a small number of coordinate vectors, each scaled by a nonnegative amount. Let's take the coordinate vectors (and their opposite sign counterparts) to be our _atoms_, and take their convex hull to be our domain. We now have a domain we know to be convex, which also induces the structure we want to see in our solution. The process is similar for low-rank matrices: we assume that they will be constructed from a small number of outer products, so we take the set of unit rank outer products to be our atoms.\r\n\r\nTo generalize over these _atomic sets_, we need more than their common properties; we need a set of common operations. The most basic of these is probably the `gauge` function. Given a set _A_ and a point _x_, the gauge function answers the question \"what is the smallest scale _\u03bb_ such that _x_ is in _\u03bb A_?\" In other words, how much do we have to expand or contract _A_ so that _x_ is only just contained in it? If we pick our set to be the _two ball_, the set of points with Euclidean norm \u2264 1, our gauge function is just the Euclidean norm of the point.\r\n\r\nOther common operations we have on atomic sets are the `expose` and `support` functions. The `expose` function gives us the atom which is most aligned with a given vector, where aligned means maximizing the dot product. Another way to imagine the operation is to take your set and your vector, and then sweep a hyperplane from the origin in the direction of the vector. The last point that the hyperplane touches on its path is the exposed point. The `support` function gives the value of the inner product which produced the exposed point.\r\n\r\nAdditionally, we define a calculus of atomic sets. We can construct atomic sets that are, for example, the Minkowski sum of other sets, a scaling of a set, or a linear map applied on a set. The `expose` operation gives us in some sense an element of the subderivative of the set, and so the usual chain rule applies. By defining this operation recursively for these compound sets, they too can be generic.\r\n\r\nUsing Julia's type system, we build representations for the sets, their atoms, and _faces_ (collections of atoms). By writing functions using these common operations on atomic sets, Julia's dispatch system allows compiling said function for any choice of atomic set (and hence notion of sparsity). Using this construction, we present a dual method for solving min_x \u00bd \u2016 Mx - b \u2016\u00b2 s.t. gauge_A(x) \u2264 \u03c4, which is generic over the choice of set _A_.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10508, "code": "Y37GJU", "public_name": "Mia Kramer", "biography": "Mia is a graduate student at the University of British Columbia, working with Michael Friedlander. She's been interested in computers and programming since being in elementary school, and after finishing her undergraduate in astrophysics at UBC she is very excited to continue learning in (and hopefully contributing to!) the field.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9416, "guid": "380e0782-f387-571d-a23a-d7ce2c000096", "logo": "", "date": "2021-07-29T16:50:00+00:00", "start": "16:50", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9416-julia-admittance-a-toolbox-for-admittance-extraction", "url": "https://pretalx.com/juliacon2021/talk/9MGDGG/", "title": "Julia Admittance: A Toolbox for Admittance Extraction", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "For power grid operators, wind farms and solar farms are black boxes since details of inverter technologies, the main component of renewables, are proprietary info. Then, how can a grid operator assess a power grid's stability? We aim to design a toolbox to address this challenge.  Julia Admittance will process experiment data and come up with admittance models for wind, solar, etc. With admittance models available, eigenvalues of the system will be computed to assess system stability.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 9913, "code": "BYEANF", "public_name": "Lingling Fan", "biography": "Lingling Fan is a full professor at University of South Florida, working on the following research areas: control, dynamics, optimization, and system identification of power systems, power electronics and electric machines. Her recent research interests include mechanism analysis of various dynamics seen in real world (wind farm oscillations, solar PV tripping), computing, and programming with Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9820, "guid": "d0b55325-de81-5d09-ad18-9bc94517c03e", "logo": "", "date": "2021-07-29T17:00:00+00:00", "start": "17:00", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9820-juliafolds-structured-parallelism-for-julia", "url": "https://pretalx.com/juliacon2021/talk/3JQKRW/", "title": "JuliaFolds: Structured parallelism for Julia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "JuliaFolds ecosystem supports structured parallelism for Julia with the packages such as Transducers.jl, Folds.jl, and FLoops.jl. It aims at providing parallelism that is easy-to-use, composable,and extensible. Furthermore, it provides a unified interface to different execution mechanisms such as multi-threading, GPU, and distributed parallelisms.  In this talk, I discuss the composable design principle of the JuliaFolds packages.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 1034, "code": "JQB3XK", "public_name": "Takafumi Arakaki", "biography": "I'm a postdoc at Julia Lab. I'm working on parallelism and compiler.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9825, "guid": "9d54a346-97ed-5d6a-ae99-9ab813d7b08c", "logo": "", "date": "2021-07-29T17:30:00+00:00", "start": "17:30", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9825-teaching-parallelism-to-the-julia-compiler", "url": "https://pretalx.com/juliacon2021/talk/MENJSR/", "title": "Teaching parallelism to the Julia compiler", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "How we currently implement the task parallel API in Julia introduces a couple of obstacles for supporting high-performance parallel programs. In particular, the compiler cannot analyze and optimize the child tasks in the context of the surrounding code. In this talk, I discuss our work on using Tapir (Schardl et al., 2019) to add parallelism to Julia that can be optimized by the compiler.", "description": "This is joint work with Valentin Churavy and TB Schardl.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1034, "code": "JQB3XK", "public_name": "Takafumi Arakaki", "biography": "I'm a postdoc at Julia Lab. I'm working on parallelism and compiler.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9734, "guid": "04dcfae6-27de-546d-93e6-f06ae28690bf", "logo": "", "date": "2021-07-29T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9734-javis-jl-julia-animations-and-visualizations", "url": "https://pretalx.com/juliacon2021/talk/DMTYDS/", "title": "Javis.jl - Julia Animations and Visualizations", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Javis.jl is a general purpose animation library which builds on top of the Luxor.jl graphics library.\r\nIt fills a gap in the Julia ecosystem by providing functionality to create object based animations to communicate complex ideas through simple means. Furthermore, Javis provides the flexibility for  users to extend Javis\u2019s visualizations to a variety of applications. Users are already expressing complicated ideas through winsome domain specific visuals such as planetary motion or brain mapping.", "description": "Javis.jl is a general purpose library for creating Julia-based animations and visualizations across domains. At its core, Javis builds on the high level graphics library Luxor.jl and FFMPEG.jl for animation creation. Individuals who have difficulty effectively communicating ideas or findings statically, can easily use and extend Javis to construct informative, performant, and winsome animated graphics.\r\n\r\nIn this talk the audience will learn the key concepts of Javis by having a look into the abstraction system we use. Additionally they will see basic examples on how objects can interact to create powerful animations. A main point will be the interoperability with existing Julia packages like Luxor.jl and Animations.jl that we use to make the easiest experience for the user who already knows how to use Luxor for static art. Finally, the audience will come away with how Javis is already being used, what the future of Javis is, and how to get involved with the project.\r\n\r\nJavis is inspired by the Python-based animation engine, manim, created by Grant Sanderson (aka 3blue1brown) to visualize math concepts. Although inspired by manim, Javis has the greater goal of providing a general purpose animated graphics library. Historically, the Julia ecosystem has lacked a similar dedicated toolchain for the easy creation of complex animations. Javis is now filling that gap in the ecosystem - and beyond only mathematics.\r\n\r\nAfter reviewing the Julia ecosystem, the most similar packages to Javis are Reel.jl, Makie.jl, and Animations.jl. Javis differentiates itself from these packages by enabling its users to create visuals that may not be generally - or easily - supported by standard plotting packages. Although Javis uses a \"Frame\" concept similar to Reel.jl and Makie.jl, it is not only limited to plots and can create much more complicated visualizations than Animations.jl. Moreover, Javis has extensive documentation and tutorials to illustrate how to easily get started which is at times lacking within these similar packages. Finally, Javis has an active 40+ developer community where beginners can ask questions and participate in the open development path of Javis. Given that Javis users will not be limited by plotting conventions and having guidance in the form of high-quality tutorials and extensive documentation, the novelty and accessibility of Javis in the Julia space is high.\r\n\r\nAlready, Javis has seen steady adoption by users. For example, Javis has been used in secondary school settings to teach on topics such as physics and earth sciences. Increasingly, Javis is also being used for advanced visualizations. Further applications of Javis are in domain specific applications such as visualizing fourier series for signal processing use cases and mapping activity across the brain to view how the brain behaves under stress.\r\n\r\nDue to the extensible nature of Javis, Javis is poised to leverage the existing Julia ecosystem for further animations that users can take advantage of using. This integrative tooling comes as a result of a very open definition of how Javis defines an animation. This tooling enables a user to hook into packages, such as Animations.jl or Pluto.jl, to provide additional capabilities for fine-grained controls of animations, as in the case of Animations.jl, or reproducible development environments per Pluto.jl.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9292, "code": "WNALCB", "public_name": "Jacob Zelko", "biography": "My Name Is Jacob S. Zelko \u2013 Pleasure To Meet You!\r\n\r\nI am a graduate of Georgia Institute of Technology with a BS in biomedical engineering. While pursuing my BS, I worked as a data information specialist and biomedical informaticist in the Department of Biomedical Informatics at Emory University doing research in the areas of computational psychiatry and worked with The Center for Discovery as an engineering consultant to aid in caring for their juvenile neurocognitively diverse population. Currently, I work as a Health Data Analytics and Informatics Researcher at Georgia Tech Research Institute and as a Consultant with the Centers for Disease Control.", "answers": []}, {"id": 10366, "code": "9ZGBBL", "public_name": "Ole Kr\u00f6ger", "biography": "I'm a master student in computer science in Heidelberg, Germany. I like to teach and blog about programming especially about Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9582, "guid": "b10300dc-cef6-5b88-bdfe-668b349b549b", "logo": "", "date": "2021-07-29T19:30:00+00:00", "start": "19:30", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9582-julia-and-deploying-complex-graphical-applications-for-laypeople", "url": "https://pretalx.com/juliacon2021/talk/NVLQT7/", "title": "Julia and deploying complex graphical applications for laypeople", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Applications written in Julia targeted at a nonprofessional audience are still uncommon, even though libraries for designing such applications have existed for years. For software to be easy to use by laypeople, a simple installation process and an intuitive GUI are essential. We have been developing and deploying such an application for over three years. This talk will focus on our experiences during that time, how the situation has improved since Julia 0.6, and what it looks like today.", "description": "Julia shows to be promising as a general-purpose language, yet uses for software targeted at non-professional users still appear to be scarce. We are the developers of one such tool: [Ahorn](https://github.com/CelestialCartographers/Ahorn) is a graphical level editor for the video game Celeste that allows a user to create their own levels for the game. Ahorn is written entirely in Julia. As the tool itself is likely to be of little interest to the Julia community, this talk will not focus on the tool, but on our experiences developing and deploying it.\r\nOwing to the nature of the tool, its audience consists in large parts of people who want to dip their toes in game and level design for the first time. Many of these people are young, some as young as 13 years old. This talk will be about what it is like to develop a graphical Julia application that has to be able to be installed by a child on a 10-year-old laptop. What did the Julia ecosystem offer for GUI design in early 2018 when the project started? How well did Julia\u2019s package installation system handle the large variety in hardware and operating systems we have encountered? How has the situation improved since then? What unique features does Julia offer that made us choose it, and how did using the language pay off years later? In our talk, we would like to answer these questions by sharing on our own experiences, and provide some ideas for what can be improved if the Julia community wants the language to become more widely adopted for the development of non-scientific user-facing applications.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10179, "code": "JHSX7T", "public_name": "Vexatos", "biography": "Developer of [Ahorn](https://github.com/CelestialCartographers/Ahorn) and similar tools. Using Julia professionally since 2017.", "answers": []}, {"id": 10180, "code": "HJG83F", "public_name": "Cruor", "biography": "Developer of [Ahorn](https://github.com/CelestialCartographers/Ahorn) and similar tools.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9730, "guid": "cfa9ad47-42d0-5001-b98e-2e03845efd1a", "logo": "/media/juliacon2021/submissions/CPDWCV/c1886afe-3907-11e7-8027-213d36bc011a_BNJDdXb.png", "date": "2021-07-29T19:40:00+00:00", "start": "19:40", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9730-pgfplotsx-jl-plotting-with-latex-directly-from-julia", "url": "https://pretalx.com/juliacon2021/talk/CPDWCV/", "title": "PGFPlotsX.jl - Plotting with LaTeX, directly from Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "PGFPlots is a plotting package for LaTeX that produces plots with vector graphics and interfaces with the math typesetting of LaTeX. `PGFPlotsX.jl` is a Julia plotting package that provides an interface to PGFPlots by transpiling Julia objects to LaTeX code. Furthermore, the figures generated by `PGFPlotsX.jl` are directly rendered in IPython notebooks, Pluto and VSCode which allows for rapid plot prototyping. It also serves as one of the backends to the popular `Plots.jl` package.", "description": "Some people like to almost endlessly tinker with their plots and the LaTeX plot package PGFPlots is one of the plotting packages that allow for such tinkering. It comes with a 600-page manual describing an almost endless number of dials and levers that can be turned and pulled to finally get the perfect plot. One of its drawbacks is that coding in LaTeX can be argued to be quite unpleasant. The error messages are often not good and there is very little linting support. `PGFPlots.jl` is a Julia package that brings all the good things about PGFPlots into Julia while remedying the bad part by allowing one to use Julia for the coding part.\r\n\r\nOne of the big design goals of the package was to facilitate \"translatability\" of LaTeX PGFPlots code into Julia over, for example, terseness. This was based on the observation that many plots are created by \"stitching together\" parts of different examples that can be found scattered over the internet. Allowing LaTeX PGFPlots code to easily be brought into Julia would open up a big amount of example code to be used.  It also means that the official PGFPlots manual largely acts as a manual for the package.\r\n\r\nEven though the API is made to resemble the one in LaTeX it is of a much higher level than the LaTeX counterpart. Many Julia objects can be directly used as inputs to the plot and will \"convert\" in a predictable way. Some examples of plottable Julia objects include data frames (from `DataFrames.jl)`, contours (from `Contours.jl`), colors (from `Colors.jl`), error bars (from `Measurements.jl`).\r\n\r\nFor people that desire a terser coding style while still having easy access to the PGFPlots renderer, it is possible to use `PGFPlotsX.jl` as a backend to `Plots.jl`. \r\n\r\nIn this talk, I will discuss how the design goals outlined above were achieved and give some illustrative examples and use cases. Attendees should get an overview of the package and be able to determine if using the package for their daily plotting is suitable.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1090, "code": "AS3MKE", "public_name": "Kristoffer Carlsson", "biography": "I'm a contributor to the Julia language and many packages.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11678, "guid": "ae5a7884-97ae-52d4-a081-99de4c6dc77d", "logo": "", "date": "2021-07-29T19:50:00+00:00", "start": "19:50", "duration": "00:10", "room": "Red", "slug": "juliacon2021-11678-towards-an-increased-code-creativity-harmony-in-javis", "url": "https://pretalx.com/juliacon2021/talk/XDX3SQ/", "title": "Towards an increased code-creativity harmony in Javis", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Javis.jl is a graphical animation/visualization package for the Julia Language which is inspired by Grant Sanderson's (aka, famous Math educator and YouTuber, 3blue1brown) Python based animation engine, Manim. This talk is about the work I have been doing this summer to make Javis more friendly and feature rich for creators", "description": "This summer I have been working towards:\r\n\r\nBringing a more organized experience for creators and developers via layers.\r\nCurrently a WIP, this feature aims to add a layer based approach towards the Javis animation canvas, where different layers are stacked on top of each other. This is beneficial in cases where a user wants to modify a particular layer, without affecting objects present in other layers. It helps maintain virtual boundaries between different objects on the canvas both conceptually and syntactically.\r\n\r\nPowerful abstractions for improved reasoning about the Javis API.\r\nCreating shorthand methods/constants to define general functions that saves creators from writing anonymous functions for each object by extending Luxor\u2019s shapes such as Line, Circle, Rectangle, Polygon etc.\r\n\r\nImprovements to object transformations\r\nTo be able to create stunning animations, being able to visualize the transformation of one element to another on the fly is both useful and aesthetically pleasing. The current state of morphing allows only single step transformation where the final object is not a distinctly different object.Being able to modify the new object after morphing will open new possibilities for the user to transform the object further.\r\n\r\nLivestream animations\r\nSharing is a part of creation, and being able to share animations is really important. Livestreaming can be done in two ways, over a local network, or directly to platforms like twitch.tv. While twitch support is a WIP, the former is available in the latest Javis.jl release.", "recording_license": "", "do_not_record": false, "persons": [{"id": 12268, "code": "7ESTQZ", "public_name": "Arsh Sharma", "biography": "Arsh Sharma is a student at the National Institute of Technology, Hamirpur, India. He is currently working as a  GSoC student for the Julia Language Community building Javis.jl, a math viz tool.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9891, "guid": "6bb11953-1e8d-5321-9bef-b8b8b039d164", "logo": "", "date": "2021-07-29T20:00:00+00:00", "start": "20:00", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9891-a-deep-dive-into-makielayout", "url": "https://pretalx.com/juliacon2021/talk/3S8DGW/", "title": "A deep dive into MakieLayout", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Makie.jl is a plotting package for high-performance interactive and publication-quality static data visualizations. MakieLayout, a former extension delivering flexible layouts and interactive widgets, has recently been integrated into the base package, and is now part of the default workflow.\r\nThis talk will take a detailed look at the new syntax and the architecture behind the layout system, as well as highlight features that make creating complex multi-plot figures a breeze.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10477, "code": "37WXQK", "public_name": "Julius Krumbiegel", "biography": "I'm a PhD student researching speech processing at the Institute for Systemic Neuroscience in Hamburg, Germany. I'm a core contributor to Makie.jl and the author of packages such as MakieLayout.jl, Chain.jl, Animations.jl.", "answers": []}], "links": [], "attachments": [], "answers": []}], "Blue": [{"id": 9708, "guid": "276f7198-e84e-501c-8954-a82b5ff6ad9e", "logo": "", "date": "2021-07-29T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9708-cuda-jl-3-0", "url": "https://pretalx.com/juliacon2021/talk/UGX8YR/", "title": "CUDA.jl 3.0", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "An overview and demonstration of the new features in CUDA.jl 3.0, most notably support for concurrent GPU programming.", "description": "CUDA.jl 3.0 was a major release of the NVIDIA GPU programming support package for Julia, with a major addition to the programming model: support for concurrent GPU programming with Julia tasks. In this talk, I will explain what concurrent GPU programming means, how it works, and how you can use it to improve your GPU programs.\r\n\r\nI will also talk about other features and changes that are part of CUDA.jl 3.0 and more recent releases, such as the new device-side random number generator, support for building computational graphs, the new memory allocator, etc.", "recording_license": "", "do_not_record": false, "persons": [{"id": 2402, "code": "9YQMAK", "public_name": "Tim Besard", "biography": "I'm a software engineer at Julia Computing, working on Julia's GPU packages and compilers.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9824, "guid": "84459090-1fee-537d-81ca-6ed495bf40d8", "logo": "/media/juliacon2021/submissions/DZC7HN/bickley_1sB1HcZ.jpg", "date": "2021-07-29T13:00:00+00:00", "start": "13:00", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9824-scaling-of-oceananigans-jl-on-multi-gpu-and-cpu-systems", "url": "https://pretalx.com/juliacon2021/talk/DZC7HN/", "title": "Scaling of Oceananigans.jl on multi GPU and CPU systems", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "This talk will present scaling and performance of the Oceananigans.jl ocean model on CPU and GPU systems. Oceananigans.jl is an all Julia code that is designed to study geophysical fluids problems ranging from idealized turbulence to planetary scale circulation. It uses the KernelAbstractions.jl package to support CPU and GPU single address space parallelism. It uses MPI.jl,  to support multi-node and multi-GPU parallelism. MPI.jl is used both directly and through PencilArrays.jl.", "description": "Oceananigans.jl is designed to be a user friendly ocean modeling code natively implemented in Julia that can scale from single core, laptop studies to large scale parallel CPU and GPU cluster systems. The codes finite volume algorithm has large inherent parallelism through spatial domain decomposition. \r\n\r\nIn this talk we will look at the strong and weak scaling performance of non-linear shallow water model configurations of Oceananigans. The code's numerical kernels utilize KernelAbstractions.jl, allowing one source code to be maintained that supports both CPU and GPU parallel scenarios. Multi-process on-node and multi-node parallelism is supported by MPI.jl and largely abstracted, using data structures and associated types that dispatch communication operations depending on the active parallelism model. \r\n\r\nWe will describe briefly the benchmark problems used and then look at scaling over multiple threads on CPUs within a single node, across multiple GPUs and across multiple CPU and GPU nodes in a high-performance computing cluster.  We will present speedup metrics and cost per solution metrics. The latter can be used to provide some measure of cost-effectiveness across quite different architectures.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1156, "code": "W7TEDS", "public_name": "Chris Hill", "biography": "Chris Hill is a principal researcher at MIT. He is a lead architect of the widely used MIT General Circulation Model (MITgcm). He has been working with the Julia community for almost a decade.", "answers": []}, {"id": 903, "code": "3C7UBC", "public_name": "Valentin Churavy", "biography": "PhD Student at MIT", "answers": []}, {"id": 1124, "code": "NH7ZDP", "public_name": "Ali Ramadhan", "biography": "I am a grad student working in computational climate science at MIT. In the Julia world I've mostly been developing Oceananigans.jl. We're building a new climate written in Julia as part of the Climate Modeling Alliance project.", "answers": []}, {"id": 10455, "code": "CJ9SDV", "public_name": "Francis Poulin", "biography": "Professor in Applied Mathematics at the University of Waterloo", "answers": []}, {"id": 10485, "code": "JVB98C", "public_name": "Gregory Wagner", "biography": "Research scientist and ocean physicist at MIT", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9821, "guid": "f5ac06fe-c39e-51f0-bfa5-43b7016aa225", "logo": "", "date": "2021-07-29T13:10:00+00:00", "start": "13:10", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9821-calculating-a-million-stationary-points-in-a-second-on-the-gpu", "url": "https://pretalx.com/juliacon2021/talk/ZYPPNH/", "title": "Calculating a million stationary points in a second on the GPU", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We will show how Julia allows us to implement spatial branch-and-bound-type methods using interval arithmetic in parallel on GPUs, in a relatively painless way.  As a test case, we calculate and verify existence and uniqueness of over one million stationary points of the transcendental Griewank function of two variables in one second on a recent GPU. We are not aware of any other system that is able to do this.", "description": "We will show how Julia allows us to implement spatial branch-and-bound-type methods using interval arithmetic in parallel on GPUs, in a relatively painless way. \r\n\r\nThese methods use repeated bisection in a divide-and-conquer style to perform exhaustive search over a box in d dimensions (for small d), in order to find all roots of a function f, find all global optima of f, or to bound feasible sets of constraints such as {x: f(x) \u2264 0}.\r\n\r\nUsing a vectorised implementation, we will show firstly how to define a vector of interval objects (or similar user-defined types) on the GPU, which most other systems cannot do. Then we need a way to run interval arithmetic methods, as defined in the IntervalArithmetic.jl package, on the GPU.  `CUDA.jl`'s broadcasting abstraction \r\n\r\nWe will illustrate with the Griewank function, a standard test case for nonlinear optimization. We have  developed a generic implementation of a vectorised branch-and-prune algorithm, which can run on both the CPU and GPU with no code changes whatsoever. A key difficulty that we faced, but were able to solve, was how to eliminate the uninteresting boxes in parallel.\r\n\r\nWe obtain a 2-orders-of-magnitude speed-up over a single CPU core, and we expect that performance will be improved even more by reducing array allocations.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1022, "code": "TJJRTG", "public_name": "David P. Sanders", "biography": "Professor of Computational Science at the Universidad Nacional Aut\u00f3noma de M\u00e9xico and visiting professor at MIT.\r\n\r\nInterested in computational science, interval arithmetic, and numeric-symbolic computing.\r\n\r\nAuthor of the JuliaIntervals suite of packages for interval arithmetic, and various tutorials on Julia.", "answers": []}, {"id": 11941, "code": "M33JR7", "public_name": "Valentin Churavy", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9698, "guid": "6d3cbc12-c41a-51e9-ab97-9446e4998c88", "logo": "", "date": "2021-07-29T13:20:00+00:00", "start": "13:20", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9698-zxcalculus-jl-a-julia-package-for-the-zx-calculus", "url": "https://pretalx.com/juliacon2021/talk/NWFRP9/", "title": "ZXCalculus.jl: A Julia package for the ZX-calculus", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "The ZX-calculus is a graphical language for representing and reasoning about quantum information. ZXCalculus.jl is a high-performance package for creating, manipulating, and visualizing ZX-diagrams in Julia. Comparing with a previous Python implementation PyZX, ZXCalculus.jl has 6-50x speed-ups on various tasks of simplifying ZX-diagrams. Moreover, this package is integrated with YaoCompiler.jl and works as a circuit simplification pass in the quantum compiler.", "description": "The repository of ZXCalculus.jl is available on GitHub: [ZXCalculus.jl](https://github.com/QuantumBFS/ZXCalculus.jl)\r\n\r\nFor a brief introduction to this package, please refer to this [blog post](https://chenzhao44.github.io/2020/08/27/ZXCalculus.jl/).\r\n\r\nFor more details about the ZX-calculus, please check this [website](http://zxcalculus.com/).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10337, "code": "NBKREV", "public_name": "Chen Zhao", "biography": "Quantum computing | quantum machine learning\r\n\r\nGitHub: [ChenZhao44](https://github.com/ChenZhao44), \r\nTwitter: [@ChenZhao44](https://twitter.com/ChenZhao44)", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9910, "guid": "103a0ed9-b23d-5330-9576-f66a4cc05fe6", "logo": "", "date": "2021-07-29T13:30:00+00:00", "start": "13:30", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9910-exatron-jl-a-scalable-gpu-mpi-based-batch-solver-for-small-nlps", "url": "https://pretalx.com/juliacon2021/talk/LMLJS8/", "title": "ExaTron.jl: a scalable GPU-MPI-based batch solver for small NLPs", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We introduce ExaTron.jl which is a scalable GPU-MPI-based batch solver for many small nonlinear programming problems. We present ExaTron.jl's architecture, its kernel design principles, and implementation details with experimental results comparing different design choices. We demonstrate a linear scaling of parallel computational performance of ExaTron.jl on Summit at Oak Ridge National Laboratory.", "description": "We introduce ExaTron.jl which is a scalable GPU-MPI-based batch solver for many small nonlinear programming problems. Its algorithm is based on a trust-region Newton algorithm for solving bound constrained nonlinear nonconvex problems. In contrast to existing work in the literature, it completely works on GPUs without requiring data transfers between CPU and GPU during its procedure. This enables us to eliminate one of the main performance bottlenecks under memory-bound situation. We present ExaTron.jl's architecture, its kernel design principles, and implementation details with experimental results comparing different design choices. We have implemented an ADMM algorithm for solving alternating current optimal power flow, where tens of thousands of small nonlinear nonconvex problems are solved by ExaTron.jl. We demonstrate a linear scaling of parallel computational performance of ExaTron.jl on Summit at Oak Ridge National Laboratory.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10493, "code": "WVYDVW", "public_name": "Youngdae Kim", "biography": "* B.S. in Mathematics and Computer Science, Pohang University of Science and Technology, 2007\r\n* M.S. in Computer Science, Pohang University of Science and Technology, 2009\r\n* Ph.D. in Computer Science, University of Wisconsin-Madison, 2017\r\n* Postdoctoral Appointee, Argonne National Laboratory, 2018-Current", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 8897, "guid": "60d6ffd0-d53a-5656-b986-6f727c89ad60", "logo": "", "date": "2021-07-29T16:30:00+00:00", "start": "16:30", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-8897-release-management-lessons-learned-in-juliadata-ecosystem", "url": "https://pretalx.com/juliacon2021/talk/RJE93F/", "title": "Release management - lessons learned in JuliaData ecosystem", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Registering a new release for your package is always a great moment. However, there are several challenges related with release management. In this talk, using the experience from JuliaData ecosystem, I will discuss the major things to consider if you want to keep your users happy.", "description": "In this talk I will discuss:\r\n1. How we manage development and patch branches in DataFrames.jl.\r\n2. Why users might not be able to install the latest version of your package and why installing it might downgrade other packages.\r\n3. How to coordinate releases of closely coupled packages.\r\n4. Why having interface packages like DataAPI.jl and Tables.jl is useful.", "recording_license": "", "do_not_record": false, "persons": [{"id": 929, "code": "DHRPEA", "public_name": "Bogumi\u0142 Kami\u0144ski", "biography": "I am a researcher in the fields of operations research and computational social science.\r\nFor development I use the Julia language. I currently mostly contribute to DataFrames.jl and related packages.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9535, "guid": "42ea5773-0dd6-5b58-8dc7-71aec7b8f9f7", "logo": "", "date": "2021-07-29T17:00:00+00:00", "start": "17:00", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9535-shaped-data-with-acsets", "url": "https://pretalx.com/juliacon2021/talk/NWRPGY/", "title": "Shaped Data with Acsets", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Acsets are a novel infrastructure for handling data of different shapes, based on category theory and implemented in Catlab.jl. Acsets generalize both graphs and dataframes, and allow a much more general approach to data manipulation than was previously available. We will discuss both the mathematics of acsets and some of the metaprogramming techniques we used to implement them in Julia. Finally, we will give examples of how acsets have been key in developing many projects in AlgebraicJulia.", "description": "Any practicing data scientist can tell you that all the munging going on between data acquisition and mathematical algorithm is a huge time sink. This is especially evident when the data does not fall into the traditional model of the dataframe. If one is lucky, it is shaped like a graph, and one can use a graph data structure and graph algorithms to analyze it. However, more generally, there are many more \"shapes\" of data, that must either be put into adhoc data structures or shoehorned into general-purpose data structures.\r\n\r\nIn Catlab, we have built a general infrastructure for differently-shaped data based on a category-theoretic framework for databases as functors that we call \"Attributed C-Sets\" (acsets for short).\r\n\r\nThe acset infrastructure is made possible by a novel use of the Julia macro and type system, which would be difficult-to-untenable in most other languages. First \"schemas\" for acsets are generated by macros. Then, more macros are used to transform these schemas into custom structs. Finally, we use `@generated` functions to specialize generic operations to these custom structs.\r\n\r\nThis approach gives us performance comparable to popular data solutions like DataFrames.jl and LightGraphs.jl, while remaining fully generic. The acset infrastructure is used pervasively throughout the AlgebraicJulia ecosystem because of the flexibility, expressivity, and performance features.\r\n\r\nIn our talk, we will give an overview of the mathematical and computational innovations necessary to implement the acset infrastructure, as well as examples of practical applications of acsets, and a reflection on how acsets have become an essential part of AlgebraicJulia.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10127, "code": "TY8PJL", "public_name": "Owen Lynch", "biography": "I am a master's student at Utrecht University, and a contributor for Catlab.jl", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9465, "guid": "84d9253a-5423-5784-b407-36b7fd5d4d02", "logo": "", "date": "2021-07-29T17:30:00+00:00", "start": "17:30", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9465-types-from-json", "url": "https://pretalx.com/juliacon2021/talk/3PCHLJ/", "title": "Types from JSON", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Tired of writing artisanally crafted types to match the JSON file or API you're consuming? Learn about type providers and how to have types created from your JSON.", "description": "Type providers infer and instantiate types from real world data.  [Types from data: Making structured data first-class citizens in F#](http://tomasp.net/academic/papers/fsharp-data/fsharp-data.pdf) formalized a type inference algorithm for real world data.  This talk will provide an overview of the theory of type providers, how this applies to Julia, and how you can get types from data today in  [JSON3.jl](https://github.com/quinnj/JSON3.jl).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10023, "code": "WQEVD7", "public_name": "Mary McGrath", "biography": "Mary is a Senior Research Software Engineer at Brown University\u2019s Center for Computation and Visualization, and a consulting Senior Software Engineer at RelationalAI. She works with researchers to provide scientific and technical computing expertise, combined with best practices, to advance computational research. She received her B.S. in Engineering Science from Smith College and her M.S. in Computer Science from Brown University.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9872, "guid": "ba483a42-d753-59b1-9c4e-823f3f2f48bb", "logo": "", "date": "2021-07-29T17:40:00+00:00", "start": "17:40", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9872-prettyprinting-optimal-layout-for-code-and-data", "url": "https://pretalx.com/juliacon2021/talk/HWSUQN/", "title": "PrettyPrinting: optimal layout for code and data", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "*PrettyPrinting* is a library for formatting composite data structures. PrettyPrinting optimizes the layout of the data to make it fit the screen width.\r\n\r\nOut of the box, PrettyPrinting can format Julia code and standard Julia containers.  It can be easily extended to format custom data types.", "description": "If you use Julia REPL to work with JSON or other nested data structures, you may find the way the data is displayed unsatisfactory.  If this is the case, consider using PrettyPrinting.  Compare:\r\n\r\n<pre>\r\njulia> data = JSON.parsefile(\"patient-example.json\")\r\nDict{String, Any} with 14 entries:\r\n  \"active\"               => true\r\n  \"managingOrganization\" => Dict{String, Any}(\"reference\"=>\"Organization/1\")\r\n  \"address\"              => Any[Dict{String, Any}(\"line\"=>Any[\"534 Erewhon St\"], \"dis\u2026\r\n  \"name\"                 => Any[Dict{String, Any}(\"family\"=>\"Chalmers\", \"given\"=>Any[\u2026\r\n  \"id\"                   => \"example\"\r\n  \"birthDate\"            => \"1974-12-25\"\r\n  \u22ee\r\n</pre>\r\n\r\n<pre>\r\njulia> using PrettyPrinting\r\n\r\njulia> pprint(data)\r\nDict(\r\n    \"active\" => true,\r\n    \"managingOrganization\" => Dict(\"reference\" => \"Organization/1\"),\r\n    \"address\" => [Dict(\"line\" => [\"534 Erewhon St\"],\r\n                       \"district\" => \"Rainbow\",\r\n                       \"use\" => \"home\",\r\n                       \"postalCode\" => \"3999\",\r\n                       \"city\" => \"PleasantVille\",\r\n                       \"period\" => Dict(\"start\" => \"1974-12-25\"),\r\n                       \"text\" => \"534 Erewhon St PeasantVille, Rainbow, Vic  3999\",\r\n                       \"type\" => \"both\",\r\n                       \"state\" => \"Vic\")],\r\n    \"name\" => [Dict(\"family\" => \"Chalmers\",\r\n                    \"given\" => [\"Peter\", \"James\"],\r\n                    \"use\" => \"official\"),\r\n               Dict(\"given\" => [\"Jim\"], \"use\" => \"usual\"),\r\n               Dict(\"family\" => \"Windsor\",\r\n                    \"given\" => [\"Peter\", \"James\"],\r\n                    \"use\" => \"maiden\",\r\n                    \"period\" => Dict(\"end\" => \"2002\"))],\r\n    \"id\" => \"example\",\r\n    \"birthDate\" => \"1974-12-25\",\r\n    \u22ee\r\n</pre>\r\n\r\nPrettyPrinting optimizes the layout of the data to make it fit the screen width.  It knows how to format tuples, named tuples, vectors, sets, and dictionaries.\r\n\r\nPrettyPrinting can also serialize `Expr` nodes as Julia code.  It supports a fair subset of Julia syntax including top-level declarations, statements, and expressions.\r\n\r\nThe ability of PrettyPrinting to format `Expr` nodes makes it easy to extend `pprint()` to user-defined data types.  Indeed, it is customary to display a Julia object as a valid Julia expression that constructs the object.  This could be done by converting the object to `Expr` and having `pprint()` format\r\nit.\r\n\r\nFor example, let us define a type `MyNode` modeled after the standard `Expr` type.\r\n\r\n<pre>\r\njulia> struct MyNode\r\n           head\r\n           args\r\n           MyNode(head, args...) = new(head, args)\r\n        end\r\n</pre>\r\n\r\nThe default implementation of `show()` is not aware of the custom constructor. Moreover, it dumps the whole object in a single line, making it difficult to read.\r\n\r\n<pre>\r\njulia> tree = MyNode(\"1\",\r\n                     MyNode(\"1.1\", MyNode(\"1.1.1\"), MyNode(\"1.1.2\"), MyNode(\"1.1.3\")),\r\n                     MyNode(\"1.2\", MyNode(\"1.2.1\"), MyNode(\"1.2.2\"), MyNode(\"1.2.3\")))\r\nMyNode(\"1\", (MyNode(\"1.1\", (MyNode(\"1.1.1\", ()), MyNode(\"1.1.2\", ()), MyNode(\"1.1.3\", \u2026\r\n</pre>\r\n\r\nWe implement function `quoteof(::MyNode)` to convert `MyNode` to `Expr`.  We can also override the default implementation of `show()` to make it use `pprint()`.\r\n\r\n<pre>\r\njulia> PrettyPrinting.quoteof(n::MyNode) =\r\n           :(MyNode($(quoteof(n.head)), $((quoteof(arg) for arg in n.args)...)))\r\n\r\njulia> Base.show(io::IO, ::MIME\"text/plain\", n::MyNode) =\r\n           pprint(io, n)\r\n</pre>\r\n\r\nNow the output is correct Julia code that fits the screen width.\r\n\r\n<pre>\r\njulia> tree\r\nMyNode(\"1\",\r\n       MyNode(\"1.1\", MyNode(\"1.1.1\"), MyNode(\"1.1.2\"), MyNode(\"1.1.3\")),\r\n       MyNode(\"1.2\", MyNode(\"1.2.1\"), MyNode(\"1.2.2\"), MyNode(\"1.2.3\")))\r\n</pre>\r\n\r\nInternally, PrettyPrinting represents all potential layouts of a data structure in the form of a *layout expression* assembled from atomic layouts, vertical and horizontal composition, and the choice operator.  The layout cost function estimates how well the layout fits the screen dimensions.  The algorithm for finding the optimal layout is a clever application of dynamic programming, which is described in [Phillip Yelland, A New Approach to Optimal Code Formatting, 2016](https://ai.google/research/pubs/pub44667).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10466, "code": "9MPXGK", "public_name": "Kyrylo Simonov", "biography": "The author of PyYAML, LibYAML, HTSQL, and DataKnots.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11871, "guid": "2a551a77-d316-51a7-a3f8-d7aeb72e11ff", "logo": "", "date": "2021-07-29T17:50:00+00:00", "start": "17:50", "duration": "00:05", "room": "Blue", "slug": "juliacon2021-11871-sponsor-talk-datachef-", "url": "https://pretalx.com/juliacon2021/talk/AKRLTA/", "title": "Sponsor talk (Datachef)", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Sponsor talk.", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 9086, "guid": "07501e21-183b-58f2-b808-78aa82aa091e", "logo": "", "date": "2021-07-29T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9086-package-latency-and-what-developers-can-do-to-reduce-it", "url": "https://pretalx.com/juliacon2021/talk/LE38LV/", "title": "Package latency and what developers can do to reduce it", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Package latency remains one of the chief complaints among Julia users. While recent improvements in Julia have reduced the problem, the opportunity for additional progress is large. In this talk I'll analyze latency from a package developer's standpoint, describing some of the factors that affect latency and how improvements in package design can reduce it. I will briefly exhibit tools that can help identify opportunities for improvement.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 1179, "code": "J9BSUH", "public_name": "Tim Holy", "biography": "Timothy E. Holy is the Alan A. and Edith L. Wolff Professor of Neuroscience and Biomedical Engineering at Washington University in St. Louis. His lab combines technological innovation with analysis of the rules governing neuronal function and computation. His work on Julia includes contributions to the type system, the array and broadcasting infrastructure, the standard library, and developer tools like the profiler, debugger, Revise, and many others.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9882, "guid": "c5b6bd31-b4c1-5958-8c7e-4fe6a1de8b25", "logo": "", "date": "2021-07-29T19:30:00+00:00", "start": "19:30", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9882-creating-a-shared-library-bundle-with-package-compiler", "url": "https://pretalx.com/juliacon2021/talk/KHK7PA/", "title": "Creating a Shared Library Bundle with Package Compiler", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "[`PackageCompiler.jl`](https://julialang.github.io/PackageCompiler.jl/dev/) has become the de facto method for creating standalone Julia applications. In this talk, we will demonstrate the use of `PackageCompiler.jl` to produce shared library bundles.  This functionality was added recently and allows the easy creation of location-independent dynamic libraries which can be linked to and called from C, C++, Rust, or other languages which can link to and use C libraries.", "description": "Julia has been touted as a great solution to the two-language problem (and it is).  But for many, interacting with code in other languages is a necessity.\r\n\r\nNumerous packages exist which aid interoperability with other languages, including C ([`Clang.jl`](https://juliainterop.github.io/Clang.jl/stable/)), C++ ([`CxxWrap.jl`](https://github.com/JuliaInterop/CxxWrap.jl)), Java ([`JavaCall.jl`](https://juliainterop.github.io/JavaCall.jl/)), Matlab ([`Matlab.jl`](https://github.com/JuliaInterop/MATLAB.jl) / [`Mex.jl`](https://github.com/byuflowlab/Mex.jl)), Python ([`PyCall.jl`](https://github.com/JuliaPy/PyCall.jl) / [`pyjulia`](https://pyjulia.readthedocs.io/en/stable/)), R ([`RCall.jl`](https://juliainterop.github.io/RCall.jl/stable/) / [`JuliaCall`](https://cran.r-project.org/web/packages/JuliaCall/readme/README.html)), Mathematica ([`MathLink.jl`](https://github.com/JuliaInterop/MathLink.jl)), and rust ([`jlrs`](https://docs.rs/jlrs/0.9.0/jlrs/)). \r\n\r\nMany of these packages focus on calling out to code in other languages from Julia, but there is also support for calling Julia code from other languages, especially for those that have the ability to call C functions, and that is what we will focus on here.\r\n\r\nThe Julia manual has a [full section on Embedding Julia](https://docs.julialang.org/en/v1/manual/embedding/).  Until now, this has been the standard way to embed and call Julia from other languages.  Using the ideas here, along with custom Julia sysimage generation with [`PackageCompiler.jl`](https://julialang.github.io/PackageCompiler.jl/dev/), one of us created a proof-of-concept repository for creating a shared library from Julia code for C or other languages (https://github.com/simonbyrne/libcg).\r\n\r\nOne downside of this work is that the library was not easy to relocate--it contained hard-coded paths to the Julia runtime.  We wanted the ability to create a relocatable shared library.\r\n\r\n`PackageCompiler.jl` already allowed the creation of \u201capps\u201d--bundles of files, including an executable--which could be relocated and moved to other machines (with some minor caveats).  We extended this functionality to create relocatable shared libraries with a `create_library` function.\r\n\r\nThe actual act of creating a shared library with `PackageCompiler.jl` is very much like creating an \u201capp\u201d, and has a very similar output--a bundle of directories which include the shared library and enough of the Julia runtime to run.  This bundle can be zipped or tarred up, sent to other computers, and installed in any location that a linker can find it.  The user has the option of setting the library version (on Mac and Linux), and can include C header files for the Julia functions she has exported in the shared library.\r\n\r\nFor this talk, we will give a brief overview of the `create_library` functionality, discuss situations in which it might be used, show how to use it, and discuss its limitations.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10473, "code": "TDJYFM", "public_name": "Kevin Squire", "biography": "Kevin Squire is a Senior Software Engineer at Second Spectrum, Inc., where he works in the AI group on machine learning algorithms and infrastructure.  Previously, he completed a postdoc in Computational Genetics at UCLA and taught Computer Science at the Naval Postgraduate School.  He received his PhD in Electrical Engineering from the University of Illinois.  Kevin has been interested in Julia since its first public release and was an early contributor to the language.", "answers": []}, {"id": 1131, "code": "PKSECG", "public_name": "Simon Byrne", "biography": "Simon is the lead software engineer at the [CliMA project](https://clima.caltech.edu/).", "answers": []}, {"id": 1090, "code": "AS3MKE", "public_name": "Kristoffer Carlsson", "biography": "I'm a contributor to the Julia language and many packages.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9757, "guid": "a003afaf-2b10-5bf2-9e67-2d0159c44fa4", "logo": "", "date": "2021-07-29T19:40:00+00:00", "start": "19:40", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9757-semantically-releasing-julia-packages", "url": "https://pretalx.com/juliacon2021/talk/CY88QP/", "title": "Semantically Releasing Julia Packages", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "The Julia community has embraced semantic versioning from a very early stage (if not from the get-go). The Julia package release flow has also been put through its paces and is easy to get started with. This is a great foundation and may be sufficient for most. However, some may require a more structured approach to release preparation, incorporating it into their day-to-day operations. This talk will show how to use the 'semantic release' framework for Julia packages to accomplish this.", "description": "The 'semantic release' framework (https://semantic-release.gitbook.io) builds upon the 'semantic versioning' (https://semver.org) and 'conventional commits' (https://www.conventionalcommits.org) specifications to bring release preparation closer to day-to-day operations.\r\n\r\nWhen the time rolls around for a new release of a Julia package, multiple decisions have to be made regarding which version number to assign, documenting what has changed, etc. This is not always a straightforward task. Gathering this information may require coordination within a group of people, or stretch long periods of time requiring effort to regain an overview of the current state of a package relative to the previous one to be able to document it. By adopting a specific commit message format, standard tooling can be used to extract this information automatically, whenever a release is desired. For instance, based on the content of commit messages the new semantic version can be determined, a changelog for the public API can be automatically generated, etc.\r\n\r\nAn argument can be made that, as all of this information is available in the version control system, there is no need for tooling such as this. However, the information contained in these systems is typically either too high-level due to sloppy commit messages, or it is too detailed requiring deep knowledge of the software to understand the implications of changes. It is typically not convenient for consumers of a Julia package to find out how a new release of a dependency affects their software.\r\n\r\nAdopting a 'semantic release' process benefits both developers and consumers of Julia software. For the former, it enables thinking about the impact of changes 'in the moment', instead of 'after the fact'. This is typically beneficial for the quality of documentation of these changes (e.g. reasons why, etc.). For the latter, it becomes easier to judge whether a new release of a dependency actually has an impact on their software.\r\n\r\nSlides are available at https://bauglir.gitlab.io/talks/juliacon-2021-semantically-releasing-julia-packages/.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4395, "code": "VCBWCT", "public_name": "Joris Kraak", "biography": "I'm a senior software engineer with GN Advanced Science and have been working with Julia since 2014. My Julia work is focused on platform development for rapid prototyping of audio signal processing algorithm personalization and cloud-based deployment. I'm passionate about making software development accessible from a technical perspective through abstraction and automation.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9799, "guid": "599718b2-4c42-5cc4-b29e-35765079709b", "logo": "", "date": "2021-07-29T19:50:00+00:00", "start": "19:50", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9799-runtime-switchable-blas-lapack-backends-via-libblastrampoline", "url": "https://pretalx.com/juliacon2021/talk/ZSPVMT/", "title": "Runtime-switchable BLAS/LAPACK backends via libblastrampoline", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Julia has historically been built against a single backing BLAS/LAPACK library, and switching to a different library has required a recompilation of Julia.  This was compounded by issues with loading 3rd party binaries that linked against incompatible BLAS backends.  This talk will showcase a new low-overhead compatibility layer in Julia v1.7 named libblastrampoline that allows for runtime switching of BLAS/LAPACK libraries, as well as allowing loading of multiple BLAS/LAPACK ABIs at once.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 2405, "code": "ST7KZT", "public_name": "Mos\u00e8 Giordano", "biography": "Research Software Developer at UCL during the day, binary builder during the night.", "answers": []}, {"id": 1080, "code": "B98NWS", "public_name": "Elliot Saba", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9900, "guid": "84c8729a-bc66-51cf-b23f-e5a746a35d51", "logo": "", "date": "2021-07-29T20:00:00+00:00", "start": "20:00", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9900-deep-dive-creating-shared-libraries-with-packagecompiler-jl", "url": "https://pretalx.com/juliacon2021/talk/U9SZZU/", "title": "Deep Dive: Creating Shared Libraries with PackageCompiler.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "The ability to create shared library bundles was recently added to `PackageCompiler.jl`.  In this talk, we will discuss the technical details of the implementation and give in-depth examples of using the resulting shared library bundles from C and Rust.", "description": "We recently added to `PackageCompiler.jl` functionality for creating shared library bundles, consisting of a \"main\" dynamic library (`.so`, `.dylib`, or `.dll`) created from Julia code, as well as any required Julia runtime libraries.  The purpose of the library bundle is to allow developers to write Julia code that can be distributed to developers using other languages without the need for Julia to be installed.\r\n\r\nThis work extends the existing `PackageCompiler.jl` functionality to create self-contained, distributable and relocatable \"apps\".  In this talk, we will go into the details of the implementation, as well as give in-depth examples of using the resulting shared library from C and rust.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10473, "code": "TDJYFM", "public_name": "Kevin Squire", "biography": "Kevin Squire is a Senior Software Engineer at Second Spectrum, Inc., where he works in the AI group on machine learning algorithms and infrastructure.  Previously, he completed a postdoc in Computational Genetics at UCLA and taught Computer Science at the Naval Postgraduate School.  He received his PhD in Electrical Engineering from the University of Illinois.  Kevin has been interested in Julia since its first public release and was an early contributor to the language.", "answers": []}, {"id": 10490, "code": "T9LQRQ", "public_name": "Nikhil Mitra", "biography": "Senior Machine Learning Engineer at Second Spectrum.", "answers": []}, {"id": 1090, "code": "AS3MKE", "public_name": "Kristoffer Carlsson", "biography": "I'm a contributor to the Julia language and many packages.", "answers": []}, {"id": 1131, "code": "PKSECG", "public_name": "Simon Byrne", "biography": "Simon is the lead software engineer at the [CliMA project](https://clima.caltech.edu/).", "answers": []}], "links": [], "attachments": [], "answers": []}], "Purple": [{"id": 9950, "guid": "427462b9-b4b2-5544-b341-1af3a4941864", "logo": "", "date": "2021-07-29T12:30:00+00:00", "start": "12:30", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9950-datasets-jl-a-bridge-between-code-and-data", "url": "https://pretalx.com/juliacon2021/talk/73XKCM/", "title": "DataSets.jl: A bridge between code and data", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "In technical computing, getting data into and out of your code can be a pain. Data comes in all shapes, sizes and formats, with many different locations and storage access mechanisms.\r\n\r\nDataSets.jl is a new package for describing data declaratively and mapping it neatly into your programs. We aim to make your code portable between data environments and remove the cruft of local paths and data access wrappers which litter technical analysis code.", "description": "DataSets.jl is an open source package for describing data format and location declaratively so that one can better separate data deserialization and access from the domain-specific analysis code which consumes that data.\r\n\r\nTo quote from the package documentation available at https://juliacomputing.github.io/DataSets.jl/dev :\r\n\r\nDataSets.jl exists to help manage data and reduce the amount of data wrangling\r\ncode you need to write. It's annoying to constantly rewrite\r\n* Command line wrappers which deal with paths to data storage\r\n* Code to load and save from various *data storage systems* (eg, local\r\n  filesystem data; local git data, downloaders for remote data over various\r\n  protocols, cloud storage access)\r\n* Code to load the same data model from various serializations\r\n* Code to deal with data lifecycle; versions, provenance, etc\r\n\r\nDataSets.jl provides scaffolding to make this kind of code more reusable. We want\r\nto make it easy to *relocate* an algorithm between different data environments\r\nwithout code changes. For example from your laptop to the cloud, to another\r\nuser's machine, or to an HPC system.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10496, "code": "FAS33Q", "public_name": "Chris Foster", "biography": "I'm a long time enthusiastic user of Julia and enjoy contributing to various packages across the open source ecosystem, Julia standard libraries and compiler. I love hearing about people's fascinating technical computing adventures of all types! Find me at https://github.com/c42f", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9688, "guid": "12a54288-e038-53f9-a1ae-bb8c8915266b", "logo": "", "date": "2021-07-29T12:40:00+00:00", "start": "12:40", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9688-systems-biology-in-modelingtoolkit", "url": "https://pretalx.com/juliacon2021/talk/EZHEQL/", "title": "Systems Biology in ModelingToolkit", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Systems Biology Markup Language (SBML) and CellML are extensible markup languages (XML) widely used throughout the biological modeling community. In this talk we showcase new packages (SBML.jl and CellMLToolkit.jl) for importing models from these languages to the ModelingToolkit.jl format for the full suite of SciML tools to simulate and analyze!", "description": "Back in my day, systems biologists used MATLAB and Python for RK4. But in 2021 we can now run downhill both ways and make our biological models zoom with CellMLToolkit.jl and SBMLToolkit.jl in Julia! We will demonstrate importing CellML and SBML models into ModelingToolkit and how we get these model analysis and simulation tools \"for free\" in an acausal symbolic component model. We will show a few examples of how (biological) researchers may benefit from the broader SciML ecosystem, including parameter estimation and global sensitivity analysis. Short comparisons with de facto SBML and CellML modeling programs will be drawn to demonstrate how a biologists\u2019 workflow may differ with SciML. The audience will leave with a firm understanding of how the Julia simulation environments will lead the next generation of biological modeling and simulation.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10325, "code": "YQY9SF", "public_name": "Anand Jain", "biography": "I am interested in the intersection of mathematics and physiology. I am a computer science student at the University of Chicago on a gap year. I am working at Julia Computing on building surrogates of systems biological models for JuliaSim.", "answers": []}, {"id": 10335, "code": "QZQELJ", "public_name": "Shahriar Iravanian", "biography": "Shahriar Iravanian, MD, MSE, is a practicing cardiac electrophysiologist and biophysical researcher with an interest in non-linear dynamics and high-performance computing with a focus on the modeling of cardiac arrhythmias. He received a Master of Science in computer science from Johns Hopkins University and finished his cardiology and electrophysiology training at the Emory University in 2011.", "answers": []}, {"id": 10340, "code": "BXYAMA", "public_name": "Paul Lang", "biography": "I am a systems biology PhD student with background in molecular biology. My doctoral research at the University of Oxford aims at improving our mechanistic understanding of cell cycle dynamics with mathematical models. This involves (1) casting chemical reaction networks into executable models, (2) obtaining highly multiplexed snapshot measurements of cell cycle regulators, from which we reconstruct their time-courses, and (3) developing parameter optimisation and model reduction/selection toolboxes.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10027, "guid": "ec2025ff-a0f7-5588-94ef-40c4f1baed27", "logo": "", "date": "2021-07-29T12:50:00+00:00", "start": "12:50", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-10027-single-cell-resolved-cell-cell-communication-modeling-in-julia", "url": "https://pretalx.com/juliacon2021/talk/YKHNVR/", "title": "Single-cell resolved cell-cell communication modeling in Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We develop multiscale models that couple cell-cell communication with cell-internal gene regulatory network dynamics to study cell fate decision-making from a dynamical systems perspective. In JuliaLang, we model cell-cell communication as a Poisson process, and cell-internal dynamics with nonlinear ordinary differential equations, taking advantage of the power of DifferentialEquations.jl. We show that subtle changes in cell-cell communication lead to dramatic changes in cell fate distributions.", "description": "The role of cell-cell communication in cell fate decision-making has not been well-characterized through a dynamical systems perspective. To do so, here we develop multiscale models that couple cell-cell communication with cell-internal gene regulatory network dynamics. This allows us to study the influence of external signaling on cell fate decision-making at the resolution of single cells. We study the granulocyte-monocyte vs. megakaryocyte-erythrocyte fate decision, dictated by the GATA1-PU.1 network, as an exemplary bistable cell fate system. Using JuliaLang, we model the cell-internal dynamics with nonlinear ordinary differential equations and the cell-cell communication via a Poisson process. \r\n\r\nIn this work, through analysis of a wide range of cell-cell communication topologies, we discovered that general principles emerged describing how cell-cell communication regulates cell fate decision-making. We studied a wide range of cell communication topologies through simulation using tools from DifferentialEquations.jl. We also used our high-performance computing cluster to run thousands of simulations in order to understand the limiting behaviors of our model. We show that, for a wide range of cell communication topologies, subtle changes in signaling can lead to dramatic changes in cell fate. We find that cell-cell coupling can explain how populations of heterogeneous cell types can arise. Analysis of intrinsic and extrinsic cell-cell communication noise demonstrates that noise alone can alter the cell fate decision-making boundaries. These results illustrate how external signals alter transcriptional dynamics, provide insight into cell fate decision-making, and provide a framework for modeling cell-cell communication that we expect will be of wide interest to the systems biology community.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10595, "code": "SF3FVR", "public_name": "Megan Franke", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9509, "guid": "9be59fd7-203c-5994-95ca-a42fa3e96393", "logo": "", "date": "2021-07-29T13:00:00+00:00", "start": "13:00", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9509-flowatlas-jl-interactive-exploration-of-phenotypes-in-cytometry", "url": "https://pretalx.com/juliacon2021/talk/QTLENJ/", "title": "FlowAtlas.jl: interactive exploration of phenotypes in cytometry", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "I will present an interactive web app for exploring phenotypes in flow cytometry data. In particular a multi-tissue, high-dimensional, immune cell dataset. This tool bridges computational methods in GigaSOM.jl and the popular FlowJo, used to annotate cells with gating strategies. By leveraging the geospatial mapping library OpenLayers to render, annotate and analyze cells, immunologists can now efficiently navigate the phenotype space of Human Cell Atlas datasets.", "description": "This project demonstrates how combining OpenLayers, D3 and GigaSOM.jl using JSServe.jl allowed us to create interactive clustering and visualisation tools for really large cytometry data. We want to continue lowering the entry barrier for experimental biologists to use computational tools.\r\n\r\nThis talk should be interesting to people from bioinformatics, immunology, machine learning and web development. Special thanks go to the lovely people involved in GigaSOM.jl for the helpful discussions", "recording_license": "", "do_not_record": false, "persons": [{"id": 4051, "code": "ZBMJRN", "public_name": "Grisha Szep", "biography": "Russian/Hungarian biophysics and machine learning PhD student at King's College London, collaborating with Microsoft Research Cambridge. Born in Vienna. Wanted to become an actor but luckily landed in research", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9884, "guid": "f5a1d0bd-e556-5753-84f7-ad9bd16aa2b7", "logo": "", "date": "2021-07-29T13:10:00+00:00", "start": "13:10", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9884-designing-ecologically-optimized-vaccines", "url": "https://pretalx.com/juliacon2021/talk/EWWNFZ/", "title": "Designing ecologically optimized vaccines", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Designing vaccines is an expensive and time consuming process. This talk demonstrates how we can exploit automatic differentiation of ODEs, parallelization, stochastic search and Bayesian optimization to minimize post-vaccination invasive pneumococcal disease and antibiotic resistant strains in a bacteria population using a novel computational model of the bacterial population dynamics that integrates epidemiological and genomic data.", "description": "Streptococcus pneumoniae (the pneumococcus) is a common nasopharyngeal bacterium that can cause invasive pneumococcal disease (IPD). Each component of current vaccines generally induce immunity to one of the approximately 100 pneumococcal types. Overall carriage rates remain similar to pre-vaccination as the serotypes not affected by the vaccine will replace the affected ones. Selecting which serotypes to target to minimize the post-vaccine IPD burden is a challenging combinatorial problem involving a large ODE system describing the population dynamics of the bacteria in response to each proposed vaccine. This talk describes how I have approached this problem using automatic differentiation, parallelized evaluation of the ODEs, stochastic search and Bayesian optimization. Here is a link to the paper this work is based on: https://www.nature.com/articles/s41564-019-0651-y.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4397, "code": "Z7JSAN", "public_name": "Kusti Skyt\u00e9n", "biography": "A Biostatistics PhD student from the University of Oslo. I'm working on combining computer simulations with Bayesian statistical models. I have been a big fan of Julia since version 0.4. My research interests are Bayesian statistics, symbolic computing and applied category theory.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9796, "guid": "a14acbd5-d2ce-5c80-9612-b5d3da22f15f", "logo": "", "date": "2021-07-29T13:20:00+00:00", "start": "13:20", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9796-prs-jl-fast-polygenic-risk-scores", "url": "https://pretalx.com/juliacon2021/talk/PDMYDR/", "title": "PRS.jl: Fast Polygenic Risk Scores", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Determining one\u2019s risk of developing various diseases throughout one\u2019s lifetime is important for pursuing good health. An emerging method for performing this calculation is the Polygenic Risk Score, or PRS. A PRS method allows one to construct a model of risk of acquiring a certain disease given one\u2019s own genome and provides a simple numerical result representing that risk. We will describe how we ported a widely used PRS program to Julia and the performance and usability that we gained.", "description": "The PRS-CS Python library calculates the relationship between genetic features and traits, eventually producing a single numerical result representing a person\u2019s genetic susceptibility to a given disease. It does this using a novel Markov Chain Monte Carlo approach, allowing it to capture information from more genetic features than previous approaches. \r\nAs collection and storage of genetic data increases globally, more diseases are studied at once. However, when calculating these scores for many diseases while maintaining high accuracy, the computational burden becomes increasingly expensive. Because of the limitations of PRS-CS in making top-notch accuracy fast, we developed PRS.jl. \r\n\r\nPRS.jl started as a direct port of PRS-CS, and without any special treatment produces results with the same accuracy but in a fraction of the time (or, depending on the configuration, better accuracy for the same amount of time). Today, PRS.jl boasts additional features and improved usability over PRS-CS, while maintaining low compute times per trait (among 9 tested) from an average of 80 hours for PRS-CS to just 15 for PRS.jl.\r\n \r\nIn this talk, I will introduce the concept of polygenic risk scores and describe how the they are used in biology and medicine. Next, I'll demonstrate how the program works and what aspects we improved upon. Finally, I will show areas where users can contribute improvements to the package.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10399, "code": "KJRBM3", "public_name": "Annika Faucon", "biography": "I am a doctoral candidate in Vanderbilt\u2019s human genetics PhD training program.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9565, "guid": "90a1571b-8e3e-5f9f-bf01-e8cee9351dd3", "logo": "/media/juliacon2021/submissions/DQJNVA/phylonetworks-logo_1mJDpzf.png", "date": "2021-07-29T13:30:00+00:00", "start": "13:30", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9565-phylonetworks-a-julia-package-for-phylogenetic-networks", "url": "https://pretalx.com/juliacon2021/talk/DQJNVA/", "title": "PhyloNetworks: a Julia package for phylogenetic networks", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Evolutionary relationships among organisms are depicted by a binary tree. However, not all species follow the paradigm of vertical inheritance of genes and thus, estimation of phylogenetic networks becomes necessary. PhyloNetworks is the first Julia package for the inference, manipulation, visualization, and use of phylogenetic networks.\r\nThe package documentation has a full tutorial including upstream analyses, network estimation, bootstrap analysis, and downstream analyses for trait evolution.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10160, "code": "GRHU7U", "public_name": "Claudia Solis-Lemus", "biography": "I am an assistant professor at the Wisconsin Institute for Discovery and the Department of Plant Pathology at the University of Wisconsin-Madison. Originally from Mexico City, I did my Undergraduate degrees in Actuarial Sciences and Applied Mathematics at ITAM. Then, I did a MA in Mathematics and a PhD in Statistics at the University of Wisconsin-Madison.\r\nIn my spare time, I enjoy swimming, running, biking, climbing and yoga!\r\nPronouns: she/her", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9438, "guid": "39d7c065-0017-597a-b706-080348730e0b", "logo": "", "date": "2021-07-29T13:40:00+00:00", "start": "13:40", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9438-solving-pokemon-go-battles-using-julia", "url": "https://pretalx.com/juliacon2021/talk/NUFWBU/", "title": "Solving Pokemon Go Battles using Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "RandomBattles.jl is a Julia package for the efficient simulation of individual and team Player-vs-Player Battles in Pokemon Go, the AR mobile game by Niantic. This package can compute Monte Carlo simulations, as well as game theoretic solutions to perfect information games. Using the game\u2019s structure and Nash equilibria, the algorithm computes optimal play strategies for an arbitrary number of moves. These simulations derived strategies that are highly similar to those employed by human players.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 9716, "code": "TEFWKB", "public_name": "Ian Slagle", "biography": "Ian Slagle is an junior undergraduate student studying Computer Science, Mathematics, and Physics at Coe College in Cedar Rapids, IA who utilizes Julia in his research. He currently plans to attend graduate school for Data Science.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9810, "guid": "ade86f40-d2eb-53a6-8d69-03961b84084f", "logo": "", "date": "2021-07-29T13:50:00+00:00", "start": "13:50", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9810-julia-for-data-analysis-in-high-energy-physics", "url": "https://pretalx.com/juliacon2021/talk/TRMZFB/", "title": "Julia for data analysis in High Energy Physics", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "The talk presents the first data analysis in the LHCb experiment performed in Julia (arXiv:2107.03419). The analysis includes data selection, building and combining complex PDFs (`AlgebraPDF.jl`), likelihood fitting, angular analysis (`FourVectors.jl`, `ThreeBodyDecay.jl`, `PartialWaveFunctions.jl`), hypotheses testing, and running pseudo experiments. New packages enrich Julia ecosystem fostering the adoption of the language in the High Energy Physics community.", "description": "The field of High Energy Physics (HEP) is a natural place to take great benefits of Julia language. The adaptation of Julia in HEP, however, has been slow and the HEP ecosystem stays a promising place for future development. In the talk, I will present [an example of the data analysis in LHCb](https://inspirehep.net/literature/1879440), a large collaboration of 1000 scientists, that pioneers an application of Julia to the typical HEP problems. The central part of the analysis is the study of a multi-particle spectrum by building a customary Mixture Model PDF based on the particle-scattering amplitude using [AlgebraPDF.jl](https://github.com/mmikhasenko/AlgebraPDF.jl), extended-likelihood fitting, and spin-hypotheses testing using sets of pseudo experiments.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10407, "code": "XBMXGQ", "public_name": "Mikhail Mikhasenko", "biography": "I am a physicist studying exotic matter formation via resonance phenomena of the QCD.\r\n\r\nField: elementary particles, hadron spectroscopy\r\n\r\nOrganizations: CERN (LHCb, COMPASS), JPAC, ORIGINS Cluster", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11726, "guid": "e7be5ee6-7106-595a-95dc-106556d0aa2f", "logo": "", "date": "2021-07-29T16:30:00+00:00", "start": "16:30", "duration": "01:30", "room": "Purple", "slug": "juliacon2021-11726-experiences-session", "url": "https://pretalx.com/juliacon2021/talk/MAUPF9/", "title": "Experiences session", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "This session will include all the experiences talks. List of all experiences talks: https://juliacon.org/2021/experiences/", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 9890, "guid": "97847ad8-9c9b-5bec-9408-0049e5ad15cd", "logo": "", "date": "2021-07-29T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Purple", "slug": "juliacon2021-9890-monads-2-0-aka-algebraic-effects-extensibleeffects-jl", "url": "https://pretalx.com/juliacon2021/talk/BB97DT/", "title": "Monads 2.0, aka Algebraic Effects: ExtensibleEffects.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "While Monads make it easy to hide one context nicely in your code, with Extensible Effects you can combine multiple contexts and let them seamlessly interact with each other. TLDR: If you want to abstract and hide away some computational context, prefer Extensible Effects to Monads.", "description": "You heard that monads should be cool, but guess maybe there is something better already? Indeed ;-)\r\n\r\nExtensible effects, or sometimes also called algebraic effects are now around for some time and have made monads composable.\r\nRemember, a monad is essentially a composable hidden context, however to compose different such monads has been a struggle for many years.\r\n\r\nThis talk will present the concept and implementation of Extensible Effects. The implementation was adapted from the scala library Eff, but massively simplified, and with many examples of different complexity. Hence it will serve very well for educational purposes. You can find the source code at https://github.com/JuliaFunctional/ExtensibleEffects.jl\r\n\r\nExtensible Effects are a bit like magic. The implementation looks so small but what it can do surpasses imagination, even if you programmed it yourself. It is a truly remarkable concept. Grab the chance and get to know it in this session!", "recording_license": "", "do_not_record": false, "persons": [{"id": 4390, "code": "MJPZGQ", "public_name": "Stephan Sahm", "biography": "Stephan Sahm is Senior Data Science and ML Engineering Consultant. Having programmed in Java, Matlab, Python, R, Scala and Julia he appreciates the combination of simplicity and speed which the Julia language brings to Data Science. With master degree in math/stochastics and cognitive science together with 5 years industry experience he can help you bring your favourite Data idea into production.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9881, "guid": "034088ad-0cb6-5677-90ca-bdaddf2fd128", "logo": "", "date": "2021-07-29T19:30:00+00:00", "start": "19:30", "duration": "00:30", "room": "Purple", "slug": "juliacon2021-9881-roadmap-to-julia-blas-and-linearalgebra", "url": "https://pretalx.com/juliacon2021/talk/QDBNXV/", "title": "Roadmap to Julia BLAS and LinearAlgebra", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "BLAS & LAPACK are an integral component of many numerical algorithms. Due to their importance, a lot of effort has gone into optimizing ASM/C/Fortran implementations.\r\nNonetheless, early work demonstrated Julia implementations were often faster than competitors, while laying groundwork for new routines specialized for new problems.\r\nWe discuss a roadmap toward providing Julia BLAS and LAPACK libraries, from optimizations in LoopVectorization to libraries like Octavian and RecursiveFactorization.", "description": "The primary motivations for implementing BLAS/LAPACK in Julia are:\r\n1. Because we can!\r\n2. The existence of highly optimized alternatives such as MKL provide a solid benchmark by which to assess how we're doing before applying the same optimization approaches to novel problems.\r\n3. We can adapt the routines easily to related operation types such as evaluating dense layers or miscellaneous tensor operations.\r\n4. Generic with respect to number types, whether that means mixing precision or something as exotic as Tropical Numbers (showcased in TropicalGEMM.jl).\r\n5. Ability to take advantage of compile time information and specialize, e.g. for statically sized arrays.\r\n6. Relatively painless support for new hardware, as we do not need to write assembly kernels. Feature detection and support for generating optimized code will also be tied with LLVM rather than libraries like OpenBLAS, which tend to lag far behind the compilers.\r\n\r\nSome of the challenges faced in the ecosystem include:\r\n1. Efficient composable threading with low enough overhead to beat MKL for small array sizes.\r\n2. Compilation time or sysimage building to avoid \"time to first matmul\" problems.\r\n3. The implementations of BLAS and LAPACK routines themselves.\r\n\r\nTraditionally, BLAS and LAPACK libraries define many compute kernels, typically written in assembly for each supported architecture. Supporting code then builds the supported BLAS and LAPACK routines through applying these kernels.\r\n\r\nLibraries such as  Octavian and RecursiveFactorization followed this approach while using LoopVectorization to produce most of the kernels.\r\nAn alternative approach is to use these problems to motivate and guide extending LoopVectorization to perform analysis and optimizations.\r\nAt the time I submit this proposal, planned features that will be able to extend the amount of work LoopVectorization can handle automatically, thereby reducing the effort needed to implement new functions:\r\n1. Allowing the bounds of inner loops to depend on the induction variables of outer loops. For example, loops of the form`for m in 1:M, n in 1:m; ...; end`.\r\n2. Allow multiple loops to occur at the same level in the nest. For example, loops of the form `for m in 1:M; for n in 1:N; end; for k in 1:K; end; end`.\r\n3. Model dependencies across loop iterations, and avoid violating them. For example, loops of the form `for m in 1:M; a[m] += a[m-1]; end`.\r\n\r\nTogether, these would allow LoopVectorization to support loop nests performing cholesky factorizations or triangular solves. These should be tunable to perform with (nearly) optimal performance at small to moderate sizes for use in blockwise routines.\r\n\r\nAn orthogonal set of optimizations would be to develop a model for automatically generating blocking (working on pieces of arrays at a time that fit nicely into upper cache levels) and packing code (copying pieces of arrays into temporary buffers to avoid pessimized address calculations due to memory accesses being spread across too many pages; this also benefits hardware prefetchers, which require relatively small strides between subsequent memory accesses to trigger).\r\n\r\nWe outline a path toward building up an ecosystem through a combination of the approaches, including applications we can target -- such as stiff ODE solves benefiting from LU and triangular solves -- and see immediately benefits along the way.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4370, "code": "DNZRRM", "public_name": "Chris Elrod", "biography": "Statistician and SIMD-enthusiast.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9866, "guid": "d6db926c-13e6-5d68-b948-87eb4494028e", "logo": "", "date": "2021-07-29T20:00:00+00:00", "start": "20:00", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9866-suitesparsegraphblas-jl", "url": "https://pretalx.com/juliacon2021/talk/YFPXCU/", "title": "SuiteSparseGraphBLAS.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Graphs are a ubiquitous and versatile data structure, which allow representation of problems and systems across a vast array of domains, from infrastructure networks and molecules to language and social interactions. [SuiteSparseGraphBLAS.jl](https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl) casts graph computations as generalized linear algebra on sparse matrices. Support for ChainRules AD frameworks, and the wider ecosystem is a core feature of v1.0, releasing around JuliaCon.", "description": "This talk will give an overview of progress on a JSOC 2021 project. Most work will be complete by this point, and the talk will give a brief overview of GraphBLAS, an example algorithm using GraphBLAS in Julia, and a graph neural network layer written using the project. \r\n\r\nOne of the goals of the project is interoperability with the Julia ecosystem, integrating with interfaces from SparseArrays, LightGraphs, and GeometricFlux. These integrations will be highlighted as well.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10456, "code": "D8TKR8", "public_name": "William Kimmerer", "biography": "Recent graduate from the University of Kentucky in Computer Science and Mathematics. Passionate about graphs, machine learning, and logic programming.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9865, "guid": "34c29796-446f-58af-b934-b606b3a87c2f", "logo": "", "date": "2021-07-29T20:10:00+00:00", "start": "20:10", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9865-mutablearithmetics-an-api-for-mutable-operations", "url": "https://pretalx.com/juliacon2021/talk/PRFW3N/", "title": "MutableArithmetics: An API for mutable operations", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "The definition of the arithmetic operations defined in Julia assume that the arguments are not modified.\r\nHowever, in many situations, a variable represents an accumulator that can be modified to contain the result, e.g., when summing the elements of an array.\r\nMoreover, many types can be mutated and mutating the element may have significant performance benefit.\r\nThis talk presents an interface that allows algorithms to exploit a possible mutability while still being completely generic.", "description": "Julia allows to write generic algorithms that work with arbitrary number types as long as they implement the needed operation such as `+`, `*`, ...\r\nThe definition of the arithmetic operations defined in Julia assume that the arguments are not modified.\r\nHowever, in many situations, a variable represents an accumulator that can be modified to contain the result, e.g., when summing the elements of an array.\r\nMoreover, many types can be mutated, e.g., multiple precision numbers, JuMP expressions, MOI functions, polynomials, arrays, ...\r\nand mutating the element may have significant performance benefit.\r\n\r\nThis talk presents an interface called MutableArithmetics.\r\nIt allows for mutable types to implement an arithmetics exploiting their mutability and for algorithms to exploit mutability while still being completely generic.\r\nMoreover, it provides the following additional features:\r\n1. it re-implements part of the Julia standard library on top of the API to allow mutable type to use a more efficient version than the default one.\r\n2. it defines a `@rewrite` macro that rewrites an expression using the standard operations (e.g `+`, `*`, ...) into a code that exploits the mutability of the intermediate values created when evalutation the expression.\r\n\r\nJuMP used to have its own API for mutable operations on JuMP expressions and its own JuMP-specific implementation of 1. and 2..\r\nThis was refactored into the package MutableArithmetics generalizing this to arbitrary mutable types.\r\nStarting from JuMP v0.21, JuMP expression and MOI functions implement the MutableArithmetics API and the JuMP-specific implementation of 1. and 2. was removed in favor of the generic versions implemented in MutableArithmetics on top of the MutableArithmetics API.\r\n\r\nWhile MutableArithmetics is already used in the released versions of numerous packages (such as JuMP, MathOptInterface, SumOfSquares, Polyhedra, SDDP and MultivariatePolynomials)\r\nand seems to be working well and cover the use cases of many different types and algorithms on these types,\r\nwe may still need to modify the API to cover all possible use cases.\r\nDuring this presentation, we hope to argue our design decision in a clear and detailed manner so that the Julia community can help us figure out whether there are situations that the API does not cover and how it could be further improved.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10452, "code": "MLJG3F", "public_name": "Beno\u00eet Legat", "biography": "Beno\u00eet Legat is a postdoctoral associate at MIT with Prof. Pablo Parrilo\r\nin the Laboratory for Information and Decision Systems (LIDS).\r\nHe received his Ph.D. degree in applied mathematics from the UCLouvain, Belgium, in 2020.\r\nHis research interests include mathematical optimization, invariant set computation and\r\noptimal control.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9686, "guid": "06e90a66-1293-50ee-a1d2-ffed3d995de6", "logo": "", "date": "2021-07-29T20:20:00+00:00", "start": "20:20", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9686-exprtools-metaprogramming-from-reflection", "url": "https://pretalx.com/juliacon2021/talk/FEEV9A/", "title": "ExprTools: Metaprogramming from reflection", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Have you ever had a list of `Method`s, e.g. from the output of `methodswith`, and thought _\u201dI just want to implement all of these, it would be great to use metaprogramming for that\u201d_?\r\nExprTools.jl has the parts to let you extract the info out of the method table, manipulate it, and then generate the AST you want for the new method you want to define.\r\n\r\nDoes this access undocumented Julia internals? Absolutely!\r\nIs this well tested? Comprehensively!\r\nIs this a good idea? Who knows!", "description": "Sometimes you want to generate definitions for many methods. Consider for example  implementing there delegation pattern. Where you have a field of a different type, and you want to overload all methods that accept that field\u2019s type to also accept this new object, and have them just delegate to calling the method on the field. Ideally this wouldn\u2019t come up and you would just need to implement a small well documented set for an interface. But sometimes things can\u2019t be ideal. Generating overloads from the method table is one way to take a jack-hammer to blast through the problem. But even outside that it can be useful as this talk will discuss.\r\n\r\n[ExprTools.jl](https://github.com/invenia/ExprTools.jl) was created to hold a more robust version of `splitdef` and `combinedef` from [MacroTools.jl](https://github.com/FluxML/MacroTools.jl).\r\n`splitdef` takes the AST for a method definition and outputs a dictionary of all the parts: name, args, whereparams, body etc. `combinedef` does the reverse: taking such a dictionary, and outputting an AST that declares the method.\r\n`splitdef` is very useful since it both handles different equivalent syntax forms, and makes the key parts accessible in a consistent way.\r\nThis makes it easier to write function decorator macros, and also macros that let the user write something that looks like a function but is actually transformed into something else.\r\nThis dictionary is also useful, and it would be great if we could define it not from an AST but from a method that has already been defined. We could access all the information we need via reflection. This is exactly what the `signature` function provides.\r\n\r\nThe `signature` function takes in a `Method` object, which can be obtained from `methods` or `methodswith`, and returns a dictionary like `splitdef` would, except it excludes the body.\r\nExcluding the body is generally not useful for this kind of generated code anyway since the user will generally want to fill the body with their own code that calls the method we are generating from. One exampl. Another example is generating overloaded operators for overloading-based reverse mode AD from [ChainRules.jl](https://github.com/JuliaDiff/ChainRules.jl/)\u2019s rrule.\r\n\r\nThe main alternative for this kind of approach is something along the lines of [Cassette.jl](https://github.com/JuliaLabs/Cassette.jl), which in effect allows the overloading of what it means to call a function. There are three key differences of an ExprTools-based generation from reflection approach over a Cassette-based overdubbing approach.\r\n\r\nOverdubbing occurs in a specific dynamically scoped context, method generation applies globally.\r\nA downside of method generation is that it will not detect new methods added after the generation is performed, overdubbing does.\r\nAn upside of method generation is that it is just plain julia code, so it doesn\u2019t break the compiler\u2019s ability to do type inference. The compiler is completely prepared to deal with julia-code. This is (sadly, but demonstrably) not true for Cassette right now.\r\n\r\n\r\nThis talk will spend ~3 minutes time covering the basics of ExprTools, with `splitdef` and `combine`. It will spend 4 minutes demonstrating `signature` and the generation of methods from the methods tables. It will spend ~1 minutes peeking under the covers as to how it works.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1095, "code": "ECUZBT", "public_name": "Lyndon White", "biography": "Lyndon White (@oxinabox) is a research software engineer at Invenia Labs (Cambridge, UK). He helps researchers use machine learning, constrained optimization, and generally tools from the technical computing domain to optimize the power grid. He get to do all the best parts of being a software developer and all the best parts of being a researcher, its great.\r\nHe works a lot on the Julia AutoDIff code, and is the leader of the ChainRules project.", "answers": []}], "links": [], "attachments": [], "answers": []}], "BoF/Mini Track": [{"id": 9812, "guid": "6966357f-01e0-5a2f-a1ff-9b2824117a8a", "logo": "/media/juliacon2021/submissions/N7REEK/juliastreamer_9aF75GY.jpg", "date": "2021-07-29T12:30:00+00:00", "start": "12:30", "duration": "01:30", "room": "BoF/Mini Track", "slug": "juliacon2021-9812-live-coding-outreach-and-beyond", "url": "https://pretalx.com/juliacon2021/talk/N7REEK/", "title": "Live Coding: Outreach and Beyond", "subtitle": "", "track": null, "type": "Birds of Feather", "language": "en", "abstract": "The goal of this session is to gather people interested in streaming their programming sessions. Streaming code is a particular exercise, we want to foster the exchange of best practices, tips and thoughts. In particular, we would like to see to which extent Julia streamers have managed to reach an audience beyond the Julia community, used streams as a teaching medium and how we can improve the formats to make it more accessible to newcomers. The BoF is not limited to streamers, people watching", "description": "Live streaming is a recent phenomena that has seen huge growth due to services such as Twitch, Youtube Live, and Facebook Live. Although this burgeoning community\u2019s focus is generally on video games, vlogs, and talk shows, a niche that is increasing in this community are educational streams. Examples of such streams are where students studying invite audiences to \u201cstudy with me\u201d or educators hosting ask me anything sessions. In particular, one area in this niche that is particularly relevant for the Julia community is live coding.\r\n\r\nLive coding is where software developers or programmers stream their programming development to a live audience. It can take many shapes where a developer works on an open source project, a coder is learning a new language, or an interactive back-and-forth to create a novel application. Live coding works as a sort of give and take relationship where streamers get the opportunity to make new connections and the audience gets to be exposed to new programming styles or learn new skills. Often, this works in the reciprocal as well.\r\n\r\nFor the Julia community, with the advent of the COVID19 pandemic, many individuals were suddenly left in a common, but highly unusual, circumstance. As many have experienced and are experiencing, the days of being in a work office setting and having passing conversations with colleagues have become somewhat distant memories. Instead, many find themselves at home behind their computers with their only company being either family, pets, or the whir of their computer\u2019s fan. In conjunction with this, the amount of interest in live streaming programming in the Julia community has been growing.\r\n\r\nIn this Birds of a Feather, we want to gather those people who have been live streaming within the Julia community and those interested in live streaming. In this gathering, streamers can share their ideas around best practices, tips and experiences in the streamer community. This could be a strong opportunity for the Julia community to also discuss how to reach and engage with people outside of the Julia community. Furthermore, this BoF could also lead to productive discussions on how to help within the Julia community whether that be in the form of increasing visibility to amazing Julia packages or leading teaching sessions. \r\n\r\nFinally, this BoF would also provide an open avenue for individuals who are interested in live streaming to freely ask questions. This could range from questions such as \u201cwhat is needed to get started as a streamer?\u201d to \u201chow do you build a great community around your stream?\u201d As a result, this can not only increase outreach from the Julia community but also foster new and meaningful connections one could make - especially in the pandemic era.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9292, "code": "WNALCB", "public_name": "Jacob Zelko", "biography": "My Name Is Jacob S. Zelko \u2013 Pleasure To Meet You!\r\n\r\nI am a graduate of Georgia Institute of Technology with a BS in biomedical engineering. While pursuing my BS, I worked as a data information specialist and biomedical informaticist in the Department of Biomedical Informatics at Emory University doing research in the areas of computational psychiatry and worked with The Center for Discovery as an engineering consultant to aid in caring for their juvenile neurocognitively diverse population. Currently, I work as a Health Data Analytics and Informatics Researcher at Georgia Tech Research Institute and as a Consultant with the Centers for Disease Control.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9826, "guid": "5c7e5e18-8a0c-5ca2-b411-69bb5b7baf71", "logo": "", "date": "2021-07-29T16:30:00+00:00", "start": "16:30", "duration": "00:45", "room": "BoF/Mini Track", "slug": "juliacon2021-9826-julia-in-high-performance-computing", "url": "https://pretalx.com/juliacon2021/talk/C3EBJM/", "title": "Julia in High-Performance Computing", "subtitle": "", "track": null, "type": "BoF (45 mins)", "language": "en", "abstract": "The JuliaHPC community as a group maintains the infrastructure for using Julia in high-performance computing. In this BoF we invite newcomers, application developers, and maintainers to join us for an informal discussion around the state of Julia in HPC.", "description": "# Agenda\r\n\r\n## Short presentations about ongoing projects\r\n- Ludovic R\u00e4ss & Sam Omlin: GPU4GEO and Julia HPC development at ETH Zurich\r\n- Simon Byrne: ClimateMachine.jl\r\n- Valentin Churavy: CESMIX-MIT\r\n- Johannes Blaschke: Julia@NERSC\r\n\r\n## Roundtable discussion\r\n- Julia in the DOE\r\n- Teaching HPC\r\n- MPI.jl\r\n- Challenges of running Julia at scale\r\n- Deploying Julia (Sysimages/Pkg/Depots/Artifacts/...)\r\n- **Your suggestion**", "recording_license": "", "do_not_record": false, "persons": [{"id": 903, "code": "3C7UBC", "public_name": "Valentin Churavy", "biography": "PhD Student at MIT", "answers": []}, {"id": 10161, "code": "ZBB3MC", "public_name": "Michael Schlottke-Lakemper", "biography": "I am a postdoctoral fellow and research software engineer at the [Numerical Simulation Research Group](https://www.mi.uni-koeln.de/NumSim) of the University of Cologne, Germany. My research focus is on numerical methods for adaptive multi-physics simulations, high-order schemes, and high-performance computing.", "answers": []}, {"id": 1131, "code": "PKSECG", "public_name": "Simon Byrne", "biography": "Simon is the lead software engineer at the [CliMA project](https://clima.caltech.edu/).", "answers": []}, {"id": 4153, "code": "R3SWQF", "public_name": "Carsten Bauer", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9710, "guid": "d00f5483-5653-5fe7-9dae-5a9d91de0088", "logo": "", "date": "2021-07-29T17:15:00+00:00", "start": "17:15", "duration": "00:45", "room": "BoF/Mini Track", "slug": "juliacon2021-9710-gpu-programming-in-julia-bof", "url": "https://pretalx.com/juliacon2021/talk/RXBMHE/", "title": "GPU programming in Julia BoF", "subtitle": "", "track": null, "type": "BoF (45 mins)", "language": "en", "abstract": "This is a BoF to talk about the various GPU programming packages in Julia:\r\n\r\n- CUDA.jl\r\n- AMDGPU.jl\r\n- oneAPI.jl\r\n- KernelAbstractions.jl\r\n- GPUArrays.jl\r\n- GPUCompiler.jl\r\n- ...\r\n\r\nIf you have any thoughts or questions about these packages, or other approaches to GPU programming in Julia, please join this BoF to chat about it!", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 2402, "code": "9YQMAK", "public_name": "Tim Besard", "biography": "I'm a software engineer at Julia Computing, working on Julia's GPU packages and compilers.", "answers": []}, {"id": 4385, "code": "GRFD9D", "public_name": "Julian P Samaroo", "biography": "I am an HPC software engineer working at the JuliaLab. I maintain Dagger.jl, AMDGPU.jl, and BPFnative.jl, and generally enjoy the challenge of hacking on compilers and HPC runtimes.", "answers": []}, {"id": 903, "code": "3C7UBC", "public_name": "Valentin Churavy", "biography": "PhD Student at MIT", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9791, "guid": "7efd6f88-0f5c-592d-8d5a-3a16eff78d1d", "logo": "", "date": "2021-07-29T19:00:00+00:00", "start": "19:00", "duration": "01:30", "room": "BoF/Mini Track", "slug": "juliacon2021-9791-julia-in-private-organizations", "url": "https://pretalx.com/juliacon2021/talk/GWRZPV/", "title": "Julia in Private Organizations", "subtitle": "", "track": null, "type": "Birds of Feather", "language": "en", "abstract": "Using Julia code within private organizations can encounter challenges not faced in the open-source community. In this BoF, we'll be discussing the unique aspects of using Julia in private organizations and cover topics such as: production deployments, tooling/ techniques for teams coding in Julia, and answering questions regarding transition/adopting Julia within an organization.", "description": "Every private organization works slightly differently with how they operate and the internal tooling they use. As Julia users who work in private organizations we'll use this BoF as an opportunity to discuss the unique challenges we've faced while using Julia within our organizations and how we've solved them. This BoF is suitable for members of private organizations which already are established in using Julia and advocates pushing for Julia to be adopted.\r\n\r\nDiscussion points will include:\r\n\r\n- Are you using repository hosting besides GitHub? Have you faced any challenges with integrating open-source tools? (e.g. CI tooling, GitHub specific tools)\r\n- Did you face any challenges when setting up a private Julia package registry?\r\n- What tooling to you use to assist with new package registry entries? (e.g. Bots, RegistryCI.jl)\r\n- How do you keep private code up to date with public dependencies? (e.g. major version changes, deprecations, etc.)\r\n- How does Julia fit into your production environment? A service, batch job, etc.\r\n- What cloud infrastructure do you use for running distributed Julia?\r\n- Solutions for containerizing Julia: shared base images, optimizing startup time, etc.\r\n- Procedures for moving closed-source to open-source?\r\n- Advice for adopting Julia within an organization\r\n\r\nHopefully, this BoF will allow different organizations using similar tooling/techniques to connect and work together. The result of this could be an improved workflow experience for these organizations and ideally a much smoother transition for those organizations just starting to adopt Julia.", "recording_license": "", "do_not_record": false, "persons": [{"id": 2401, "code": "AQLMAC", "public_name": "Curtis Vogt", "biography": "I have been working with Julia since 2015 and have made a variety of contributions to the ecosystem. I am a member of the Julia Community Prize committee and work for Beacon Biosignals as a Principal Software Architect.", "answers": []}], "links": [], "attachments": [], "answers": []}], "JuMP Track": [{"id": 10874, "guid": "d59287df-7665-5692-b475-eded6e73b122", "logo": "", "date": "2021-07-29T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10874-the-design-of-the-minizinc-modelling-language", "url": "https://pretalx.com/juliacon2021/talk/3BBA7L/", "title": "The Design of the MiniZinc Modelling Language", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In this talk, we discuss the design of MiniZinc, a leading Constraint modelling language.", "description": "MiniZinc was designed with the aim to become a 'standard' Constraint Programming modelling language. As such, it is oriented towards logical and combinatorial constraints standardized in the Global Constraints Catalogue, but also supports continuous variables. The most important design criteria were expressiveness, while at the same time simplicity for practical implementation, and mechanisms for easy plugging of new solvers. The solver interface incorporates a low-level language FlatZinc (aka MPS for example), and a redefinition scheme for global constraints. The latter enables native handling of globals supported by a given solver, while applying default or solver-specific redefinitions for unsupported ones. Other solver technologies, such as SAT, local search, and MIP, have been interfaced, and several experimental interfaces exist, such as to quantum computing. The modelling system has enabled the annual solver competition MiniZinc Challenge since 2008.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11328, "code": "DHETLD", "public_name": "Gleb Belov", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10881, "guid": "655df93b-e286-5844-be9f-1dbb9127bd2e", "logo": "", "date": "2021-07-29T13:00:00+00:00", "start": "13:00", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10881-constraintsolver-jl-first-constraint-solver-written-in-julia", "url": "https://pretalx.com/juliacon2021/talk/9KTFNJ/", "title": "ConstraintSolver.jl - First constraint solver written in Julia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In this talk we discuss ConstraintSolver.jl, a new Julia package to tackle the problem of solving constraint programming problems purely in Julia.", "description": "Constraint programming is used in a variety of fields ranging from simple puzzle solving to big instances in industry. Currently Julia does not have a package for constraint programming and JuMP itself is in the beginning of implementing constraints and variable sets to support constraint solvers in the future. ConstraintSolver.jl is a new Julia package to tackle the problem of solving constraint programming problems purely in Julia. This has advantages for prototyping new ideas which is harder to do in low level languages like C or C++. Additionally the solver will be able to solve problems with different types than just integers and floating point numbers i.e. an integration with Unitful.jl will be possible. Another advantage of a solver purely written in Julia is to easily use automatic differentiation.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10366, "code": "9ZGBBL", "public_name": "Ole Kr\u00f6ger", "biography": "I'm a master student in computer science in Heidelberg, Germany. I like to teach and blog about programming especially about Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10869, "guid": "9bf487b4-a594-5a57-9e8f-72204f681b0b", "logo": "", "date": "2021-07-29T13:30:00+00:00", "start": "13:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10869-constraintprogrammingextensions-jl", "url": "https://pretalx.com/juliacon2021/talk/EHUKWK/", "title": "ConstraintProgrammingExtensions.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "ConstraintProgrammingExtensions.jl is a project bringing constraint programming to JuMP. Its main part is a large series of constraints that aim at providing a common interface for constraint-programming solvers. It also consists of a series of bridges that define relationships between those sets (including between high-level constraints such as knapsacks and mathematical-programming formulations) and of a FlatZinc reader-writer to import and export models in that common format.", "description": "Constraint programming is a modelling paradigm that has proved to be extremely useful in many real-world scenarios, like computing optimum schedules or vehicle routings. It is often viewed as either a complementary or a competing technology to mathematical programming, trading modelling ease with computational efficiency. Both approaches have seen many developments in terms of modelling language and solvers alike, including in Julia. Even though several constraint-programming solvers are available (or entirely written) in Julia, [JuMP and MathOptInterface](https://jump.dev/) (its solver abstraction layer) do not give access to them in the same, unified way as mathematical programming, though the latest versions of JuMP have been designed to provide great flexibility. \r\n\r\n[ConstraintProgrammingExtensions](https://github.com/dourouc05/ConstraintProgrammingExtensions.jl) is currently a one-man project bringing constraint programming to JuMP. Its main part is a large series of sets that aim at providing a common interface for constraint-programming solvers. It also consists of a series of bridges that define relationships between those sets (including between high-level constraints such as knapsacks and mathematical-programming formulations) and of a [FlatZinc](https://www.minizinc.org/) reader-writer to import and export models in that common format, already supported by tens of solvers. As a side effect, ConstraintProgrammingExtensions is also becoming a way to ease modelling for mathematical programming, as high-level constraints can be used with traditional mathematical-programming solvers. \r\n\r\nThis presentation details the current state of ConstraintProgrammingExtensions, some of its design decisions, and future developments when JuMP and MathOptInterface do not provide sufficient versatility: for instance, several constraint-programming solvers allow graphs as first-class decision variables; also, constraint programming is not restricted by the linearity or the convexity of mathematical expressions, unlike many mathematical-programming solvers.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11323, "code": "EVRZ99", "public_name": "Thibaut Cuvelier", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10863, "guid": "4dd41b7b-7f7e-5f23-bd6f-399846fe9cf4", "logo": "", "date": "2021-07-29T16:30:00+00:00", "start": "16:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10863-nonlinear-programming-on-the-gpu", "url": "https://pretalx.com/juliacon2021/talk/P8KJSW/", "title": "Nonlinear programming on the GPU", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "So far, most nonlinear optimization modelers and solvers have primarily targeted CPU architectures. However, with the emergence of heterogeneous computing architectures, leveraging massively parallel accelerators in nonlinear optimization has become crucial for performance. As part of the Exascale Computing Project ExaSGD, we are studying how to efficiently run nonlinear optimization algorithms at exascale using GPU accelerators.", "description": "This talk walks over our recent experiences in our development efforts. The parallel layout of GPUs requires running as many operations as possible in batch mode, in a massively parallel fashion. We will detail how we have adapted the automatic differentiation, the linear algebra and the optimization solvers in a batch setting and present the different challenges we have addressed. Our efforts have led to the development of different prototypes, all addressing a specific issue on the GPU: ExaPF for batch automatic differentiation, ExaTron as a batch optimization solver, ProxAL for distributed parallelism. The future research opportunities are manyfold for the nonlinear optimization community: how can we leverage new automatic differentiation backends developed in the machine learning community for optimization purpose? How can we exploit the Julia language to develop a vectorized nonlinear optimization modeler targeting massively parallel accelerators?", "recording_license": "", "do_not_record": false, "persons": [{"id": 4450, "code": "WC3WU3", "public_name": "Fran\u00e7ois Pacaud", "biography": "Fran\u00e7ois Pacaud is a postdoctoral appointee at Argonne National Lab, supervised by Mihai Anitescu. His work focuses on the development of new nonlinear optimization algorithms on GPU architectures.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10866, "guid": "b71ca502-9d50-5e46-a8df-18bdc7856d5d", "logo": "", "date": "2021-07-29T17:00:00+00:00", "start": "17:00", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-10866-madnlp-jl-a-mad-nonlinear-programming-solver-", "url": "https://pretalx.com/juliacon2021/talk/A3Z33C/", "title": "MadNLP.jl: A Mad Nonlinear Programming Solver.", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We present a native-Julia nonlinear programming (NLP) solver MadNLP.jl. This solver implements the filter line-search interior-point method for constrained NLPs; to the best of our knowledge, MadNLP is currently the only native-Julia solver that is capable of handling general nonlinear equality/inequality-constrained optimization problems. MadNLP is interfaced with the algebraic modeling language JuMP.jl, the graph-based modeling language Plasmo.jl, and the NLP data structure NLPModels.jl.", "description": "MadNLP leverages diverse sparse and dense linear algebra routines: UMFPACK, HSL routines, MUMPS, Pardiso, LAPACK, and cuSOLVER. The key feature of MadNLP is the adoption of scalable linear algebra methods: structure-exploiting parallel linear algebra (based on restricted additive Schwarz and Schur complement strategy) and GPU-based linear algebra (cuSOLVER). These methods significantly enhance the scalability of the solver to large-scale problem instances (e.g., long-horizon dynamic optimization, stochastic programs, abd dense NLPs). Furthermore, MadNLP exploits Julia's extensibility so that new linear solvers can be added in a plug-and-play manner. In the presentation, we will present benchmark results against other open-source and commercial solvers as well as the results highlighting MadNLP's advanced features. Our results suggest that (i) MadNLP has comparable speed and robustness with Ipopt/KNITRO when tested against the standard benchmark test set (CUTEst); (ii) MadNLP with structure-exploiting parallel linear algebra can achieve speed-up up of a factor of 3 when solving large-scale sparse nonlinear programs; and (iii) GPU-acceleration achieves the speed-up of a factor of 10 when solving dense nonlinear optimization problems. The presentation will conclude with a future development roadmap, including the implementation of distributed-memory parallelism and pure-GPU solver.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11320, "code": "LTCS8H", "public_name": "Sungho Shin", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10865, "guid": "f0ef9e67-100b-5f80-8ad2-f60040e15a12", "logo": "", "date": "2021-07-29T17:10:00+00:00", "start": "17:10", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-10865-nonconvex-jl", "url": "https://pretalx.com/juliacon2021/talk/MVCXHB/", "title": "Nonconvex.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Nonconvex.jl is a package that aims to interface all the major nonlinear and mixed integer nonlinear programming packages in Julia using a function-based API. Zygote.jl is used for automatic differentiation (AD) and ChainRules.jl can be used to define analytic gradients or custom adjoint rules for functions. Ipopt.jl, NLopt.jl, Percival.jl and Juniper.jl are some of the packages wrapped in Nonconvex.jl as of the writing of this abstract.", "description": "The method of moving asymptotes is also natively implemented in the package. The first order augmented Lagrangian algorithm implemented in Percival.jl is particularly suitable for the AD-based approach because efficient adjoint rules of block constraints can be used when calculating the gradient of the augmented Lagrangian instead of computing the entire Jacobian of the constraint functions. The nice thing about having a function-based API is that registering functions with JuMP.jl and splatting inputs are not needed anymore thus simplifying the nonlinear and mixed integer nonlinear optimization interface. Future work includes using ModelingToolkit.jl to reverse-engineer the objective and constraint functions, generating mathematical expressions where possible thus allowing the use of expression-based nonlinear and mixed integer nonlinear solvers such as Alpine.jl.", "recording_license": "", "do_not_record": false, "persons": [{"id": 3814, "code": "PFTTSC", "public_name": "Mohamed Tarek", "biography": "A topology optimization researcher, a co-maintainer of Turing.jl, a scientist at Pumas-AI, and an enthusiastic learner of anything \"scientific computing\".", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10879, "guid": "a22dcd20-47b1-5307-b1b8-4c5347408ed7", "logo": "", "date": "2021-07-29T17:20:00+00:00", "start": "17:20", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-10879-nomad-jl", "url": "https://pretalx.com/juliacon2021/talk/UZJWTT/", "title": "NOMAD.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "The NOMAD software is a derivative-free solver which implements the mesh adaptive direct search algorithm. Its purpose is to solve constrained problems where the objective and the functions defining the constraints correspond to the outputs of a program seen as a blackbox. This talk aims at presenting the NOMAD.jl interface to Julia, linked to the JuMP modeling language. Some applications will also be exposed.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 11333, "code": "QXEXMD", "public_name": "Ludovic Salomon", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10878, "guid": "5513e015-d2e4-5434-a010-4b548f46aad8", "logo": "", "date": "2021-07-29T17:30:00+00:00", "start": "17:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10878-linearly-constrained-separable-optimization", "url": "https://pretalx.com/juliacon2021/talk/FGUEAM/", "title": "Linearly Constrained Separable Optimization", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Many optimization problems involve minimizing a sum of univariate functions, each with a different variable, subject to coupling constraints.  We present [PiecewiseQuadratics.jl](https://github.com/JuliaFirstOrder/PiecewiseQuadratics.jl) and [SeparableOptimization.jl](https://github.com/JuliaFirstOrder/SeparableOptimization.jl), two Julia packages for solving such problems when these univariate functions in the objective are piecewise-quadratic.", "description": "***Note:*** *SeparableOptimization.jl was named \"LCSO.jl\" at the time of the presentation recording.*\r\n\r\n[PiecewiseQuadratics.jl](https://github.com/JuliaFirstOrder/PiecewiseQuadratics.jl) allows for the representation and manipulation of such functions, including the computation of the proximal operator or the convex envelope.  [SeparableOptimization.jl](https://github.com/JuliaFirstOrder/SeparableOptimization.jl) solves the problem of minimizing a sum of piecewise-quadratic functions subject to affine equality constraints by applying the Alternating Direction Method of Multipliers (ADMM).  This allows us to quickly solve problems even when the univariate functions are very complicated.  We demonstrate this with a portfolio construction example, in which the univariate functions represent the US tax laws for realized capital gains.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11332, "code": "ZH8QUF", "public_name": "Ellis Brown", "biography": "Engineer at BlackRock AI Labs", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10864, "guid": "8c3e8d47-8253-5774-b10b-15837803413e", "logo": "", "date": "2021-07-29T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10864-nexos-jl-for-nonconvex-exterior-point-operator-splitting", "url": "https://pretalx.com/juliacon2021/talk/SWBYRL/", "title": "NExOS.jl for Nonconvex Exterior-point Operator Splitting", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "NExOS.jl is a Julia package that implements the Nonconvex Exterior-point Operator Splitting (NExOS) algorithm (https://arxiv.org/pdf/2011.04552.pdf). The package is tailored for minimizing a convex cost function over a nonconvex constraint set, where projection onto the constraint set is single-valued around local minima.", "description": "We consider the problem of minimizing a convex cost function over a nonconvex constraint set, where projection onto the constraint set is single-valued around points of interest. A wide range of nonconvex learning problems have this structure including (but not limited to) sparse and low-rank optimization problems.\r\n\r\nBy exploiting the underlying geometry of the constraint set, NExOS finds a locally optimal point by solving a sequence of penalized problems with strictly decreasing penalty parameters. NExOS solves each penalized problem by applying an outer iteration operator splitting algorithm, which converges linearly to a local minimum of the corresponding penalized formulation under regularity conditions. Furthermore, the local minima of the penalized problems converge to a local minimum of the original problem as the penalty parameter goes to zero.\r\n\r\nNExOS.jl has been extensively tested on many instances from a wide variety of learning problems. In spite of being general-purpose, NExOS is able to compute high-quality solutions very quickly and is competitive with specialized algorithms.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11319, "code": "T8F8UF", "public_name": "Shuvomoy Das Gupta", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10873, "guid": "37701557-4320-5b96-b255-d39860a35a91", "logo": "", "date": "2021-07-29T19:30:00+00:00", "start": "19:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10873-global-constrained-nonlinear-optimisation-with-interval-methods", "url": "https://pretalx.com/juliacon2021/talk/BR7WG8/", "title": "Global constrained nonlinear optimisation with interval methods", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We will present recent work in progress on guaranteed methods for inequality-constrained *global* nonlinear optimization in Julia. Using methods based on interval arithmetic allows us to guarantee (prove) that we return the true global minimum and minimizers for inequality-constrained optimization problems in low dimensions.", "description": "Interval arithmetic provides a computationally-cheap way to compute an over-estimate of the range of a function over an input set. These estimates are guaranteed to be correct (mathematically rigorous), even\r\nthough the computations are done using floating-point arithmetic, by using directed rounding.\r\n\r\nThis kind of range bounding can be used to design a conceptually-simple algorithm for guaranteed unconstrained global optimization, as in the talk presented at JuMP-dev Chile in 2019.\r\nIn this talk we show how to extend this to constrained optimization.\r\n\r\nFirst we show how both the objective function and constraints can be modelled using symbolic expressions from the Symbolics.jl library. Based on these symbolic expressions we have a  new implementation of interval constraint propagation, as implemented in the ReversePropagation.jl library, including common subexpression elimination.\r\n\r\nOne main difficulty in interval-based inequality-constrained optimization is deciding when a given box is feasible, i.e. satisfies all of the constraints. We have implemented what we believe to be a novel method to do so.\r\n\r\nThis is an extension to inequality-constrained optimization of th", "recording_license": "", "do_not_record": false, "persons": [{"id": 1022, "code": "TJJRTG", "public_name": "David P. Sanders", "biography": "Professor of Computational Science at the Universidad Nacional Aut\u00f3noma de M\u00e9xico and visiting professor at MIT.\r\n\r\nInterested in computational science, interval arithmetic, and numeric-symbolic computing.\r\n\r\nAuthor of the JuliaIntervals suite of packages for interval arithmetic, and various tutorials on Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}]}}, {"index": 11, "date": "2021-07-30", "day_start": "2021-07-30T04:00:00+00:00", "day_end": "2021-07-31T03:59:00+00:00", "rooms": {"Green": [{"id": 9814, "guid": "0d07a02f-8a36-55cb-813d-9ecaa0af0c13", "logo": "", "date": "2021-07-30T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9814-calibration-analysis-of-probabilistic-models-in-julia", "url": "https://pretalx.com/juliacon2021/talk/8BWJXP/", "title": "Calibration analysis of probabilistic models in Julia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Calibrated probabilistic models ensure that predictions are consistent with empirically observed outcomes, and hence such models provide reliable uncertainty estimates for decision-making. This is particularly important in safety-critical applications. We present Julia packages for analyzing calibration of general probabilistic predictive models, beyond commonly studied classification models. Additionally, our framework allows to perform statistical hypothesis testing of calibration.", "description": "**The Pluto notebook of this talk is available at https://talks.widmann.dev/2021/07/calibration/**\r\n\r\nThe talk focuses on:\r\n- introducing/explaining calibration of probabilistic models\r\n- discussing/showing how users can apply the offered evaluation measures and hypothesis tests\r\n- highlighting the relation to the Julia ecosystem, in particular to packages such as KernelFunctions and HypothesisTests and interfaces via pyjulia (Python) and JuliaCall (R)\r\n\r\nProbabilistic predictive models, including Bayesian and non-Bayesian models, output probability distributions of targets that try to capture uncertainty inherent in prediction tasks and modeling. In particular in safety-critical applications, it is important for decision-making that the model predictions actually represent these uncertainties in a reliable, meaningful, and interpretable way.\r\n\r\nA calibrated model provides such guarantees. Loosely speaking, if the same prediction would be obtained repeatedly, then it ensures that in the long run the empirical frequencies of observed outcomes are equal to this prediction. Note that usually it is not sufficient if a model is calibrated though: a constant model that always outputs the marginal distribution of targets, independently of the inputs, is calibrated but probably not very useful.\r\n\r\nCommonly, calibration is analyzed for classification models, often also in a reduced binary setting that focuses on the most-confident predictions only. Recently, we published a framework for calibration analysis of general probabilistic predictive models, including but not limited to classification and regression models. We implemented the proposed methods for calibration analysis in different Julia packages such that users can incorporate them easily in their evaluation pipeline.\r\n\r\n[CalibrationErrors.jl](https://github.com/devmotion/CalibrationErrors.jl) contains estimators of different calibration measures such as the expected calibration error (ECE) and the squared kernel calibration error (SKCE). The estimators of the SKCE are consistent, and both unbiased and unbiased estimators exist. The package uses kernels from KernelFunctions.jl, and hence many standard kernels are supported automatically.\r\n\r\n[CalibrationTests.jl](https://github.com/devmotion/CalibrationTests.jl) implements statistical hypothesis tests of calibration, so-called calibration tests. Most of these tests are based on the SKCE and can be applied to any probabilistic predictive model.\r\n\r\nFinally, the package [CalibrationErrorsDistributions.jl](https://github.com/devmotion/CalibrationErrorsDistributions.jl) extends calibration analysis to models that output probability distributions from Distributions.jl. Currently, Gaussian distributions, Laplace distributions, and mixture models are supported.\r\n\r\nTo increase the adoption of these calibration evaluation techniques by the statistics and machine learning communities, we also published interfaces to the Julia packages in [Python](https://github.com/devmotion/pycalibration) and [R](https://github.com/devmotion/rcalibration).\r\n\r\n### References\r\n\r\nWidmann, D., Lindsten, F., & Zachariah, D. (2019). Calibration tests in multi-class classification: A unifying framework. In Advances in Neural Information Processing Systems 32 (NeurIPS 2019) (pp. 12257\u201312267).\r\n\r\nWidmann, D., Lindsten, F., & Zachariah, D. (2021). Calibration tests beyond classification. International Conference on Learning Representations (ICLR) 2021.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1081, "code": "BKDQGH", "public_name": "David Widmann", "biography": "I am a PhD student at the [Division of Systems and Control](https://www.it.uu.se/research/systems_and_control) within the [Department of Information Technology](https://www.it.uu.se) and the [Centre for Interdisciplinary Mathematics](https://www.math.uu.se/CIM) in Uppsala, supervised by [Fredrik Lindsten](https://liu.se/en/employee/freli29), [Dave Zachariah](http://www.it.uu.se/katalog/davza513), and Erik Sj\u00f6blom. The main focus of my PhD studies is [uncertainty-aware deep learning](http://www.math.uu.se/digitalAssets/396/c_396868-l_1-k_lindsten.pdf). Currently, I am particularly interested in analyzing and evaluating [calibration](https://en.wikipedia.org/wiki/Calibration_(statistics)) of probabilistic models. Please visit [my webpage](https://widmann.dev/research/) for more information.\r\n\r\n[My GitHub profile](https://github.com/devmotion/) provides an overview of my contributions to the Julia ecosystem. Currently, I am a member of the [steering council of SciML](https://sciml.ai/governance.html) and the [Turing team](https://turing.ml/dev/team/).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9630, "guid": "19e11b00-13f0-5b00-b2be-929412898ffc", "logo": "/media/juliacon2021/submissions/WWP7DR/SciModel-01_ol5RxM1.png", "date": "2021-07-30T13:10:00+00:00", "start": "13:10", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9630-sciml-for-structures-predicting-bridge-behavior", "url": "https://pretalx.com/juliacon2021/talk/WWP7DR/", "title": "SciML for Structures: Predicting Bridge Behavior", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We study the utility of a scientific machine learning (SciML) model for predicting structural responses such as bridge deflections and stresses.  The SciML model is compared with a data-driven neural network model for a synthetic and a real world case.In both cases, we rely on the Julia algorithmic differentiation ecosystem to efficiently fit the models. Our preliminary results indicate the superiority of the SciML mode over the data-driven one in interpolation and extrapolation as well.", "description": "Structures in civil engineering are traditionally modelled using the finite element (FE) method. Although it is an extremely successful method, it has some shortcomings: (i) it can require substantial human effort to build complex models; and (ii) it can be difficult to combine with measurement data in order to increase model prediction accuracy. A way to overcome these shortcomings is to use data-driven machine learning approaches, however these may require a prohibitive amount of measurement data and still perform poorly in extrapolation. Combining the machine learning model with scientific knowledge, i.e. scientific machine learning (SciML), may offer a practically tenable solution to the above challenges.\r\n\r\nThis talk aims to explore to what extent a scientific machine learning model can predict the structural response of a twin girder bridge in comparison with a data-driven machine learning model. The two approaches are compared with regards to prediction accuracy as well as the amount of data needed to achieve a particular accuracy. The comparison is made by using a synthetic case and a real-world case with field measurements.\r\n\r\nThe scientific machine learning model requires a formulation of the physics, which can be done in different manners. In engineering practice the structural behavior of bridges is typically described/predicted by FE models. For the SciML physics formulation we selected a simplified 2D beam model made up of 4-degrees-of-freedom linear elastic beam elements. This simple 2D-model is chosen in order to explore a very fast modelling workflow, potentially expandable to a digital tool for quick structural assessment. The 2D model is combined with a neural network in order to approximate the 3D bridge behavior. The neural network achieves this by representing a transverse load distribution function that describes what percentage of a concentrated load at a certain location is carried by the modelled 2D girder. As the bridge is composed of two identical girders, the rest of the load is assumed to be carried by the second girder. We do not take shear lag effects into account in our physics formulation. \r\n\r\nThe loss for the SciML model was calculated in three steps: first, the load on the 2D beam was determined by the neural network, second, the structural system is solved for this predicted load and sensor position, finally the loss is calculated using the difference of the predicted structural responses and the measured ones.\r\n\r\nFor the data-driven model, a feedforward neural network tries to directly predict the structural response of the 2D girder for a certain sensor and load location. The difference between this prediction and the measured data is used to calculate the loss for the training of the neural network.\r\n\r\nWe chose to make the implementation of the SciML model in Julia because of its many attractive features, such as multiple dispatch and packages for automatic differentiation (e.g. Zygote.jl) and machine learning (e.g. Flux.jl). For the FE package, we wanted a lightweight, hackable package that would be easy to get started with, in order to provide a fast workflow. It was also desirable to have a 100% Julia written FE package, in order to fully utilize Zygote for backpropagating the FE solutions. We chose CALFEM.jl, a Julia port of the CALFEM package, originally developed in the late 1970s at Lund University in Sweden and subsequently improved over the decades, today typically used for teaching simple FE programming. CALFEM.jl lacks support for automatic differentiation, but because of the many favorable features of Julia, it was a quite simple task to implement AD support for the components that we needed. The source code of the analysis will be made open to the public.\r\n\r\n\r\n\r\nThe results show that a SciML approach can accurately predict structural behavior of the bridge using far less data points than a purely data driven approach. Moreover, the SciML approach is much better in extrapolation than the purely data-driven one. Our results show that at the moment purely data-driven approaches are impractical to predict structural responses and SciML seems to be a very promising addition to the toolbox of structural modelling approaches.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10256, "code": "KGLG9D", "public_name": "Axel Larsson", "biography": "Hi there! My name is Axel and I'm an intern at TNO, the Netherlands Organisation for Applied Scientific Research, working with Scientific Machine Learning for predicting structural responses. The internship is a part of my master thesis at University College London.\r\n\r\nMy fields of interest are computational structural engineering and computational design. Over the years, I've become more interested in more computing related topics like HPC, parallell processing and machine learning. This fall, I will move to the U.S. to start my PhD in Civil Engineering at Princeton University. I'm very interested in Julia for my future research and seeking collaborators in the Julia community.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9704, "guid": "b421e725-8850-5695-bdfb-e7da05e4c0da", "logo": "/media/juliacon2021/submissions/NVSXHU/sim_state4_mfZYtLf.png", "date": "2021-07-30T13:20:00+00:00", "start": "13:20", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9704-simulating-a-public-transportation-system-with-openstreetmapx-jl", "url": "https://pretalx.com/juliacon2021/talk/NVSXHU/", "title": "Simulating a public transportation system with OpenStreetMapX.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We will show how to perform modeling and of an urban network using the OpenStreetMapX.jl package. With actual Toronto data we will show how the library can be used for commuter routing including sidewalks and public transportation. We represent the city\u2019s urban space as a LightGraphs.jl strongly connected, directed graph where vertices are located at geographic coordinates. Additionally, we will also demonstrate a simulation model explaining the role of public transportation in virus widespread.", "description": "*Co-authors: Nykyta Polituchyi, Kinga Siuta, Pawe\u0142 Pra\u0142at*\r\n\r\nThe  [OpenStreetMapX.jl](https://github.com/pszufe/OpenStreetMapX.jl) package is capable of parsing [*.osm](https://wiki.openstreetmap.org/wiki/OSM_file_formats) formatted data from the [OpenStreetMap.org](https://www.openstreetmap.org/) project. This data can be subsequently utilized to extract information about city\u2019s POIs (points of interest), measure actual distances, perform routing and build numerical simulation model that make it possible to understand dynamics of a city. Those capabilities will be illustrated with a map of Toronto and show how to extend the osm data with other sources to extend the city routing beyond cars and sidewalks and model an actual public transportation network. \r\n\r\nIn this presentation two interconnected applications of the The OpenStreetMapX.jl package will be presented. Firstly, mixed routing combining different means of transportation will be presented and discussed showing how different Julia libraries can work together towards a common goal (including [OpenStreetMapXPlot](https://github.com/pszufe/OpenStreetMapX.jl), [LightGraphs](https://github.com/JuliaGraphs/LightGraphs.jl),  PyCall, Plots, DataFrames and others). Secondly, an agent-based simulation of a public transportation system will be discussed. We will show how to model and measure the impact of availability and frequency of public transportation onto decisions made by commuters and subsequently its contribution towards spreading the pandemic. \r\n\r\nThe presentation is accompanied by a Jupyter notebook that is available since on the [OpenStreetMapX.jl GitHub project website](https://github.com/pszufe/OpenStreetMapX.jl) since the first day of JuliaCon 2021. \r\n\r\nIn summary, in this talk the following areas will be discussed:\r\n\r\n-\tprocessing of OpenStreetMap data in Julia to obtain graph structures for processing with LightGraphs.jl\r\n-\tvisualizing graphs, maps and spatial data with OpenStreetMapXPlot.jl (GR, PyPlot backends) as well as integration with Leaflet via folium and PyCall\r\n-\tbuilding animations of a city using OpenStreetMapXPlot.jl combined with the `Plots.@animate` macro \r\n-\tusing Julia to augment OSM map data with external sources in order to build routing mechanism that can include public transportation (metro, streetcarts)\r\n-\tcombine this all into an agent simulation that can be used to model how the frequency and availability of a public urban transportation system contributes to the development of pandemic \r\n\r\n*The research is financed by a NSERC, Canada, \u201cAlliance COVID-19\u201d grant titled: \"COVID-19: Agent-based framework for modelling pandemics in urban environment\u201d.*", "recording_license": "", "do_not_record": false, "persons": [{"id": 1089, "code": "HNA89P", "public_name": "Przemys\u0142aw Szufel", "biography": "Przemys\u0142aw Szufel is an Assistant professor at SGH Warsaw School of Economics, Poland and an     Adjunct Professor, Cybersecurity Research Lab, Ted Rogers School of Management, Ryerson University, Toronto. \r\n\r\nHe has first started using Julia at the version 0.3. He is a co-author of the book \u201cJulia 1.0 Programming Cookbook: Over 100 numerical and distributed computing recipes for your daily data science work\ufb02ow\u201d which has been translated by O\u2019Reilly from English to Japanese. Przemys\u0142aw also holds currently 4-th place on the StackOverflow portal answering Julia-related questions. He is the maintainer and co-auhtor of three Julia libraries in the public repository: [OpenStreetMapX](https://github.com/pszufe/OpenStreetMapX.jl),   [OpenStreetMapXPlot](https://github.com/pszufe/OpenStreetMapXPlot.jl) and [SimpleHypergraphs](https://github.com/pszufe/SimpleHypergraphs.jl). \r\n He is a co-author of over 40 publications, including handbooks and journal papers, in the area of applying advanced analytics, machine learning, simulation methods and optimization.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9219, "guid": "6c5048a6-f5be-5ccf-a104-9061c023ab7c", "logo": "", "date": "2021-07-30T13:30:00+00:00", "start": "13:30", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9219-juliasim-machine-learning-accelerated-modeling-and-simulation", "url": "https://pretalx.com/juliacon2021/talk/ETY3B7/", "title": "JuliaSim: Machine Learning Accelerated Modeling and Simulation", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Julia is known for its speed, but how can you keep making things faster after all of the standard code optimization tricks run out? The answer is machine learning reduced or approximate models. JuliaSim is an extension to the Julia SciML ecosystem for automatically generating machine learning surrogates which accurately reproduce model behavior.", "description": "Julia is known for its speed, but how can you keep making things faster after all of the standard code optimization tricks run out? The answer is machine learning reduced or approximate models. JuliaSim is an extension to the Julia SciML ecosystem for automatically generating machine learning surrogates which accurately reproduce model behavior. In this talk we will showcase how you can take your existing ModelingToolkit.jl models and automate the model order reduction of its components. By hooking into the hierarchical modeling ecosystem, this allows for using the same surrogate across many models without requiring retraining. We will show the benefits of this process on energy efficient building design, which has been accelerated by orders of magnitude over the Dymola Modelica implementation, by using neural surrogatized HVAC models. We will demo simultaneous translation and acceleration of components designed outside of Julia through JuliaSim's ability to take in Functional Markup Units (FMUs) from Modelica and Simulink, along with domain-specific modeling definitions like SPICE netlists of electrical circuits and Pumas pharmacometic models. Similarly, this system allows for generating digital twins of real objects through its measurements, allowing one to quickly incorporate components with less physical understanding directly through its data. We will show a JuliaHub-based parallelized training platform that allows offloading the training process to the cloud. This will allow for engineers to pull pre-accelerated models from the ever growing JuliaSim Model Store directly into their Julia-based designs for fast exploration. Together this will leave the audience ready to integrate ML-accelerated modeling and simulation tools into their workflows.", "recording_license": "", "do_not_record": false, "persons": [{"id": 904, "code": "WUWQQ3", "public_name": "Chris Rackauckas", "biography": "Chris Rackauckas is an Applied Mathematics Instructor at MIT and the Director of Scientific Research at Pumas-AI. He is the lead developer of the SciML open source scientific machine learning organization which develops widely used software for scientific modeling and inference. One such software is DifferentialEquations.jl for which its innovative solvers won an IEEE Outstanding Paper Award and the inaugural Julia Community Prize. Chris' work on high performance differential equation solving is seen in many applications from the MIT-CalTech CLiMA climate modeling initiative to the SIAM DSWeb award winning DynamicalSystems.jl toolbox. Chris is also the creator of Pumas, the foundational software of Pumas-AI for nonlinear mixed effects modeling in clinical pharmacology. These efforts on Pumas led to the International Society of Pharmacology's (ISoP) Mathematical and Computational Special Interest Group Award at the American Conference of Pharmacology (ACoP) 2019 for his work on improved clinical dosing via Koopman Expectations, along with the ACoP 2020 Quality Award for his work on GPU-accelerated nonlinear mixed effects modeling via generation of SPMD programs. For this work in pharmacology, Chris received the Emerging Scientist award from ISoP in 2020, the highest early career award in pharmacometrics.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11702, "guid": "a33b29c9-4e8b-58af-9485-0e3ed8fed6d7", "logo": "", "date": "2021-07-30T14:30:00+00:00", "start": "14:30", "duration": "00:45", "room": "Green", "slug": "juliacon2021-11702-keynote-soumith-chintala-", "url": "https://pretalx.com/juliacon2021/talk/S3RH8Z/", "title": "Keynote (Soumith Chintala)", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Keynote", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 11705, "guid": "e7021969-def6-551b-9e75-6716626236d6", "logo": "", "date": "2021-07-30T15:15:00+00:00", "start": "15:15", "duration": "00:10", "room": "Green", "slug": "juliacon2021-11705-sponsor-talk-relationalai", "url": "https://pretalx.com/juliacon2021/talk/8CMRGC/", "title": "Sponsor talk - RelationalAI", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Sponsor talk - RelationalAI", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 11703, "guid": "21f5f506-481d-5b74-a797-bcdd5c9c369f", "logo": "/media/juliacon2021/submissions/VSMCQG/juliadata_V7UW6ot.png", "date": "2021-07-30T15:25:00+00:00", "start": "15:25", "duration": "00:15", "room": "Green", "slug": "juliacon2021-11703-the-state-of-dataframes-jl", "url": "https://pretalx.com/juliacon2021/talk/VSMCQG/", "title": "The state of DataFrames.jl", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "In this talk I discuss what has recently changed in DataFrames.jl, what is the current state of the package, and what are our plans for the future.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 929, "code": "DHRPEA", "public_name": "Bogumi\u0142 Kami\u0144ski", "biography": "I am a researcher in the fields of operations research and computational social science.\r\nFor development I use the Julia language. I currently mostly contribute to DataFrames.jl and related packages.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11704, "guid": "550b8682-2a07-5459-a32e-a668bc5f0d32", "logo": "", "date": "2021-07-30T15:40:00+00:00", "start": "15:40", "duration": "00:15", "room": "Green", "slug": "juliacon2021-11704-sponsor-talk-juliacomputing", "url": "https://pretalx.com/juliacon2021/talk/AX3VYR/", "title": "Sponsor talk - JuliaComputing", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Sponsor talk - JuliaComputing", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 11707, "guid": "4f721cf3-1d7f-528b-aa95-62f4efdb366f", "logo": "", "date": "2021-07-30T15:55:00+00:00", "start": "15:55", "duration": "00:05", "room": "Green", "slug": "juliacon2021-11707-closing-remarks", "url": "https://pretalx.com/juliacon2021/talk/VJEVMQ/", "title": "Closing remarks", "subtitle": "", "track": null, "type": "Keynote", "language": "en", "abstract": "Closing remarks", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 11886, "guid": "6c95e740-e176-5bae-830d-ad82e8ef354b", "logo": "", "date": "2021-07-30T18:00:00+00:00", "start": "18:00", "duration": "01:00", "room": "Green", "slug": "juliacon2021-11886-gathertown-social-break", "url": "https://pretalx.com/juliacon2021/talk/9TYSM9/", "title": "GatherTown -- Social break", "subtitle": "", "track": null, "type": "Social hour", "language": "en", "abstract": "Join us on Gather.town for a social hour.\r\n\r\nIt is a virtual location where we will facilitate the poster sessions, social gatherings, and hackathon. You can join the space using the URL: https://gather.town/invite?token=3QYkt8gX.\r\n\r\nYou should have received the password through Eventbrite", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 9811, "guid": "fc30e4c8-9535-5554-a8c1-787ca8174c4b", "logo": "/media/juliacon2021/submissions/T7UFDU/biglogo_Z7ynDIR.png", "date": "2021-07-30T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9811-introducing-chemellia-machine-learning-with-atoms-", "url": "https://pretalx.com/juliacon2021/talk/T7UFDU/", "title": "Introducing Chemellia: Machine Learning, with Atoms!", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In this talk, I introduce Chemellia: a machine learning ecosystem (built on Flux.jl) designed for chemistry and materials science problems involving molecules, crystals, surfaces, etc. I will focus on two packages I have developed: first, ChemistryFeaturization, which allows customizable and invertible featurization of atomic systems. The second, AtomicGraphNets, implements graph neural network models tailored to atomic graphs, and substantially outperforms comparable Python packages.", "description": "Machine learning is a promising approach in science and engineering for \u201cfilling the gaps\u201d in modeling, particularly in cases where substantial volumes of training data are available. These techniques are becoming increasingly popular in the chemistry and materials science communities, as evidenced by the popularity of Python packages such as DeepChem and matminer. Clearly, there are many potential benefits to building, training, and running such models in Julia, including improved performance, better code readability, and perhaps most importantly, a multitude of prospects for composability with packages from the broader SciML ecosystem, allowing integration with packages for differential equation solving, sensitivity analysis, and more.\r\n\r\nIn this talk, I introduce [Chemellia](https://github.com/chemellia): an ecosystem for machine learning on atomic systems based on Flux.jl. In particular, I will focus two packages I have been developing that will be core to Chemellia. [ChemistryFeaturization](https://github.com/Chemellia/ChemistryFeaturization.jl) represents a novel paradigm in data representation of molecules, crystals, and more. It defines flexible types for features associated with individual atoms, pairs of atoms, etc. as well as for representing featurized structures in the form of, for example, a crystal graph (the AtomGraph type, which of course dispatches the set of functions so that all of the LightGraphs analysis capabilities \u201cjust work\u201d). It also implements an easily extensible set of modular featurization schemes to create inputs for a variety of models, graph-based and otherwise. A core design principle of the package is that all featurized data types carry the requisite metadata to \u201cdecode\u201d their features back to human-readable values.\r\n\r\n[AtomicGraphNets](https://github.com/Chemellia/AtomicGraphNets.jl) provides a Julia implementation of the increasingly popular crystal graph convolutional neural net model architecture that trains and runs nearly an order of magnitude faster than the Python implementation, and requires fewer trainable parameters to achieve the same accuracy on benchmark tasks due to a more efficient and expressive convolutional operation. The layers provided by this package can be easily combined into other architectures using Flux\u2019s utility functions such as Chain and Parallel.\r\n\r\nWe have some great summer student developers working on these packages now and would welcome further community feedback and contributions!", "recording_license": "", "do_not_record": false, "persons": [{"id": 9646, "code": "BKJLVX", "public_name": "Rachel Kurchin", "biography": "Usually writing code (or docs!) or triathlon-ing.\r\n\r\nMore at [my website](https://rkurchin.github.io).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9658, "guid": "ca396a97-cb1b-50a3-baba-43295ac77b02", "logo": "/media/juliacon2021/submissions/ME7JE9/rms-logo-medium_VcsaXfc.png", "date": "2021-07-30T19:30:00+00:00", "start": "19:30", "duration": "00:30", "room": "Green", "slug": "juliacon2021-9658-simulating-chemical-kinetics-with-reactionmechanismsimulator-jl", "url": "https://pretalx.com/juliacon2021/talk/ME7JE9/", "title": "Simulating Chemical Kinetics with ReactionMechanismSimulator.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Understanding many complex chemical processes requires the study of large chemical mechanisms that can involve thousands of species. We present ReactionMechanismSimulator.jl a highly extensible software that can be used to simulate, calculate sensitivities for, analyze and visualize a wide variety of kinetic systems and reactors from gas phase ignition to liquid oxidation to electrocatalysis. We present benchmarks against alternative software and our extensive mechanism analysis toolkit.", "description": "Large chemical kinetic systems are important in many fields including atmospheric chemistry, combustion, pyrolysis, polymers, oxidation, catalysis and electrocatalysis. Traditional C++ and Fortran tools for simulating these systems tend to be difficult to extend, have difficulty integrating modern numerical techniques such as automatic differentiation and adjoint sensitivities and have old or lacking mechanism analysis tools. We present ReactionMechanismSimulator.jl a Julia package for simulating and analyzing kinetic systems. \r\n\r\nReactionMechanismSimulator.jl was designed with extension in mind. Its parser can automatically parse and use newly added kinetic, thermodynamic, phase and domain models as soon as the associated structure is defined with no other code modifications. In addition to analytic jacobians for common systems it provides automatic and symbolic jacobians through ForwardDiff.jl and ModelingToolkit.jl. Forward and adjoint sensitivity analyses are implemented using Julia\u2019s SciML toolkit. ReactionMechanismSimulator.jl includes a suite of molecular structure aware plotting and flux diagram generation software that facilitates efficient analysis of kinetic mechanisms.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10296, "code": "XPJDU7", "public_name": "Matthew S Johnson", "biography": "MIT Chemical Engineering Ph.D. Student", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9502, "guid": "31519ddc-5653-59e5-8cc8-6ec99d1a11be", "logo": "/media/juliacon2021/submissions/7PVG8Z/OpenSAFT_51tCFCs.png", "date": "2021-07-30T20:00:00+00:00", "start": "20:00", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9502-clapeyron-jl-an-extensible-implementation-of-equations-of-state", "url": "https://pretalx.com/juliacon2021/talk/7PVG8Z/", "title": "Clapeyron.jl: An Extensible Implementation of Equations of State", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "The implementation of thermodynamic equations of state for physical property prediction (density, heat capacity, enthalpy, phase fractions, etc) is traditionally an esoteric process. With Julia\u2019s clean syntax and efficient multiple-dispatch system, it is possible to produce extremely lucid code without trade-offs in efficiency, while also being infinitely extensible. We hope to show that Julia is a powerful tool that can transform the art of thermodynamic modelling in both academia and industry.", "description": "Thermodynamic models represent a key tool for a variety of applications; this includes the study of complex systems (electrolytes, polymers, pharmaceuticals, etc), process modelling and molecular design. However, it is not uncommon for thermodynamic models to involve hundreds of different components, especially with the more modern equations of state like those built from Statistical Associating Fluid Theory (SAFT), whose ability to model complex phenomena (such as hydrogen bonding and London dispersion interactions) comes at the cost of complicated mathematical formulation. Most implementations are often abstruse, if they are open to the public at all, which is likely to be the main reason for the high barrier to entry into the field. Beyond those mathematical functions, it is also an exercise in working out the physical properties by exploiting some thermodynamic relations, which may involve the use of highly non-linear solvers for problems with near-singular Jacobians, and solving for the global minima of a non-convex, non-linear problem. The actual execution tends to be application-specific and difficult to extend, even if one had a full understanding of the procedures that are traditionally written in FORTRAN.\r\n\r\nEnter Julia, a language that seems to provide the most natural realisation of every step of this process. OpenSAFT is a framework that makes it easy to build SAFT-type (or any free-energy-based) models such that researchers and enthusiasts alike will be able to focus on the actual thermodynamics and algorithms without worrying about the implementation. With the Julia culture that completely embraces Unicode identifiers and terse syntax for mathematical operations, we are able to create nearly one-to-one translations of the mathematical expressions in the literature to code, removing the layer of obfuscation that usually appears when writing high-performance code.\r\n\r\nDifferential programming is a concept that is extensively used in modern statistical-learning tools, but is still relatively unknown to a lot of the scientific community. We are now able to trivially obtain any-order derivatives of the Helmholtz free energy function, instead of having to work out the corresponding expressions for each model. Suddenly, it all becomes a plug-and-play solution where the user could just write out the model equations, and have OpenSAFT seamlessly obtain all the relevant properties. By careful selection of parameter types, nearly every part of the code can be easily modified or extended so that users will be able to take direct control of the solvers if necessary. This allows people to easily pry into the inner workings of thermodynamic equations of state and study how they can be set up and used.\r\n\r\nWith Julia, OpenSAFT has the potential to revolutionise thermodynamic research and education, and we think that this effort will also greatly help to bridge the gap between cutting-edge development in academia and actual practical use in industry. Perhaps it could also inspire scientists from other domains to invest in bringing over their work to Julia where everything \u201cjust works\u201d.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10080, "code": "HHKEWV", "public_name": "Paul Yew", "biography": "Thermodynamics enthusiast.", "answers": []}, {"id": 10081, "code": "GNS83F", "public_name": "Pierre Walker", "biography": "I am an Imperial chemical engineering undergraduate with a great interest in all things related to thermodynamics! I\u2019ve been using Julia for the past two years to develop an extensible open-source implementation of equations of state: OpenSAFT", "answers": []}, {"id": 10419, "code": "ZQMLJ9", "public_name": "Andr\u00e9s Riedemann", "biography": "Chemical engineering", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9895, "guid": "53bbb996-db97-5a3d-a415-8ce951cf89fe", "logo": "/media/juliacon2021/submissions/YGWUVE/Modia_Robot_zVsBIHs.png", "date": "2021-07-30T20:10:00+00:00", "start": "20:10", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9895-modia-modeling-multidomain-engineering-systems-with-julia", "url": "https://pretalx.com/juliacon2021/talk/YGWUVE/", "title": "Modia \u2013 Modeling Multidomain Engineering Systems with Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Modia (www.ModiaSim.org) is a set of Julia packages for modeling and simulation of multidomain engineering systems (electrical, 3D mechanical, fluid, etc.). Status and plans of a largely redesigned version of Modia is presented consisting of a new syntax in pure Julia mixing equation with function based modeling (e.g. drive trains + 3D mechanics) and new transformation techniques in order that Modia models can be simulated with the ODE integrators of DifferentialEquations.jl.", "description": "Modia (www.ModiaSim.org) is a set of Julia packages for modeling and simulation of coupled multidomain engineering systems (electrical, 3D mechanical, fluid, etc.). It shares many powerful features of the Modelica (www.Modelica.org) language. In the talk status and plans for Modia are presented.\r\n\r\nA new simple, yet powerful syntax has been introduced in Modia based on named tuples of Julia and recursive merge. An electrical Resistor can, for example, be defined as:\r\n\r\n\tResistor = OnePort | Model( R = 1.0u\"\u03a9\", equation = :[ R*i = v ] )\r\n\r\nThe | denotes a recursive merge between the named tuple OnePort and a new Model (named tuple) adding a parameter R and Ohms equation, i.e., corresponding to extending the model OnePort having variables and equations. Such a resistor can then be instantiated:\r\n\r\n\tR = Resistor | Map(R=0.5u\"\u03a9\")\r\n\r\nwith an updated value of the resistance R. The Model constructor constructs a named tuple which only adds attributes during merge and Map only updates attributes. This use of named tuples unifies and generalizes inheritance, hierarchical modifiers and replaceable models of Modelica. Component instances such as R have ports (defined in OnePort) which are connected to form complete hierarchical system models.\r\n\r\nFor certain kinds of models, such as multibody systems, the order of evaluating the component equations is independent of the model topology. This means that algorithmic functions can be used for each model component and called according to the connection topology. This avoids repeated structural and symbolic analysis of the multibody equations, the code size is considerably reduced, and pre-compilation is possible. Modia allows to express such kinds of models together with equation-based models. \r\n\r\nNew symbolic algorithms transform the Modia equations to ODEs (Ordinary Differential Equations in state space form) and generate a Julia function that can be used to simulate the transformed model with ODE integrators of DifferentialEquations.jl. \r\n\r\nWhen instantiating a Modia model, the floating point type of the Modia variables can be defined. This allows for example to easily model uncertainty propagation with Measurements.jl or perform Monte Carlo Simulation with MonteCarloMeasurements.jl. The hierarchical NamedTuple description of a model can be easily mapped to a JSON file. As a result, the complete parameterization of a Modia Model, or the complete Modia model itself, can be exchanged in a straightforward way with a Web App for model composition by drag-and-drop and for 3D animation.\r\n\r\nHilding Elmqvist: Mogram AB\r\nMartin Otter, Andrea Neumayr, Gerhard Hippmann: DLR Institute of System Dynamics and Control", "recording_license": "", "do_not_record": false, "persons": [{"id": 10476, "code": "ZPRJKM", "public_name": "Hilding Elmqvist", "biography": "PhD from Department of Automatic Control, Lund Institute of Technology in 1978 about a new modeling language. Started Dynasim 1992, sold to Dassault Syst\u00e8mes in 2006. Chief architect for modeling software Dymola. Initiated design of Modelica modeling language in 1996.\r\n\r\nPrevious experience include: Mogram AB (CEO), Dassault Syst\u00e8mes (CTO Systems), Dynasim AB (CEO).\r\n\r\nWorking with Julia since 2015 and with Modia since 2016.", "answers": []}, {"id": 10345, "code": "TYBGHT", "public_name": "Martin Otter", "biography": null, "answers": []}, {"id": 1050, "code": "ATAFQL", "public_name": "Andrea Neumayr", "biography": "I am a PhD student and I've studied Mathematics. I am working with Julia since 2017. I'm a developer of a modeling and simulation environment of 3D-systems called Modia3D. Our Julia package is https://github.com/ModiaSim/Modia3D.jl.\r\nI'm interested modeling and numerical analysis in general and I want to learn more about Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9588, "guid": "9ca1fc2f-ef3f-5e42-8508-311be28cc35b", "logo": "/media/juliacon2021/submissions/X3SAWW/Screenshot_2021-03-21_084101_7qcpTuP.jpg", "date": "2021-07-30T20:20:00+00:00", "start": "20:20", "duration": "00:10", "room": "Green", "slug": "juliacon2021-9588-optical-simulation-with-the-opticsim-jl-package", "url": "https://pretalx.com/juliacon2021/talk/X3SAWW/", "title": "Optical simulation with the OpticSim.jl package", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "OpticSim.jl", "description": "OpticSim.jl is an open source (https://github.com/microsoft/OpticSim.jl) Julia package for simulation and optimization of complex optical systems developed by the Microsoft Research Interactive Media Group and the Microsoft HART group.\r\n\r\nIt is designed to allow optical engineers to create optical systems procedurally and then to simulate and optimize them. \r\n\r\nA large variety of surface types are supported, and these can be composed into complex 3D objects through the use of constructive solid geometry (CSG). A substantial catalog of optical materials is provided through the GlassCat submodule.\r\n\r\nThe software provides extensive control over the modelling, simulation, and visualization of optical systems. It is especially suited for designs that have a procedural architecture.\r\n\r\nThe talk will explain how to use OpticSim.jl to simulate various types of optical systems.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10188, "code": "TGSYQC", "public_name": "Brian Guenter", "biography": "Brian Guenter is a Senior Principal Researcher at Microsoft Research, where he manages the Interactive Media Group.", "answers": []}, {"id": 10198, "code": "WVBJJK", "public_name": "Charlie Hewitt", "biography": "Research scientist at Microsoft mixed reality and AI labs. Interested in computer graphics and vision.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11887, "guid": "325d1da1-0472-5bfc-8257-da118530eefd", "logo": "", "date": "2021-07-30T20:30:00+00:00", "start": "20:30", "duration": "01:00", "room": "Green", "slug": "juliacon2021-11887-gathertown-social-break", "url": "https://pretalx.com/juliacon2021/talk/8LK7KU/", "title": "GatherTown -- Social break", "subtitle": "", "track": null, "type": "Social hour", "language": "en", "abstract": "Join us on Gather.town for a social hour.\r\n\r\nIt is a virtual location where we will facilitate the poster sessions, social gatherings, and hackathon. You can join the space using the URL: https://gather.town/invite?token=3QYkt8gX.\r\n\r\nYou should have received the password through Eventbrite", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}], "Red": [{"id": 9737, "guid": "63b80d76-ded5-5597-bc93-aa5f3151f0f5", "logo": "/media/juliacon2021/submissions/WZ7YM9/symbolics_mvV3IG0.png", "date": "2021-07-30T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9737-symbolics-jl-fast-and-flexible-symbolic-programming", "url": "https://pretalx.com/juliacon2021/talk/WZ7YM9/", "title": "Symbolics.jl - fast and flexible symbolic programming", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Symbolics.jl is a fast, yet flexible symbolic manipulation package. It can generate serial or multi-threaded Julia code; or even C, Stan or MATLAB code from symbolic expressions. This talk is an overview of the features and the organization of the Symbolics.jl package, and the design decisions that make it fast and extendable.", "description": "Symbolic systems either excel in flexibility or performance. For example, SymPy is highly flexible and has a good set of term rewriting functionality, but is slow. On the other hand, projects like OSCAR are specialized tools for computational algebra -- problems are hard to set up but computations are highly efficient. Further, neither of these types of tools actually help you turn symbolic expressions into executable code.\r\n\r\nIn this talk, we introduce the Symbolics.jl and the underlying SymbolicUtils.jl packages. We also talk about the term-rewriting system and ways to write passes that transform symbolic expressions with user-defined custom rules.\r\n\r\nOutline:\r\n\r\n- Why is Symbolics.jl useful\r\n- Example of symbolic basic manipulation\r\n- Benchmark vs SymPy\r\n- Code generation example\r\n- Differentiation syntax (comparison with other systems and possibilities, and AD)\r\n  - Fast sparsity detection\r\n  - Under the hood\r\n    - Wrapper to make symbolic expression: `Num <: Number`\r\n    - Syms and Terms\r\n    - Fast canonical form\r\n    - Term interface\r\n    - Expression rewriting\r\n       - Rule syntax\r\n       - Chaining and pipelining rules\r\n       - Simplification\r\n    - Polynomial form from AbstractAlgebra\r\n    - ModelingToolkit\r\n       - How ModelingToolkit builds a simulation system on top of Symbolics\r\n       - Use of build_function in ODE solver\r\n       - Structural simplification example with a bit of all the clever ideas (Attend Chris\u2019s talk and workshop)", "recording_license": "", "do_not_record": false, "persons": [{"id": 10361, "code": "CZ3CRC", "public_name": "Shashi Gowda, Yingbo Ma", "biography": "Shashi is a grad student at MIT. Yingbo is an undergrad at UMBC and works at Julia Computing. We like coding in Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9439, "guid": "8d279a39-ca69-52bd-a7d7-03508cf2f0fa", "logo": "/media/juliacon2021/submissions/F9PLVY/dragon_YF1D9lf.jpg", "date": "2021-07-30T13:00:00+00:00", "start": "13:00", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9439-unleashing-algebraic-metaprogramming-in-julia-with-metatheory-jl", "url": "https://pretalx.com/juliacon2021/talk/F9PLVY/", "title": "Unleashing Algebraic Metaprogramming in Julia with Metatheory.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "A novel data structure and technique from theorem provers, a pattern matching system and classical term rewriting. Mix it with dynamism and the homoiconic metaprogramming system of Julia. Add algebraic composability. Shake well before using. What could go wrong? Composable compiler transforms, numerical code optimizers, interpreters and compilers, computer algebra systems, categorical theorem provers and much more to come. Come experiment with us and the Metatheory.jl package!", "description": "We introduce Metatheory.jl: a lightweight and performant general purpose symbolics and metaprogramming framework meant to simplify the act of writing complex Julia metaprograms and to significantly enhance Julia with a native term rewriting system, based on state-of-the-art equality\r\nsaturation techniques, and a dynamic first class AST pattern matching system that is dynamically\r\ncomposable in an algebraic fashion, taking full advantage of the language\u2019s powerful reflection capabilities. Our contribution allows performing general purpose symbolic mathematics, manipulation,\r\noptimization, synthesis or analysis of syntactically valid Julia expressions with a clean and concise\r\nprogramming interface, both during compilation or execution of programs. We have been currently experimenting with optimizing mathematical code and equational theorem proving strategies. This talk will discuss algebraic equational reasoning with examples from logic, program analysis, abstract algebra and category theory.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9988, "code": "7ATBR8", "public_name": "Alessandro Cheli", "biography": "Computer Science undergraduate student at the University of Pisa. Interested in functional programming, programming language theory, category theory, algebraic and symbolic computation, computability theory.", "answers": []}, {"id": 10194, "code": "EYVZUS", "public_name": "Philip Zucker", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9656, "guid": "674100ea-3c00-5ca4-bb98-672a913417f6", "logo": "", "date": "2021-07-30T13:30:00+00:00", "start": "13:30", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9656-towards-a-symbolic-integrator-with-rubin-jl", "url": "https://pretalx.com/juliacon2021/talk/G8LARY/", "title": "Towards a symbolic integrator with Rubin.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Rubin.jl will be a 100% Julia implementation of an integration term-rewriting system. The rule catalogue is taken from RUBI, a Mathematica-based integration engine that uses binary searches in a tree of mutually exclusive rewriting rules, which nets RUBI an order of magnitude speed improvement over Mathematica over an immense test suite. Rubin.jl hosts 99.5+% of RUBI's rules, and 99.9% of the test suite in a JSON format, spanning more than 72,000 single variable integration unit tests.", "description": "Rubin.jl will be based on Symbolics.jl, a novel foundation for a Julian CAS. The goal of Rubin.jl is to \r\n\r\n[X] Convert all the RUBI rules into a huge JSON\r\n\r\n[X] Convert all the RUBI unit tests into a huge JSON\r\n\r\n[ ] Parse the JSON files into Rubin Rules and Rubin tests\r\n\r\n[ ] Benchmark the test suite and assess discrepancies\r\n\r\nSymbolics.jl is a Julia based term-rewriting system that allows the user to specify that a \"left hand side\" symbolic expression should be transformed into the expression on the right hand side. Symbolic integration is useful for pure and applied mathematics - this will help bring in even more users to Julia.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1182, "code": "JE89PF", "public_name": "Miguel Raz Guzm\u00e1n Macedo", "biography": "Physics Undergraduate based in Mexico City, UNAM. I enjoy handstands and coding in Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9513, "guid": "34de65d7-c8fb-5a44-bc26-4efa1a15931f", "logo": "", "date": "2021-07-30T13:40:00+00:00", "start": "13:40", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9513-algebraicdynamics-compositional-dynamical-systems", "url": "https://pretalx.com/juliacon2021/talk/ARURL8/", "title": "AlgebraicDynamics: Compositional dynamical systems", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "[AlgebraicDynamics](https://github.com/AlgebraicJulia/AlgebraicDynamics.jl) is a new library in the [AlgebraicJulia](https://www.algebraicjulia.org/) ecosystem for specifying and solving dynamical systems with compositional and hierarchical structure. This modular approach to constructing and analyzing dynamical systems is grounded in the mathematics of applied category theory.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10090, "code": "8ZZBEM", "public_name": "Sophie Libkind", "biography": "Sophie is a math PhD student at Stanford University. Her research interests are focused on dynamical systems including topological invariants of dynamical systems, composing dynamical systems, and the question of how continuous dynamical systems compute.", "answers": []}, {"id": 988, "code": "WPZLWJ", "public_name": "James Fairbanks", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9746, "guid": "f8b362fe-6aa0-5224-a692-142f0a6c1011", "logo": "/media/juliacon2021/submissions/WQ8MJK/OSCAR_logo_TfUhtvt.png", "date": "2021-07-30T13:50:00+00:00", "start": "13:50", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9746-the-oscar-computer-algebra-system", "url": "https://pretalx.com/juliacon2021/talk/WQ8MJK/", "title": "The OSCAR Computer Algebra System", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "We present OSCAR, an **O**pen **S**ource **C**omputer **A**lgebra **R**esearch system for abstract algebra, algebraic geometry, group theory, number theory, and more. It joins existing world class systems under a common Julia interface in the Oscar.jl package. Applications exist well beyond pure mathematics (e.g. in coding theory, cryptography, robotics, ...).\r\n\r\nWe give an overview of existing and planned capabilities. We also discuss what sets us apart from Symbolics.jl.", "description": "In this talk we present OSCAR, an **O**pen **S**ource **C**omputer **A**lgebra **R**esearch system for computations to support research in abstract algebra, algebraic geometry, group theory, number theory, and more. It builds on decades of experience by extending and integrating our four existing cornerstone systems:\r\n- [GAP](https://www.gap-system.org/) - group and representation theory (via [GAP.jl](https://github.com/oscar-system/GAP.jl)),\r\n- [Singular](https://www.singular.uni-kl.de/) - commutative and non-commutative algebra, algebraic geometry (via [Singular.jl](https://github.com/oscar-system/Singular.jl)),\r\n- [Polymake](https://polymake.org/doku.php) - polyhedral geometry (via [Polymake.jl](https://github.com/oscar-system/Polymake.jl)),\r\n- Antic ([Hecke](https://github.com/thofma/Hecke.jl/), [Nemo](http://nemocas.org/)) - number theory.\r\n\r\nThese are joined together under a common Julia interface in the [Oscar.jl](https://github.com/oscar-system/Oscar.jl) package.\r\n\r\nApplications of our computational capabilities exist well beyond pure mathematics (e.g. in coding theory, cryptography, crystallography, robotics, ...).\r\n\r\nWhile OSCAR is still under heavy development, many useful features are already available, and more are in the works. We will give an overview of existing capabilities and give a preview of what will come in the future. We will also outline what sets us apart from Symbolics.jl (which has a very different scope).\r\n\r\nThe development of OSCAR is supported by the Deutsche Forschungsgemeinschaft DFG within the [Collaborative Research Center TRR 195](https://www.computeralgebra.de/sfb/).\r\nOutside contributions to OSCAR are highly welcome. Please talk to us:\r\n- on our own Slack (use this [invite link](https://join.slack.com/t/oscar-system/shared_invite/zt-thtcv97k-2678bKQ~RpR~5gZszDcISw), or [email me](mailto:horn@mathematik.uni-kl.de) if it does not work)\r\n- on the Julia Slack in `#oscar` or `#algebra`\r\n- via our mailing list, join at <https://mail.mathematik.uni-kl.de/mailman/listinfo/oscar-dev>\r\n- via issues and PRs on our various GitHub repositories.\r\n\r\nAdditional information can be found on our homepage, <https://oscar.computeralgebra.de>.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10287, "code": "KCSGU7", "public_name": "Max Horn", "biography": "Since April 2020 I am full professor for Algorithmic Algebra and Geometry at TU Kaiserslautern, Germany. My research focuses on computer algebra, group theory and algebraic Lie theory.\r\n\r\nBesides being one of the principal investigators on the grant behind OSCAR, and one of its developers, I am also core developer of the [GAP](https://www.gap-system.org) computer algebra system for computational group theory.\r\n\r\nOutside of mathematics, I've been involved in many open source projects over the past decades; e.g. in the distant past, I served as project leader for [ScummVM](https://www.scummvm.org) as well as the [Fink project](https://www.finkproject.org), and contributed to [TeXShop](https://texshop.org).", "answers": []}, {"id": 10376, "code": "BPLE9V", "public_name": "Claus Fieker", "biography": "I am a professor for computational number theory at Kaiserslautern University. I  a  PI of the DFG (German research association) funded OSCAR project as well as a developer of both OSCAR and Hecke.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9744, "guid": "10c31872-b2a9-5f6b-8fb7-63b683df0518", "logo": "", "date": "2021-07-30T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9744-enabling-rapid-microservice-development-with-a-julia-sdk", "url": "https://pretalx.com/juliacon2021/talk/SHHKEM/", "title": "Enabling Rapid Microservice Development with a Julia SDK", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "The Optimal Reality platform, by Deloitte Digital Australia, is a modelling and simulation environment built and deployed as Julia microservices. This talk describes our Software Development Kit which enables rapid building and deployment of these microservices.\u00a0We discuss our use of templates, utility packages, standardised multi-threading and logging functions, and a custom GraphQL interface; and share how they can be used to bolster team creativity and efficiency.", "description": "The benefits of microservices architectures are well understood. They have the potential to be more agile, enable each service to pick the best technology for its purpose and be scaled or autoscaled appropriately, and can be easily deployed and managed through common open-source technologies.\r\n\r\nDeveloping a solution with a microservices architecture, however, can have some disadvantages. A developer creating a new microservice must understand the external interfaces to that service, how it is tested and deployed, and how to configure the service to run and scale as required. This increases the skill requirement of a developer and can take time away from what the developer is actually trying to do \u2013 create a new bit of functionality. It can also result in inconsistencies in code behaviour and style between services. This problem is compounded when the developers are using a new language and are unfamiliar with what is possible and with best practices, and further compounded when that language is itself rapidly developing.\r\n\r\nWe faced this challenge when developing a modelling and simulation platform built and deployed as Julia microservices. Julia was a new language for the majority of our team, and we needed to quickly design and deploy many services. Furthermore, we wanted to continue to use recent open-source developments without requiring that all of our developers must stay up to date with package and language advancements. To enable our developers to focus on what they\u2019re best at (i.e., the functionality of the service they\u2019re developing) and mitigate the issues mentioned, we made use of Julia\u2019s excellent ecosystem to create a Software Development Kit (SDK).\r\n\r\nIn this talk, we describe the components of the SDK, how they enable both efficient development and use of new open-source advances, and how similar approaches can be used by your team as you build microservices. We will discuss how Julia\u2019s package system makes it ideal for SDK use.\r\n\r\nLocated in a private registry, the SDK includes a microservice template, a utility package template, various utility packages and a custom GraphQL interface. The microservice template is the starting point for a developer writing a new microservice and includes the following functionality:\r\n\r\n- Default communication routes (service execution, liveness etc)\r\n- Logging behaviour\r\n- Automatic documentation\r\n- Asynchronous and multithreading tools\r\n- CICD scripts (testing, building and cloud deployment)\r\n\r\nWe will discuss the above, including detailing the various open-source packages used for each function.\r\n\r\nWe will also describe how providing utility packages in an SDK enables teams to make use of the best open-source developments, which may be developing and changing frequently, through a stable API. For example, when handling large volumes of data, it is often desirable to encode and decode numeric arrays to minimise data transfer. One package in our SDK provides a simple encode and decode interface, where the specifics of what compression packages are being used can be updated as required without the majority of users needing to stay abreast of open-source developments. We will detail this approach and give other examples of where we have found it useful. Finally, we will describe our custom GraphQL interface, which wraps a generic interface in a similar method to the utility packages, enabling developers to quickly interact with and make use of our platform.\r\n\r\nTo conclude, Julia is a powerful language with an exceptional ecosystem. In this talk, we will demonstrate how it can be used to create an efficient environment for microservice development which lets developers focus on what they\u2019re developing, ensures all services use the best of the open-source community and generally makes things much more straightforward.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10371, "code": "ZA9RUN", "public_name": "Malcolm Miller", "biography": "Malcolm is a simulation engineer at Deloitte Digital Australia with a background in real-time simulation in the automotive and transport domains. Currently he is developing real-time simulations of large transport networks as part of the [Optimal Reality](https://optimalreality.com) team, and enjoying [contributing](https://github.com/mmiller-max) to Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9894, "guid": "7ed26a93-0335-5db2-88ed-7fe60c347496", "logo": "", "date": "2021-07-30T19:30:00+00:00", "start": "19:30", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9894-kubernetes-native-julia-development", "url": "https://pretalx.com/juliacon2021/talk/9LCKEQ/", "title": "kubernetes-native julia development", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "You have access to a k8s cluster, and you want to use it to scale out computations. But first, you need to develop and debug julia code that can take advantage of it!\r\n                                                         \r\nI will present an ergonomic julia development setup to help make k8s feel like home, using freely available and easily installed tools.", "description": "In this setup, from a julia project directory, you can:\r\n- drop into a julia REPL that is running on your k8s cluster                                        \r\n- edit source files locally, use Revise and get back results saved to disk, via a 2-way sync between the local julia project directory and the corresponding directory in the k8s container                                                                                            \r\n- sync REPL history across local and remote julia sessions                                       \r\n- easily spin up and use Distributed workers from within the julia session                                                                                                                                                                                                             \r\n- automatically build and use images containing julia, with chosen dependencies baked in a PkgCompiler sysimage, precompiled julia project, and (optionally) CUDA                                                                                                                      \r\n- minimize time-to-first-command-completion with cached image builds; first use in a project directory takes a long time to build, but subsequently spinning up is fast                                                                                                                \r\n- set RAM/cpu/disk resources for the main julia session and any Distributed workers                                                                                                                                                                                                    \r\n- set julia (and CUDA) versions independently for each session\r\n- run your work as a non-interactive job once it is ready                                                                                                                                                                                                                              \r\n                                                                                      \r\nThis tries to make minimal assumptions about the k8s setup; requirements are access to the cluster via `kubectl` and to a container registry that the k8s cluster can pull from.                                                                                                       \r\n                                                                                      \r\nTools needing to be installed locally are:                                                                                                                                                                                                                                             \r\n- kubectl                               \r\n- docker buildkit                                          \r\n- devspace sync                                                      \r\n                                                                                                 \r\nThe julia-specific tools developped to make this possible are [K8sClusterManagers.jl](https://github.com/beacon-biosignals/K8sClusterManagers.jl) and `julia_pod`.\r\n\r\nThis workflow is developped and used day-to-day at [Beacon Biosignals](https://beacon.bio/).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10478, "code": "PYEFR8", "public_name": "Kolia Sadeghi", "biography": "Senior Machine Learning Engineer at [Beacon Biosignals](https://beacon.bio/), working with julia since 1.0.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9879, "guid": "338e3c09-0155-5264-8ae2-beb5c37433a2", "logo": "", "date": "2021-07-30T19:40:00+00:00", "start": "19:40", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9879-rewriting-pieces-of-a-python-codebase-in-julia", "url": "https://pretalx.com/juliacon2021/talk/GXLNHG/", "title": "Rewriting Pieces of a Python Codebase in Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Many people looking at Julia are coming from Python, and already have a sizable codebase.\r\nOur fund started rewriting  performance-critical parts of our Python codebase in Julia, getting 10x-30x speedups. I'll go over how to start migrating Python code to Julia using PyCall and PyJulia, some gotchas to avoid, and where you're likely to see the biggest benefits.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10470, "code": "QX7UTF", "public_name": "Satvik Souza Beri", "biography": "Satvik is a co-founder and head of Machine Learning at Temple Capital, a crypto currency quant fund.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9736, "guid": "3a655c81-bdae-50bb-9a93-99403e11c0d1", "logo": "", "date": "2021-07-30T19:50:00+00:00", "start": "19:50", "duration": "00:10", "room": "Red", "slug": "juliacon2021-9736-julia-in-the-windows-store", "url": "https://pretalx.com/juliacon2021/talk/MSTYCZ/", "title": "Julia in the Windows Store", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "I will describe an effort to distribute Julia via the Windows Store. This effort includes a full Julia version manager that provides the ability to install multiple Julia versions at the same time, switch between them etc. The talk showcases an experimental working version of the installer from a user perspective, and also gives a brief deep dive around the technologies used.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 1038, "code": "7JQFVF", "public_name": "David Anthoff", "biography": "David Anthoff is an environmental economist who studies climate change and environmental policy. He co-develops the integrated assessment model FUND that is used widely in academic research and in policy analysis. His research has appeared in Nature, Science, the American Economic Review and other academic journals. He contributed a background research paper to the Stern Review and has advised numerous organizations (including US EPA and the Canadian National Round Table on the Environment and the Economy) on the economics of climate change.\r\n\r\nHe is an assistant professor in the Energy and Resources Group at the University of California, Berkeley. Previously he was an assistant professor in the School of Natural Resources and the Environment of the University of Michigan, a postdoc at the University of California, Berkeley and a postdoc at the Economic and Social Research Institute in Ireland. He also was a visiting research fellow at the Smith School of Enterprise and the Environment, University of Oxford.\r\n\r\nHe holds a PhD (Dr. rer. pol.) in economics from the University of Hamburg (Germany) and the International Max Planck Research School on Earth System Modelling, a MSc in Environmental Change and Management from the University of Oxford (UK) and a M.Phil. in philosophy, logic and philosophy of science from Ludwig-Maximilians-Universit\u00e4t M\u00fcnchen (Munich, Germany).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9572, "guid": "f8f42bd4-70b5-5424-9c33-ab7f9460ba84", "logo": "", "date": "2021-07-30T20:00:00+00:00", "start": "20:00", "duration": "00:30", "room": "Red", "slug": "juliacon2021-9572-redwood-a-framework-for-clusterless-supercomputing-in-the-cloud", "url": "https://pretalx.com/juliacon2021/talk/TXAWKU/", "title": "Redwood: A framework for clusterless supercomputing in the cloud", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We present Redwood, a Julia framework for clusterless supercomputing in the cloud. Redwood provides a set of distributed programming macros that enable users to remotely execute Julia functions in parallel through cloud services for batch and serverless computing. We present the architecture and design of Redwood, as well as its application to existing Julia packages for machine learning and inverse problems.", "description": "Through the rise in popularity of deep learning and large-scale numerical simulations, high-performance computing (HPC) has entered the mainstream of scientific computing. Today, HPC techniques are increasingly required by a wider and wider audience, in fields including machine and deep learning, weather forecasting, medical and seismic imaging, computational genomics, fluid dynamics and others. HPC workloads have been traditionally deployed to on-premise high-performance computing clusters and were therefore only available to a very limited number of researchers or corporations. With the rise of cloud computing, HPC resources have in principle become available to a much wider audience but managing HPC infrastructure in the cloud is challenging. As the cloud provides a fundamentally different computing infrastructure from on-premise supercomputer, users need build environments and applications that are resilient are cost efficient and that are able to leverage cloud-related opportunities such as elastic (hyper-scale) compute and heterogeneous infrastructure.\r\n\r\nNaturally, the current approach to port HPC applications to the cloud is to replicate the infrastructure of on-premise supercomputing centers with cloud resources. Cloud services such as AWS ParallelCluster or Azure CycleCloud enable users to create virtual HPC clusters that consist of login nodes, job schedulers, a set of compute instances, networking and distributed storage systems. Even cloud-native approaches such as Kubernetes follow this cluster-based architecture, albeit using containerization and novel schedulers. However, from the user side both approaches are a two-step approach in which users first create a (virtual) HPC cluster in the cloud and then submit their parallel program to the cluster. This makes running HPC applications in the cloud challenging, as users have to act as cluster administrators who manage the HPC infrastructure before being able to run their application.\r\n\r\nIn this work, we argue for the case of clusterless supercomputing in the cloud in which the user application essentially takes over the role of the job scheduler and cluster orchestrator. Instead of a\r\ntwo-step process in which users first create a cluster and then submit their job to it, the application is executed anywhere and dynamically manages the required compute infrastructure at runtime. To enable this type of clusterless HPC which is heavily inspired by serverless orchestration frameworks, we introduce Redwood, an open-source software package for clusterless supercomputing on the Azure cloud. Redwood provides a set of distributed programming macros that are designed in accordance with Julia's existing macros for distributed computing around the principles of remote function calls and futures. Unlike Julia's standard distributed computing framework, Redwood does not require a parallel Julia session that is running on a set of interconnected nodes (i.e., a cluster). Instead, Redwood executes functions that are tagged for remote (parallel) execution via cloud services such as Azure batch or Azure Functions by creating a closure around the executed code and running it remotely through the respective cloud service. Results, namely function outputs, are written to cloud object stores and remote references are returned to the user.\r\n\r\nIn this talk, we discuss the architecture and implementation of Redwood and present HPC scenarios that are enable by it. This includes large-scale MapReduce workloads, computations that are distributed across multiple data centers or even regions, as well as combinations of data and model parallel applications in which users can execute multiple distributed-memory MPI workloads in parallel. Additionally, we present how existing Julia packages such as Flux or JUDI (a framework for PDE-constrained optimization) can be cloud-natively deployed through Redwood, without requiring users to set up HPC clusters.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10165, "code": "LSJRYM", "public_name": "Philipp A. Witte", "biography": "Philipp A. Witte is a researcher at Microsoft Research for Industry (RFI), a new initiative within Microsoft for developing innovative research solutions for industry-related problems ranging from AI/ML to edge- and high-performance computing. Prior to Microsoft, Philipp received his B.Sc. and M.Sc. in Geophysics from the University of Hamburg and his Ph.D. in Computational Science and Engineering from the Georgia Institute of Technology. During his Ph.D., Philipp worked with Professor Felix J. Herrmann at the Seismic Laboratory for Imaging and Modeling (SLIM) on computational aspects of least squares seismic imaging and full-waveform inversion. He has authored and contributed to multiple open-source software packages, including Devito, the Julia Devito Inversion framework (JUDI) and InvertibleNetworks.jl, a Julia framework for deep learning with normalizing flows.", "answers": []}], "links": [], "attachments": [], "answers": []}], "Blue": [{"id": 9838, "guid": "a4546214-b52a-556c-8daf-8fc96d1ba406", "logo": "", "date": "2021-07-30T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9838-jet-jl-the-next-generation-of-code-checker-for-julia", "url": "https://pretalx.com/juliacon2021/talk/BNB888/", "title": "JET.jl: The next generation of code checker for Julia", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Julia's extreme expressiveness and composability come from its dynamism \u2013 at the cost of that, a static type check of Julia code has been remained as a longstanding problem.\r\nJET.jl is a fresh approach to static analysis of such a dynamic language; it can detect type-level errors given a pure Julia script within a practical speed. \r\nIn this talk we will first give an overview of its features and basic usages, and then move to a discussion of its internals, current limitations and future works.", "description": "This talk will introduce [JET.jl](https://github.com/aviatesk/JET.jl), an experimental type checker for Julia.\r\n\r\nJET is powered by both abstract interpretation routine implemented within the Julia compiler as well as a concrete interpretation based on [JuliaInterpreter.jl](https://github.com/JuliaDebug/JuliaInterpreter.jl). The abstract interpreter enables a static analysis on a pure Julia script without any need for additional type annotations, while the concrete interpreter allows effective analysis no matter how heavily it depends on runtime reflections or external configurations, which are common obstacles to static code analysis.\r\n\r\nThe talk will begin by explaining the motivation for type-level analysis of Julia code as well as how we can find various kinds of errors ahead of time using JET. Then we will illustrate how JET works and also the limitations involved with its design choices, and finally discuss the planned future enhancements like IDE integrations and such.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4222, "code": "8BZR7G", "public_name": "Shuhei Kadowaki", "biography": "A research programmer working at Julia Lab, MIT. Working on Julia's compiler technology stack, mainly around its abstract interpretation based type inference. Aso a maintainer of Julia IDEs, [julia-vscode](https://www.julia-vscode.org/) and [Juno](https://junolab.org/).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9733, "guid": "d7d88a09-cc4b-5031-98b9-9c2eb44c2b91", "logo": "", "date": "2021-07-30T13:00:00+00:00", "start": "13:00", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9733-easy-featureful-parallelism-with-dagger-jl", "url": "https://pretalx.com/juliacon2021/talk/3TLU8P/", "title": "Easy, Featureful Parallelism with Dagger.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Parallelizing codes with Distributed.jl is simple and can provide an appreciable speed-up; but for complicated problems or when scaling to large problem sizes, the APIs are somewhat lacking. Dagger.jl takes parallelism to the next level, with support for GPU execution, fault tolerance, and more. Dagger's scheduler exploits every bit of parallelism it can find, and uses all the resources you can give it. In this talk, I'll build an application with Dagger to highlight what Dagger can do for you!", "description": "The Distributed standard library exposes RPC primitives (remotecall) and remote channels for coordinating and executing code on a cluster of Julia processes. When a problem is simple enough, such as a trivial map operation, the provided APIs are enough to get great performance and \"pretty good\" scaling. However, things change when one wants to use Distributed for something complicated, like a large data pipeline with many inputs and outputs, or a full desktop application. While one *could* build these programs with Distributed, one would quickly realize that a lot of functionality will need to be built from scratch: application-scale fault tolerance and checkpointing, heterogeneous resource utilization control, and even simple load-balancing. This isn't a fault of Distributed: it just wasn't designed as the be-all-end-all distributed computing library for Julia. If Distributed won't make it easy to build complicated parallel applications, what will?\r\n\r\nDagger.jl takes a different approach: it is a batteries-included distributed computing library, with a variety of useful tools built-in that makes it easy to build complicated applications that can scale to whatever kind and size of resources you have at your disposal. Dagger ships with a built-in heterogeneous scheduler, which can dispatch units of work to CPUs, GPUs, and future accelerators. Dagger has a framework for checkpointing (and restoring) intermediate results, and together with fault tolerance, allows computations to safely fail partway through, and be automatically or manually resumed later. Dagger also has primitives to build dynamic execution graphs across the cluster, so users can easily implement layers on top of Dagger that provide abstractions better matching the problem at hand.\r\n\r\nThis talk will start with a brief introduction to Dagger: what it is, how it relates to Distributed.jl, and a brief overview of the features available. Then I will take the listeners through the building of a realistic, mildly complicated application with Dagger, showcasing how Dagger makes it easy to make the application scalable, performant, and robust. As each feature of Dagger is used, I will also point out any important caveats or alternative approaches that the listeners should consider when building their own applications with Dagger. I will wrap up the talk by showing the application running at scale, and talk briefly about the future of Dagger and how listeners can help to improve it.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4385, "code": "GRFD9D", "public_name": "Julian P Samaroo", "biography": "I am an HPC software engineer working at the JuliaLab. I maintain Dagger.jl, AMDGPU.jl, and BPFnative.jl, and generally enjoy the challenge of hacking on compilers and HPC runtimes.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9742, "guid": "2a06d036-1a67-5566-b2d8-b8388cc7ca7a", "logo": "", "date": "2021-07-30T13:30:00+00:00", "start": "13:30", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9742-actors-jl-concurrent-computing-with-the-actor-model", "url": "https://pretalx.com/juliacon2021/talk/PFWXF9/", "title": "Actors.jl: Concurrent Computing with the Actor Model", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "`Actors` implements the Actor Model of concurrent computation. Actors\r\n- interact via messages,\r\n- represent computations and\r\n- can create other actors.\r\n\r\nProgrammers can use actors to\r\n- model computational concepts: e.g. atomic blocks, event handlers, state machines,\r\n- implement concurrent objects such as servers, supervisors, firewalls and to\r\n- compose them into an application.\r\n\r\nActors allows to write fault-tolerant Julia applications and make concurrency easier to understand.", "description": "**Give an overview** of `Actors`' philosophy and functionality and how it integrates into Julia's multi-threading and distributed computing.\r\n\r\n**Demonstrate** how to\r\n\r\n- `spawn` actors with arbitrary Julia functions as behaviors,\r\n- `send` them messages and get back results,\r\n- make them interact,\r\n- `supervise` them and to\r\n- integrate them with tasks and distributed processes.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10369, "code": "LXNRLJ", "public_name": "Paul Bayer", "biography": "Profession: Mechanical engineer\r\nLocation: Germany, Landshut\r\nGithub: https://github.com/pbayer\r\nLinkedin: https://www.linkedin.com/in/paul-bayer-4104a78/", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9681, "guid": "3ecc739e-9ae5-5dd1-b5db-f03d7468c2e6", "logo": "", "date": "2021-07-30T13:40:00+00:00", "start": "13:40", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9681-bpfnative-jl-ebpf-programming-in-julia", "url": "https://pretalx.com/juliacon2021/talk/DAQSUR/", "title": "BPFnative.jl: eBPF programming in Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "eBPF is a virtual machine that can run user-defined code in the Linux kernel. The ability to generate eBPF bytecode from Julia would allow our Linux users to introspect, manipulate, and explore the core of their operating system from the comfort of a high-level language. In this talk, I will explain the basics of eBPF, how it's integrated and used in the Linux kernel, and how we can use \"eBPF superpowers\" from Julia.", "description": "eBPF (extended Berkeley Packet Filter) is a virtual machine specification and machine code ISA originally designed for packet filtering in operating system kernels. eBPF is designed to be simple and compact enough to be trivially converted to native machine code, making it very portable across machine architectures. eBPF is developed in tandem with the Linux kernel, intended to be an internal runtime for safely executing user-defined code within the Linux kernel, where it allows users to introspect (and even modify) the functioning of their kernel's various subsystems. Given the key role that the OS kernel plays in allowing modern computers to function, it is thus no surprise that the ability to write and install eBPF kernels is considered a Linux \"superpower\".\r\n\r\nAs we can see from the example set by CUDA.jl, Julia is an excellent language for writing portable code which can execute on a variety of architectures with minimal changes. Recognizing this, I created BPFnative.jl as an interface from Julia to eBPF and the Linux kernel. BPFnative.jl allows users to write eBPF kernels in pure Julia, compile them into eBPF bytecode, and install them at various locations in the Linux kernel. This allows users with a minimal understanding of eBPF to explore their OS kernel at runtime, and thanks to the security measures and verifier built into the Linux eBPF VM, makes this a very safe thing to do.\r\n\r\nFor this talk, I will introduce the basics of eBPF and why Linux users should care about it, and then provide examples (including code snippets) of how to create eBPF kernels for introspecting various parts of the Linux kernel with BPFnative.jl. I will strive to make the examples relevant to everyday Linux users who want to find out more about what their OS is doing behind the scenes, without having to fully understand how the Linux kernel works. I will also encourage interested users to explore other parts of their OS with eBPF, and submit examples to BPFnative.jl to benefit the community.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4385, "code": "GRFD9D", "public_name": "Julian P Samaroo", "biography": "I am an HPC software engineer working at the JuliaLab. I maintain Dagger.jl, AMDGPU.jl, and BPFnative.jl, and generally enjoy the challenge of hacking on compilers and HPC runtimes.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9723, "guid": "d82beed8-5190-50c8-89b2-44c00df6388a", "logo": "", "date": "2021-07-30T13:50:00+00:00", "start": "13:50", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9723-atomic-fields-the-new-primitives-on-the-block", "url": "https://pretalx.com/juliacon2021/talk/YFCXJD/", "title": "Atomic fields: the new primitives on the block", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Atomic accessors support have recently been expanded to provide more efficient build-blocks for working with threads. Dealing effectively with multi-core programs requires a vocabulary for communicating intent, both to humans and machines. Here I'll talk about what atomics are, why we needed them, and how to use them!", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 1057, "code": "GKZDHU", "public_name": "Jameson Nash", "biography": "I work for Julia Computing on Julia compiler technology.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9771, "guid": "7deef356-f53c-5fc1-901b-0f91df36d28e", "logo": "", "date": "2021-07-30T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Blue", "slug": "juliacon2021-9771-a-short-history-of-astrotime-jl", "url": "https://pretalx.com/juliacon2021/talk/TJ3FNS/", "title": "A Short History of AstroTime.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Time is...complicated. It seems simple enough when you are close to the surface of the Earth and you have a device in your pocket that is constantly connected to atomic clocks. But go to outer space and things get uncomfortable pretty quickly. This talk explores how [AstroTime.jl](https://github.com/JuliaAstro/AstroTime.jl) has evolved and how it can help you deal with the intricacies of time such as leap seconds and different time scales. Even if you are neither an astronomer nor an astronaut!", "description": "The [AstroTime.jl](https://github.com/JuliaAstro/AstroTime.jl) library has been in development since 2013 (originally as part of [Astrodynamics.jl](https://github.com/JuliaSpace/Astrodynamics.jl)). It provides the `Epoch` type as a replacement and complement to Julia's `DateTime`. `Epoch` can handle sub-nanosecond accuracy over a time span several times the age of the universe with support for all commonly used astronomical time scales.\r\n\r\nSince its inception, AstroTime.jl has gone through several major design iterations as our understanding of the scope and complexity of the problem domain has grown. The public API on the other hand has remained remarkably stable which is a great testament to Julia's expressive and versatile type system. While AstroTime.jl is built on the solid foundations of the `Dates` standard library, it also fixes some of the shortcomings of the latter and might also highlight further areas of possible improvement.\r\n\r\nAstroTime.jl was meant to be only a small stepping stone on the way to making Julia a multiplanetary programming language but it has become a great project in its own right. We want to share the journey so far and maybe get you exited about something as mundane as time. Or spacetime, rather, relatively speaking...", "recording_license": "", "do_not_record": false, "persons": [{"id": 10348, "code": "KDTCJJ", "public_name": "Helge Eichhorn", "biography": "I am a mechanical engineer working on ground systems software in the European space industry.\r\n\r\nWorking on reimagining space exploration with Open Source at [JuliaAstro](https://github.com/JuliaAstro), [JuliaSpace](https://github.com/JuliaSpace), and [OpenAstrodynamics](https://github.com/openastrodynamics).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9793, "guid": "9a201a5a-9043-5bbe-b591-165ed5b1d7fb", "logo": "", "date": "2021-07-30T19:30:00+00:00", "start": "19:30", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9793-going-to-jupiter-with-julia", "url": "https://pretalx.com/juliacon2021/talk/BPJ3N7/", "title": "Going to Jupiter with Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Modern astrodynamics demands a lot from scientific-computing. Calculations are often expensive, and correct unit handling is essential. Sometimes, complex algorithms are needed to parse through vast amounts of data. Julia's efficient syntax, and rich and growing ecosystem has met these challenges with minimal developer effort throughout the development of GeneralAstrodynamics.jl. Feature development and research applications will be presented alongside a simple Earth-Jupiter transfer design.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10395, "code": "ZR87UR", "public_name": "Joe Carpinelli", "biography": "I'm an aerospace engineering MS student who will be graduating in May 2021. My academic research has primarily been space robotics software development. I've worked on an open source Julia package, `UnitfulAstrodynamics.jl`, throughout my graduate astrodynamics courses. I'll be working as an aerospace controls engineer on the Orion project starting in July 2021.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9907, "guid": "87663d26-05dc-5d89-a7ea-724e122f1b7e", "logo": "", "date": "2021-07-30T19:40:00+00:00", "start": "19:40", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9907-climacore-jl-tools-for-building-spatial-discretizations", "url": "https://pretalx.com/juliacon2021/talk/MXSRY8/", "title": "ClimaCore.jl: Tools for building spatial discretizations", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "This talk will cover ClimaCore.jl: a suite of tools for building spatial discretizations, primarily aimed at weather and climate modeling applications. It provides a high-level interface for composing multiple operators and functions, and are compatible with the SciML suite of differential equations solvers.", "description": "The Climate Modelling Alliance (CliMA) is building ClimateMachine.jl, a modern earth system model that can learn from data. On a technical side, we are developing the model entirely in Julia, using distributed parallelism with both GPU and CPU architectures. \r\n\r\nClimaCore.jl is a suite of tools we are building for our next iteration of Climate Machine.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1131, "code": "PKSECG", "public_name": "Simon Byrne", "biography": "Simon is the lead software engineer at the [CliMA project](https://clima.caltech.edu/).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9860, "guid": "72c0f2bf-c142-5bc6-81c9-064a81b5e2d0", "logo": "/media/juliacon2021/submissions/GBJ3HG/simulated_atm_flow04_Ru0WzFe.png", "date": "2021-07-30T19:50:00+00:00", "start": "19:50", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9860-climatemodels-jl-a-simple-interface-to-climate-models", "url": "https://pretalx.com/juliacon2021/talk/GBJ3HG/", "title": "ClimateModels.jl -- A Simple Interface To Climate Models", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Here we provides a uniform interface to climate models of varying complexity and completeness. Models that range from low dimensional to whole Earth System models are \r\nran and analyzed via this simple interface. Three examples illustrate this framework as applied to:\r\n\r\n- a stochastic path (zero-dimensional, Julia function)\r\n- a shallow water model (two-dimensional, Julia package)\r\n- a general circulation model (high-dim., feature-rich, fortran, MPI)", "description": "Key objectives of this project include:\r\n\r\n- make it as easy to run complex models as it is to run simple ones and, hopefully, so easy that that they can all be used interactively in classrooms \r\n- enable the Julia community to access widely-used, full-featured models right now and comfortably using notebooks, IDEs, terminal, and batch _(1)_.\r\n- enable the climate science community to leverage the booming Julia ecosystem for analyzing model output and experimenting with models _(2)_.\r\n- provide basic pipelining (e.g. Channel), book-keeping (e.g. Git), and documenting features (e.g. Pkg) to make complex workflows easier to reproduce, modify, and share with others.\r\n\r\n_(1) The MITgcm, used as example, has configurations for Ocean, Atmosphere, Cryosphere, Biosphere in forward as  well as an adjoint mode (via AD)._\r\n\r\n_(2) Both on-premise or via cloud based environments._", "recording_license": "", "do_not_record": false, "persons": [{"id": 10449, "code": "PFYSJ9", "public_name": "Gael Forget", "biography": "I work as a reseach scientist at the Massachusetts Institute of Technology (MIT) where I investigate oceanography and climate. As part of the Department of Earth, Atmospheric and Planetary Sciences, my work focuses on ocean modeling and the analysis of global ocean data sets such as Argo profile collections, satellite records of sea level, or ocean color retrievals. I co-develop computer programs in various languages and carry out ocean state estimation using the MIT general circulation model in order to interpolate and interpret ocean observations. My scientific interests include: ocean circulation and climate variability; tracer transport and turbulent transformation processes; interaction of ecological, geochemical, and physical processes; global cycles of heat, water, and carbon; observational statistics; forward and inverse modeling.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10340, "guid": "602bb7a8-2f1d-51db-87dc-a7c1bb84ba2f", "logo": "", "date": "2021-07-30T20:00:00+00:00", "start": "20:00", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-10340-space-engineering-in-julia", "url": "https://pretalx.com/juliacon2021/talk/E3MWHZ/", "title": "Space Engineering in Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Amazonia 1 was the first remote sensing satellite fully designed, integrated, tested, and operated by Brazil. It was developed by the National Institute for Space Research (INPE) and was launched on February 28, 2021. In this project, Julia language was frequently used in the mission analysis and the development of the attitude and orbit control subsystem (AOCS).", "description": "This talk presents how we used the packages ReferenceFrameRotations.jl, SatelliteToolbox.jl, and DifferentialEquations.jl to create a high fidelity simulator of the Amazonia-1\u2019s AOCS and perform numerous analyses related to this mission.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10877, "code": "8AFQPZ", "public_name": "Dr. Ronan Arraes Jardim Chagas", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9817, "guid": "968db876-f5ce-5ae1-abaa-837e5804c0d9", "logo": "", "date": "2021-07-30T20:10:00+00:00", "start": "20:10", "duration": "00:10", "room": "Blue", "slug": "juliacon2021-9817-in-situ-data-analysis-with-julia-for-e3sm-at-large-scale", "url": "https://pretalx.com/juliacon2021/talk/GJRKY3/", "title": "In-Situ Data Analysis with Julia for E3SM at Large Scale", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "In this talk, we will present our work of coupling the Julia runtime with E3SM, an advanced earth system simulation application for supercomputers, and running E3SM with swappable in-situ Julia modules at large scale. The talk includes (1) the Julia runtime coupling with legacy High-Performance Computing (HPC) applications (i.e., E3SM), (2) the design of two in-situ data analysis modules in Julia, and (3) the communication design for E3SM and the in-situ Julia modules.", "description": "The Energy Exascale Earth System Model (E3SM) is the Department of Energy's state-of-the-art earth system simulation model. It aims to address the most critical and challenging climate problems by efficiently utilizing DOE\u2019s advanced HPC systems. One of the challenges of E3SM (and other exascale simulations) is the imbalance between the great size of the generated simulation data and the limited storage capacity. This means that post hoc data analysis needs to be replaced with in-situ analysis, which analyzes simulation data as the simulation is running. Our work aims to use Julia to provide data scientists with a high-level and performant interface for developing in-situ data analysis algorithms without directly interacting with complex HPC codes. This talk discusses (1) high-level Julia runtime coupling with E3SM, (2) two in-situ data analysis modules in Julia, and (3) low-level communication between E3SM and the in-situ Julia modules.\r\n\r\nIn this project, we focus on the Community Atmosphere Model (CAM), which models the atmosphere and is one of E3SM\u2019s coupled modules. Our goal is to study extreme weather events that happen in the atmosphere, such as sudden stratospheric warmings (SSW) that can destabilize the polar vortex and cause extreme cold temperatures on earth surfaces. The primary design consideration of coupling Julia with E3SM is the identification of an appropriate entry point in E3SM\u2019s CAM for calling in-situ Julia modules. CAM is implemented in Fortran and simulates in the timestep style. The control module of CAM has access to the simulation data and is selected to be interfaced with the Julia runtime. To couple E3SM with Julia, (1) we have implemented a Fortran-based in-situ data adapter in the control module of CAM, which takes the CAM simulation data as input and internally passes the data to the Julia runtime. (2) We have implemented a C-based interface between the in-situ data adapter and the in-situ Julia modules. The C interface includes three major functions: initialization, cleanup and worker, which creates an in-situ Julia instance (by loading and initializing the in-situ Julia module from a specified path), destroys the Julia instance, and passes the data from the in-situ adapter to the in-situ Julia instance. Our Fortran in-situ adapter interface calls the worker function at every time step and initialization/cleanup functions at the first/last time step. (3) As E3SM mixes the usage of GNU Make and CMake for combining and compiling different E3SM components, we have added the Julia compilation flags for the C and Fortran interfaces into the CAM CMake file (i.e., header files) and the top-level GNU Make file (i.e., Julia libraries). The in-situ Julia module is only compiled when it is called during runtime, which avoids compiling the whole E3SM if the in-situ Julia module needs to be changed.\r\n\r\nWe have implemented two data analysis in-situ modules: linear regression and SSW. This linear regression approach models simulation variables as a function of simulation time. It can be used to track trends in variables of interest and to identify important checkpoints in the simulation. SSW characterizes midwinter stratospheric sudden warmings that often cause splitting of the stratospheric polar vortex. By definition, SSW occurs when the zonal mean of the zonal wind becomes reversed (easterly) at 60\u00b0N and 10 hPa and lasts for at least 10 consecutive days. This event can lead to extreme temperatures on the surface in northern America.\r\n\r\nThe worker function in the C interface aims to support efficient low-level data communication between E3SM and the in-situ Julia modules. To run at large-scale, E3SM adopts Message Passing Interface (MPI) and so the data is distributed among all the MPI ranks. Each MPI rank of CAM has access to only a local data block of CAM variables (e.g., velocity and temperature) and passes its local data block in 1D array to its own in-situ Julia instance through the C interface. When the in-situ Julia instance needs remote data (e.g., for computation of SSW) from other in-situ Julia instances, MPI.jl is used to implement the data communication between different in-situ Julia instances. However, one key design challenge is to make sure that E3SM and Julia use the same MPI communicator for correct data communication and this is challenging as current Julia C embeddings are not able to directly pass the MPI communicator. To address this challenge, we have developed two converters (i.e., in both C and Fortran formats) of MPI communicators for supporting different MPI libraries. Last, we have also evaluated the performance (i.e., overall overhead) of the worker function for providing valuable guidelines of running HPC applications with Julia at large-scale.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9790, "code": "Y8SZVN", "public_name": "LI TANG", "biography": "Dr Tang is a research scientist in the CCS-7 Programming Models team at Los Alamos National Laboratory. His research interests include programming model, co-design, performance/energy analysis and modeling. Dr Tang received his Ph.D. from the Department of Computer Science and Engineering at University of Notre Dame in 2017.", "answers": []}, {"id": 10405, "code": "GEBDZP", "public_name": "Earl Lawrence", "biography": "Group leader for Statistical Sciences at Los Alamos National Laboratory", "answers": []}], "links": [], "attachments": [], "answers": []}], "Purple": [{"id": 9566, "guid": "10f2f38b-fb05-5cb0-91b4-dee33bf40566", "logo": "/media/juliacon2021/submissions/VAGFD7/blobvis4_cropped_with_title_bsKhlfu.png", "date": "2021-07-30T12:30:00+00:00", "start": "12:30", "duration": "00:30", "room": "Purple", "slug": "juliacon2021-9566-adaptive-and-extendable-numerical-simulations-with-trixi-jl", "url": "https://pretalx.com/juliacon2021/talk/VAGFD7/", "title": "Adaptive and extendable numerical simulations with Trixi.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Trixi.jl is a numerical simulation framework for adaptive, high-order discretizations of conservation laws. It has a modular architecture that allows users to easily extend its functionality and was designed to be useful to experienced researchers and new users alike. In this talk, we will give an overview of Trixi\u2019s current features, present a typical workflow for creating and running a simulation, and show how to add new capabilities for your own research projects.", "description": "When doing research on numerical discretization methods, scientists are often faced with a dilemma when choosing the appropriate simulation tool: In the beginning of a project, you often want a code that is nimble and with low overhead, which allows rapid prototyping to assist you in experimenting with different approaches. Later on, however, you want to evaluate your newly developed methods and algorithms in a production setting and require a high-performance implementation, support for parallelization, and a full toolchain for postprocessing and visualizing your results.\r\n\r\nWith [Trixi.jl](https://github.com/trixi-framework/Trixi.jl), we try to bridge this gap by using a simple but modular architecture, which allows us to easily extend Trixi beyond the existing functionality. The main components, such as the mesh, the solvers, or the equations, can each be selected and combined individually in a library-like manner. At the same time, Trixi is a comprehensive numerical simulation framework for hyperbolic PDEs and comes with all necessary ingredients to set up a simulation, run it in parallel, and visualize the results.\r\n\r\nAt its core, various systems of equations are solved on hierarchical quadtree/octree grids that provide adaptive mesh refinement via solution-based indicators. The equations, e.g., compressible Euler, ideal MHD, or hyperbolic diffusion, are discretized with high-order discontinuous Galerkin spectral element methods, with support for entropy-stable shock capturing. Trixi puts an emphasis on having a fast implementation with shared memory parallelization, and integrates well with other packages of the Julia ecosystem, such as [OrdinaryDiffEq.jl](https://github.com/SciML/OrdinaryDiffEq.jl) for time integration, [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) for automatic differentiation, or [Plots.jl](https://github.com/JuliaPlots/Plots.jl) for visualization. One of the key goals of Trixi is to be useful to experienced researchers while remaining accessible for new users or students. Thus, we continuously strive to keep the implementation as simple as reasonably possible. \r\n\r\nDue to Julia\u2019s unique capabilities and ecosystem including [LoopVectorization.jl](https://github.com/JuliaSIMD/LoopVectorization.jl), serial performance of Trixi can be on par with large-scale C++ and Fortran projects in performance benchmarks using a subset of optimized methods. At the same time, the general framework is simple and extendable enough to allow porting new solver infrastructures within a few hours.\r\n\r\nIn this talk, we will give an overview of the currently implemented features and discuss the overall architecture of Trixi. We will show a typical workflow for creating and running a simulation, and present scientific results that were obtained with Trixi. Finally, we will demonstrate how to add new capabilities to Trixi for your own research projects.\r\n\r\nThe Jupyter notebook used for the live demonstration of Trixi.jl during the talk, as well as the presentation slides, can be found at https://github.com/trixi-framework/talk-2021-juliacon.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10161, "code": "ZBB3MC", "public_name": "Michael Schlottke-Lakemper", "biography": "I am a postdoctoral fellow and research software engineer at the [Numerical Simulation Research Group](https://www.mi.uni-koeln.de/NumSim) of the University of Cologne, Germany. My research focus is on numerical methods for adaptive multi-physics simulations, high-order schemes, and high-performance computing.", "answers": []}, {"id": 10183, "code": "WYXDAB", "public_name": "Hendrik Ranocha", "biography": "I am a Postdoctoral Fellow in the Cluster of Excellence at the University of M\u00fcnster, Germany. My research is focused on the analysis and development of numerical methods for partial and ordinary differential equations. In particular, I am interested in the stability of these schemes as well as mimetic and structure-preserving techniques, allowing the transfer of results from the continuous level to the discrete one.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9776, "guid": "44e7dadd-8a54-55ab-abb6-3e6169f0fdf8", "logo": "/media/juliacon2021/submissions/E7HKVW/image_2021-05-27_13-32-47_OYI3e3w.png", "date": "2021-07-30T13:00:00+00:00", "start": "13:00", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9776-3-6x-speedup-on-a64fx-by-squeezing-shallowwaters-jl-into-float16", "url": "https://pretalx.com/juliacon2021/talk/E7HKVW/", "title": "3.6x speedup on A64FX by squeezing ShallowWaters.jl into Float16", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "[ShallowWaters.jl](https://github.com/milankl/ShallowWaters.jl), a fluid circulation model that was written with a focus on 16-bit arithmetics, runs on A64FX 3.6x faster in Float16 compared to Float64 without a significant model degradation. Calculations were systematically rescaled to fit into the very limited range of Float16 guided by Sherlogs.jl. ShallowWaters.jl shows that 16-bit calculations on A64FX are indeed a competitive way to accelerate Earth-system simulations on available hardware.", "description": "Most Earth-system simulations run on conventional CPUs in 64-bit double precision floating-point numbers Float64, although the need for high precision calculations in the presence of large uncertainties has been questioned. The world\u2019s fastest supercomputer, Fugaku, is based on [A64FX microprocessors](https://www.fujitsu.com/global/products/computing/servers/supercomputer/a64fx/), which also support the 16-bit low precision format Float16. We investigate the Float16 performance on A64FX with [ShallowWaters.jl](https://github.com/milankl/ShallowWaters.jl), a fluid circulation model that was written with a focus on 16-bit arithmetics. It implements techniques that address precision and dynamic range issues in 16 bit. The precision-critical time integration is augmented to include Kahan\u2019s compensated summation to reduce rounding errors. Such a compensated time integration is as precise but faster than mixing 16 and 32-bit of precision. The very limited dynamic range available in Float16 is 6e-5 to 65504, as subnormals are inefficiently supported on A64FX. The bitpattern histogram analysis at runtime with [Sherlogs.jl](https://github.com/milankl/Sherlogs.jl) as well as its functionality to record stacktraces conditioned on the occurrence of subnormals were invaluable to limit the arithmetic range. Consequently, we benchmark speed-ups of 3.8x on A64FX with Float16 and 3.6x with compensated time integration to minimize model degradation. Although ShallowWaters.jl is simplified compared to large Earth-system models, it shares essential algorithms and therefore shows that 16-bit calculations on A64FX are indeed a competitive way to accelerate Earth-system simulations on available hardware.\r\n\r\nThis work used the [Isambard UK National Tier-2 HPC Service](http://gw4.ac.uk/isambard/) operated by GW4 and the UK Met Office, and funded by EPSRC.\r\n\r\nCo-authors  \r\n- [Sam Hatfield](https://www.ecmwf.int/en/about/media-centre/news/2020/accelerating-weather-forecasting-models-using-reduced-precision), European Centre for Medium-Range Weather Forecasts, Reading, UK \r\n- [Matteo Croci](https://www.maths.ox.ac.uk/people/matteo.croci), Mathematical Institute, University of Oxford, UK\r\n- [Peter D\u00fcben](https://www.ecmwf.int/en/about/who-we-are/staff-profiles/peter-dueben), European Centre for Medium-Range Weather Forecasts, Reading, UK\r\n- [Tim Palmer](https://www2.physics.ox.ac.uk/contacts/people/palmer), University of Oxford, UK", "recording_license": "", "do_not_record": false, "persons": [{"id": 4335, "code": "A9SQSW", "public_name": "Milan Kl\u00f6wer", "biography": "PhD student in Climate Computing  \r\nAtmospheric, Oceanic and Planetary Physics  \r\nUniversity of Oxford  \r\n\r\nmilan.kloewer@physics.ox.ac.uk  \r\n[www.milank.de](https://milank.de)  \r\ntwitter [@milankloewer](https://twitter.com/milankloewer)  \r\ngithub [@milankl](https://github.com/milankl)", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9432, "guid": "863fb558-73fd-5d7a-b783-58f343651fda", "logo": "/media/juliacon2021/submissions/RPBHWE/Screen_Shot_2021-03-04_at_18.52.45_K3lYLLM.png", "date": "2021-07-30T13:10:00+00:00", "start": "13:10", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9432-waterlily-jl-real-time-fluid-simulation-in-pure-julia", "url": "https://pretalx.com/juliacon2021/talk/RPBHWE/", "title": "WaterLily.jl: Real-time fluid simulation in pure Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "WaterLily.jl is a new fluid dynamics simulation package written in pure Julia to take advantage of its speed and its active modelling, linear algebra, and machine learning communities. This talk will give an overview of the simulation approach, detail some of the Julia-specific aspects of the code (CartesianIndices for multidimensional algorithms and JuliaDiff for distance-function-based geometries), present a few examples, and discuss the future goals for the package.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 9780, "code": "EWGM8B", "public_name": "Gabriel Weymouth", "biography": "Prof of marine hydrodynamics & biologically inspired engineering at University of Southampton, physics-based machine learning at Alan Turing Institute. https://weymouth.github.io/", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9713, "guid": "d39bf544-fc8b-599d-8811-541adc3d97d4", "logo": "", "date": "2021-07-30T13:20:00+00:00", "start": "13:20", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9713-new-tools-to-solve-pdes-in-julia-with-gridap-jl", "url": "https://pretalx.com/juliacon2021/talk/HFHLDS/", "title": "New tools to solve PDEs in Julia with Gridap.jl", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "In this talk, we explore the novel capabilities of Gridap to solve Partial Differential Equations (PDEs) in Julia. This includes new features like a high-level API to write the PDE weak form with a syntax almost identical to the math notation, support for automatic differentiation, and simulation of PDEs on manifolds and domains of mixed geometrical dimensions. We will showcase these techniques with representative applications and performance comparisons against codes implemented in C/C++.", "description": "Gridap is a new, open-source, finite element (FE) library implemented in the Julia programming language. The main goal of Gridap is to adopt a more modern programming style than existing FE applications written in C/C++ or Fortran in order to simplify the simulation of challenging problems in science and engineering and improve productivity in the research of new discretization methods. The library is a feature-rich general-purpose FE code able to solve a wide range of partial differential equations (PDEs), including linear, nonlinear, and multi-physics problems. Gridap is extensible and modular. One can implement new FE spaces, new reference elements, and use external mesh generators, linear solvers, and visualization tools. In addition, it blends perfectly well with other packages of the Julia package ecosystem, since Gridap is implemented 100% in Julia.\r\n\r\nOne of the distinctive features of the library is a high-level API allowing one to simulate complex PDEs with very few lines of code. This API makes possible to write the PDE weak form in a syntax almost identical to the mathematical notation. In some sense, the high-level API of Gridap resembles to the one of FE codes based on symbolic domain-specific languages like UFL in FEniCS, but, in contrast, Gridap does not consider any compiler of variational forms nor C/C++ code generation facilities. Instead, the library takes advantage of the Julia JIT compiler to generate efficient machine code for the particular problem the user wants to solve, which makes the Gridap much easier to maintain and extend.\r\n\r\nThe Gridap project was initially presented in last year's JuliaCon. Since then, a number of new important features have been added, including an enhanced syntax for writing the PDE weak form, the support of more PDE types, and the support of more numerical techniques. In JuliaCon2021, we would like to showcase these updates via a set of representative use cases and challenging applications such as fluid-structure interaction problems.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4053, "code": "TJKSVY", "public_name": "Francesc Verdugo", "biography": "Francesc Verdugo PhD is assistant research professor at CIMNE (Barcelona, Spain) and he is interested in the research of new discretization methods to solve partial differential equations (PDEs). He is co-founder of the Gridap.jl project to solve PDEs in Julia.", "answers": []}, {"id": 10349, "code": "EQAZAW", "public_name": "Eric Neiva", "biography": "Postdoctoral researcher at the International Centre for Numerical Methods in Engineering", "answers": []}, {"id": 10350, "code": "RHYTX3", "public_name": "Oriol Colomes", "biography": null, "answers": []}, {"id": 10363, "code": "KYRPFM", "public_name": "Santiago Badia", "biography": "Santiago Badia is Professor of Computational Mathematics at Monash since June 2019. He obtained his PhD at Universitat Polit\u00e8cnica de Catalunya (UPC) in 2006. Previously, he worked at the Applied Mathematics departments at Politecnico di Milano (Italy) in 2006 and Sandia National Labs (New Mexico, USA) in 2007-08. He joined UPC in 2009, where he was appointed Professor of Computational Science and Engineering in 2017. He is adjoint researcher at CIMNE (Barcelona), where he leads the Large Scale Scientific Computing Department.\r\n\r\nHe works on the numerical approximation of partial differential equations (PDEs), e.g., using finite element methods, for modelling fluid and solid mechanics, electromagnetics, and multiphysics problems. He is particularly interested in large scale scientific computing and numerical linear algebra.\r\n\r\nAs a by-product of his research, Prof Badia leads some high-performance scientific projects, like FEMPAR. FEMPAR provides state-of-the-art numerical discretizations of PDEs and highly scalable numerical linear algebra solvers. FEMPAR has been used to model metal additive manufacturing, superconductor devices, breeding blankets in fusion reactors, or nuclear waste repositories. It has attained perfect weak scalability up to 458,672 cores in JUQUEEN (Germany) solving up to 60 billion unknowns. In 2019 he co-started the Gridap project, which heavily relies on functional programming and multiple dispatching in Julia, with the aim to create an easy-to-use but very efficient PDE solver.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9922, "guid": "d5f680cd-934d-534d-a86f-ccfb428ab1c6", "logo": "/media/juliacon2021/submissions/39HB9T/ITensor_logo_zsz5Ea7.png", "date": "2021-07-30T13:30:00+00:00", "start": "13:30", "duration": "00:30", "room": "Purple", "slug": "juliacon2021-9922-what-s-new-in-itensors-jl", "url": "https://pretalx.com/juliacon2021/talk/39HB9T/", "title": "What's new in ITensors.jl", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "Tensor networks encapsulate a large class of low rank decompositions of very high order -- potentially infinite order -- tensors. They have found a wide variety of uses in physics, chemistry, and data science. ITensors.jl is a high performance Julia library with a unique memory independent interface that makes it easy to use and develop tensor network algorithms. In this talk, I will give an overview of the library and new features that have been added since its release last year.", "description": "In JuliaCon 2019, we gave an early preview of ITensors.jl, a ground-up pure Julia rewrite of ITensor, a high performance C++ library for using and developing tensor network algorithms. ITensors.jl v0.1 was officially released in May of 2020. Since then, there has been a lot of development of the library as well as a variety of spinoff libraries, such as ITensorsGPU.jl that adds a GPU backend for tensor operations,  ITensorsVisualization.jl for visualizing tensor networks, PastaQ.jl for using tensor networks to simulate and analyze quantum computers, ITensorGaussianMPS.jl for creating tensor networks of noninteracting quantum systems, as well as more experimental libraries like ITensorsGrad.jl for adding automatic differentiation support and ITensorInfiniteMPS.jl for working with infinite tensor networks. In addition, many advanced features have been added to ITensors.jl and its underlying sparse tensor library NDTensors.jl, such as multithreaded block sparse tensor contractions, alternative dense contraction backends like TBLIS, contraction sequence optimization, and more. In this talk, I plan to give an overview of the current libraries and capabilities as well as lay out a roadmap for where the Julia ITensor ecosystem is heading.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4147, "code": "8Q8AYS", "public_name": "Matthew Fishman", "biography": "Matthew Fishman received a PhD in physics from Caltech in the spring of 2018. His thesis was on the development of new tensor network algorithms for studying quantum many-body systems. In the fall of 2019, he started as an Associate Data Scientist at the Center for Computational Quantum Physics, part of the Flatiron Institute in New York City. There, he is lead developer of the C++ and Julia versions of the ITensor library, a leading software package for performing tensor network calculations.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9579, "guid": "b02858ff-9a7b-51b7-9eba-2df35e28b8dc", "logo": "", "date": "2021-07-30T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "Purple", "slug": "juliacon2021-9579-applied-measure-theory-for-probabilistic-modeling", "url": "https://pretalx.com/juliacon2021/talk/U7AM33/", "title": "Applied Measure Theory for Probabilistic Modeling", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We'll give an overview of MeasureTheory.jl, describing some of the advantages relative to Distributions.jl and some applications in probabilistic modeling.", "description": "We have several goals for MeasureTheory.jl:\r\n- Better performance than Distributions.jl, because normalizing constants can be deferred\r\n- Minimal type constraints, for example allowing symbolic manipulations\r\n- Autodiff-friendly code\r\n- Multiple parameterizations for a given measure\r\n- A consistent interface, especially important for probabilistic programming\r\n- Composability, to make it easy to build new measures from existing ones\r\n- Fall-back to Distributions.jl when needed\r\n\r\nWhile the library is still in its early stages, we're making good progress on all fronts. We hope this can become the library of choice as a basis for probabilistic modeling in Julia, and we're excited to help the Julia community get involved in development.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1004, "code": "A7PDM3", "public_name": "Chad Scherrer", "biography": "Hi, I'm Chad. My interests range from applied problems through \"technology transfer\", to applied research. I've been involved in probabilistic programming for the last ten years, and have led design of a few prototype systems. Since 2015 I've been very interested in Julia, resulting in Soss.jl and MeasureTheory.jl, as well as some utility packages around these.\r\n\r\nMost recently I've founded Informative Prior, where I'm available for contract consulting work involving teaching, development, or application of probabilistic modeling software.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9696, "guid": "cbf15a36-904d-51f9-b63c-3cf4af766139", "logo": "", "date": "2021-07-30T19:30:00+00:00", "start": "19:30", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9696-fouriertools-jl-working-with-the-frequency-space", "url": "https://pretalx.com/juliacon2021/talk/J8CRXY/", "title": "FourierTools.jl | Working with the Frequency Space", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "FourierTools.jl aims at simplifying work in Fourier/Frequency space without loosing efficiency. \r\nWe provide several convenient wrappers to speed-up the common `fft(fftshift(x))` pattern.\r\nThis package also brings functionality to up and downsample signals through sinc interpolation. \r\nFurthermore, based on FFTs it provides shearing, rotation, convolution and (sub) pixel shift functions which can be applied to N-dimensional data efficiently.", "description": "Fourier space is commonly used for convolution operations, as the Fast Fourier Transformation (FFT) is, as its name may suggest, O(N log N) fast. The FFT algorithm typically produces data at a mangled form that makes it difficult to directly apply functions to. `fftshift` is a way to deal with this but involves data copies. \r\nBased on the packages ShiftedArrays.jl and PaddedViews.jl, the FourierTools.jl package implements views to the results of the FFTW routines `fft` and `rfft` and their inverse `ifft` and `irfft` including the respective `fftshift` operations but implemented as views rather than copying data. The indexing is, in notable difference to FFTViews.jl kept as ordinary arrays are indexed. This helps with the seamless integration across packages. \r\nTo implement an FFT-based `resample` operation of real-valued data, a new view, derived from `AbstractArray` is introduced, handling potential copy and addition operations for even-sized arrays to enforce the real-valuedness of the corresponding real space data (`select_region_ft`). In the community it has been [discussed](https://discourse.julialang.org/t/sinc-interpolation-based-on-fft/52512), whether such an operation is necessary. Referring to this discussion, we argue that the Fourier-space operations cannot be replaced by casting to `real`, since the latter violates Parseval's theorem. \r\nIn addition to the `resample` operation `FourierTools.jl` also provides a tool for sub-pixel shifting based FFTs. Further algorithms like shearing, sub-pixel shifting and rotation can be also implemented via the use of the Fourier shift theorem and due to the generality of the FFT these can be applied to N-dimensional datasets efficiently.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10334, "code": "CNV3SE", "public_name": "Rainer Heintzmann", "biography": "My research focuses on developing tools to image cellular function at high resolution. We develop techniques to measure multidimensional information in small biological objects such as cells, cellular organelles or other small structures of interest. Computer-based reconstruction methods, especially inverse-modeling based in automatic differentiation are of primary interest.", "answers": []}, {"id": 9921, "code": "U3YH9P", "public_name": "Felix Wechsler", "biography": "[Felix Wechsler](https://felixwechsler.science) studied Physics and Informatics at the Technical University of Munich in Germany. For his master studies in Photonics he moved to Jena (city of light). Currently he finishes his master thesis in the field of computational microscopy at the [Biomedical Imaging Group of Leibniz Institute of Photonic Technology](https://nanoimaging.de/) under the joint supervision of Rainer Heintzmann and Ivo Ihrke.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11679, "guid": "5598daed-e996-51ba-8034-7196f74a168d", "logo": "", "date": "2021-07-30T19:40:00+00:00", "start": "19:40", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-11679-intervallinearalgebra-jl-linear-algebra-done-rigorously", "url": "https://pretalx.com/juliacon2021/talk/WA7BP8/", "title": "IntervalLinearAlgebra.jl: Linear algebra done rigorously", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Solving linear systems is central in most computational domains, from mathematics to engineering applications. This talk will introduce IntervalLinearAlgebra.jl: a package written in Julia to solve linear systems, with interval or real coefficients, rigorously. That is, producing a set guaranteed to contain the true solution of the original problem. This can be applied to solve problems involving uncertainty propagation or perform self-validated computations.", "description": "Linear systems arise in practically all domains involving numerical computations. While several efficient floating-point algorithms are available, the final output has no information about how close to the true solution the computed result is. To overcome this, interval arithmetic offers a framework to perform rigorous computations, where real numbers are replaced by intervals guaranteed to contain the true value.\r\n\r\nThe talk will introduce my Google Summer of Code (GSoC) project: the development of IntervalLinearAlgebra.jl, a package to solve both interval and real linear systems rigorously. During the talk, I will highlight the main features of the package. First, I will give an overview of interval linear systems and demonstrate how to use the package to determine the exact solution, highlighting that even in lower dimensions the solution set can have complex non-convex shapes.\r\n\r\nMotivated by this, I will show how to determine a tight enclosure of the solution of an interval linear system, showing the several solution strategies implemented in the package. The presented algorithms will be compared in terms of accuracy and computation time, highlighting the pros and cons of each. During the talk, I will also discuss the lesson learnt during the development process as well as the roadmap beyond GSoC.", "recording_license": "", "do_not_record": false, "persons": [{"id": 12269, "code": "PTCVCM", "public_name": "Luca Ferranti", "biography": "PhD student in computer science at the University of Vaasa. Research interests in compuational methods for efficient and reliable positioning.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9450, "guid": "d57a9efa-d013-5f20-a829-2af97f60296b", "logo": "", "date": "2021-07-30T19:50:00+00:00", "start": "19:50", "duration": "00:10", "room": "Purple", "slug": "juliacon2021-9450-global-sensitivity-analysis-for-sciml-models-in-julia", "url": "https://pretalx.com/juliacon2021/talk/CLKYFN/", "title": "Global Sensitivity Analysis for SciML models in Julia", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Majority of scientific modelling workflows involve doing global sensitivity analysis as an intermediate step. It can be used primarily in two stages, either before parameter estimation to simplify the fitting problem by fixing unimportant parameters or for analysis of the input parameters' influence on the output. GlobalSensitivity.jl is a package in the SciML ecosystem that provides a full suite of GSA methods that can be of great utility to a lot of practitioners.", "description": "Global Sensitivity Analysis quantifies the influence of input parameters on the model output. Hence some of the core questions we wish answer with models such as identification of most influential parameters, makes GSA an essential part of modelling workflow. GlobalSensitivity.jl [1] is a generalized GSA package with built-in support for parallelism integrated with the pharmaceutical modeling and simulation platform Pumas[2]. Our implementation of GSA for differential equation based mechanistic pharmacometrics, PBPK and QsP models gives order of magnitude speedups over GSA capabilities of other languages. Currently GlobalSensitivity.jl supports the Sobol, Morris, eFAST, Regression based, DGSM, Delta Moment, EASI, Fractional Factorial and RBD-FAST GSA methods.\r\n\r\nThe talk covers running GSA workflow on a Lotka-Volterra differential equation written in the DifferentialEquations.jl interface.\r\n\r\n[1] url: https://gsa.sciml.ai/stable/.\r\n[2] url: https://github.com/PumasAI/PumasTutorials.jl/blob/master/tutorials/pkpd/hcvgsa.jmd", "recording_license": "", "do_not_record": false, "persons": [{"id": 10006, "code": "7YFPLU", "public_name": "Vaibhav Dixit", "biography": "Vaibhav is involved in building analysis tooling in the SciML ecosystem in Julia and one of the developers of Pumas (https://pumas.ai).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9936, "guid": "5bff83d0-7ff3-586b-8e11-f352f02171f0", "logo": "/media/juliacon2021/submissions/LUVWJZ/Screenshot_2021-04-01_at_10.48.34_TUdRr5f.png", "date": "2021-07-30T20:00:00+00:00", "start": "20:00", "duration": "00:30", "room": "Purple", "slug": "juliacon2021-9936-zigzagboomerang-jl-parallel-inference-and-variable-selection", "url": "https://pretalx.com/juliacon2021/talk/LUVWJZ/", "title": "ZigZagBoomerang.jl - parallel inference and variable selection", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "[ZigZagBoomerang.jl](https://t.co/5MIOOlhGjZ) provides piecewise deterministic Monte Carlo methods. They have the same goal as classical Markov chain Monte Carlo methods: to sample for example from the posterior distribution in a Bayesian model. Only that the distribution is explored through the continuous movement of a particle and not one point at a time. This provides new angles of attack: I showcase a multithreaded sampler and high-dimensional variable selection sampler.", "description": "## [ZigZagBoomerang.jl](https://github.com/mschauer/ZigZagBoomerang.jl) - parallel inference and variable selection\r\n\r\nZigZagBoomerang.jl provides piecewise deterministic Monte Carlo (PDMC) methods. They have the same goal as classical Markov chain Monte Carlo methods: to sample from a probability distribution, for example the posterior distribution in a Bayesian model. Only that the distribution is explored through the continuous movement of a particle and not one point at a time. The particle changes direction at random times and moves otherwise on deterministic trajectories. For example it may move with constant velocity along a line, see the picture. The random direction changes are calibrated such that the trajectory of the particle samples the target distribution, in general the particle is turned back (reflected) when moving too far into the tails of the distribution. From the trajectory, the quantities of interest, such as the posterior mean and standard deviation, can be estimated.\r\n\r\nThe decision of whether to change direction in one coordinate only requires the evaluation of a partial derivative which depends on few coordinates \u2013 the neighbourhood of the coordinate in the Markov blanket. That allows exploiting multiple processor cores using Julia's multithreaded parallelism (or other forms of parallel computing). The difference between threaded Gibbs sampling and threaded PDMP is that in Gibbs sampling part of the state is fixed, while the other part is changed. Here, the particle never ceases to move, and it is the decisions about direction changes which happen in parallel on subsets of coordinates. Metaphorically speaking this is the difference between walking, where one foot is on the ground all the time, and running, where both feet are in the air between steps. \r\n\r\nBecause the particle moves on a deterministic trajectory between the times of random events, one can determine exactly the time when the process would leave an area of interest. That allows to sample distributions of bounded support, or spending additional time in a lower dimensional subset of the space, the basis of variable selection with the sticky PDMPs in high dimensional sparse inference problems.\r\n\r\nIn the presentation I showcase a multithreaded sampler and high-dimensional variable selection with sticky PDMPs.\r\n\r\n### Links\r\n\r\n* [ZigZagBoomerang.jl](https://github.com/mschauer/ZigZagBoomerang.jl)\r\n* Discourse Announcement: [[ANN] `ZigZagBoomerang.jl`](https://discourse.julialang.org/t/ann-zigzagboomerang-jl/57287) \r\n* Joris Bierken's [Overview over Piecewise Deterministic Monte Carlo](https://diamweb.ewi.tudelft.nl/~joris/pdmps.html)\r\n\r\n### Literature\r\n\r\n1. Joris Bierkens, Paul Fearnhead, Gareth Roberts: The Zig-Zag Process and Super-Efficient Sampling for Bayesian Analysis of Big Data. *The Annals of Statistics*, 2019, 47. Vol., Nr. 3, pp. 1288-1320. [https://arxiv.org/abs/1607.03188].\r\n2. Joris Bierkens, Sebastiano Grazzi, Kengo Kamatani and Gareth Robers: The Boomerang Sampler. *ICML 2020*. [https://arxiv.org/abs/2006.13777].\r\n3. Joris Bierkens, Sebastiano Grazzi, Frank van der Meulen, Moritz Schauer: A piecewise deterministic Monte Carlo method for diffusion bridges.  *Statistics and Computing*, 2021 (to appear). [https://arxiv.org/abs/2001.05889].\r\n4. Joris Bierkens, Sebastiano Grazzi, Frank van der Meulen, Moritz Schauer: Sticky PDMP samplers for sparse and local inference problems.  2020. [https://arxiv.org/abs/2103.08478].", "recording_license": "", "do_not_record": false, "persons": [{"id": 4440, "code": "PZQ7NJ", "public_name": "Moritz Schauer", "biography": "I am Associate Senior Lecturer at the Department of Mathematical Sciences of Chalmers University of Technology and University of Gothenburg and working on statistical theory and methodology for dynamical stochastic models. In general, dynamical stochastic models describe the evolution of processes and systems which have dynamics with temporal or spatial interactions and show stochastic behaviour. Applications of such models are found in all areas, be it to model the change in the extension of the West Antarctic ice shelf, the interaction of neurons in the brain or the deformation of tissue during tumour growth. \r\n\r\n* Github: https://github.com/mschauer\r\n* Academic website: http://www.math.chalmers.se/~smoritz/index.htm\r\n* Twitter: [@MoritzSchauer](https://twitter.com/MoritzSchauer)", "answers": []}], "links": [], "attachments": [], "answers": []}], "BoF/Mini Track": [{"id": 9918, "guid": "da2cd6e0-82d5-50d0-ae56-cf26719fccb8", "logo": "/media/juliacon2021/submissions/FBTSYM/cartoon_caBWQXM.png", "date": "2021-07-30T12:30:00+00:00", "start": "12:30", "duration": "01:30", "room": "BoF/Mini Track", "slug": "juliacon2021-9918-julia-for-biologists", "url": "https://pretalx.com/juliacon2021/talk/FBTSYM/", "title": "Julia for Biologists", "subtitle": "", "track": null, "type": "Birds of Feather", "language": "en", "abstract": "This session is tailored to anyone with a general interest in Julia for Biologists. Join us to meet like minded people, exchange thoughts and develop ideas on Julia and its application in the biological sciences. \r\n\r\nThe session has 3 parts: \r\n1. Who is in the room? ~ 15 min  \r\n2. Presentation \u201cA perspective: Julia for Biologists\u201d by E. Roesch  ~ 25 min\r\n3. Discussion ~ 50 min\r\n\r\nA recorded version of 2. will be made available afterwards but the session itself will NOT be recorded.", "description": "\u201cBirds of a Feather flock together\u201d \u2014 Whether you see yourself as a biologist, software developer, mathematician or anything in between, the objective of this session is to provide a welcoming and discussion-stimulating environment to strengthen the Julia community in the biological sciences. Independent of your Julia skills level, we are curious to hear what brings you to this area, what you love about it and where you feel like is room for improvement.", "recording_license": "", "do_not_record": true, "persons": [{"id": 1086, "code": "A9GFJJ", "public_name": "Elisabeth Roesch", "biography": "I am a Ph.D. student in the Theoretical Systems Biology Group at the University of Melbourne led by Prof. Michael Stumpf. I focus my research on hybrid models, in which I combine mechanistic modelling techniques, e.g. differential equations, with machine learning approaches such as neural networks. I am passionate about using hybrid models in developmental biology to enhance our understanding of cell fate decision making.\r\n\r\nIn 2017, I received a Bachelor of Science in Bioinformatics from the Technical University of Munich and the Ludwig Maximilian University of Munich. In 2018, I graduated from Imperial College London with a Master of Science in Bioinformatics and Theoretical Systems Biology.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11725, "guid": "fe0c03c4-9b29-52b8-bcf2-7d273ac20321", "logo": "", "date": "2021-07-30T16:30:00+00:00", "start": "16:30", "duration": "01:30", "room": "BoF/Mini Track", "slug": "juliacon2021-11725-virtual-posters-session", "url": "https://pretalx.com/juliacon2021/talk/NBER8M/", "title": "Virtual posters session", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "The virtual poster session will include 100 posters hosted on gathertown. Link to all the posters: https://juliacon.org/2021/posters/", "description": "", "recording_license": "", "do_not_record": false, "persons": [], "links": [], "attachments": [], "answers": []}, {"id": 9640, "guid": "ba5415c3-43e5-5c12-b899-288d687b161a", "logo": "/media/juliacon2021/submissions/GFEPY7/2015annual_tvQhzoD.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9640-watching-earth-at-night", "url": "https://pretalx.com/juliacon2021/talk/GFEPY7/", "title": "Watching earth at night", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Hundreds of researchers use nighttime lights as a measure of economic activity. While NOAA and NASA release the data, there is a lack of open-source implementations and a lack of efficient computing frameworks through which this data can be utilised at modest levels of computational budgets. In our open-source Julia package, we have pushed the frontier on statistical methods for cleaning this data, making these techniques, alongside traditional methods, available to researchers.", "description": "The package, NighttimeLights.jl, was a foundation for a research paper, \"But clouds got in my way: bias and bias correction of VIIRS nighttime lights data in the presence of clouds\" by Ayush Patnaik, Ajay Shah, Anshul Tayal, Susan Thomas. This paper diagnoses a source of bias in the data and responds to this problem with a bias correction scheme. Along with other mainstream methods of data cleaning, this method is also implemented in the package.\r\n\r\nWhile there are packages to do image processing in Julia and packages to handle geostationary data, the assumptions about the sensor producing the data, such as in Images.jl, make it incompatible with nighttime lights data. We built the package from scratch without making any assumptions about the sensor. Functions in the package take regular float 3D arrays as input, which makes it possible to extend the package to data from any sensor and not just VIIRS nighttime lights.\r\n\r\nIn summary, our work is at the global frontier of exploiting nighttime lights data, and the first open-source implementation of such work, and harnesses Julia to make the large scale computation uniquely accessible within modest computational budgets.", "recording_license": "", "do_not_record": false, "persons": [{"id": 982, "code": "TAXX8K", "public_name": "Ayush Patnaik", "biography": "Research consultant xKDR", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9767, "guid": "00020305-3628-58c3-ab3c-4f7b87e3d0a6", "logo": "/media/juliacon2021/submissions/DXEEDM/geothermalcloud-small_2BIQoSW.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9767-geothermalcloud-fusion-of-big-data-and-multi-physics-models", "url": "https://pretalx.com/juliacon2021/talk/DXEEDM/", "title": "GeoThermalCloud: Fusion of Big Data and Multi-Physics Models", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "GeoThermalCloud is an open-source machine-learning framework for geothermal exploration. It has been applied for the discovery, exploration, and development of Hidden Geothermal Resources.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10383, "code": "PMRGDL", "public_name": "Velimir Vesselinov", "biography": "My expertise is in applied mathematics, computer science and engineering. My research is in the general area of data analytics, model diagnostics and machine learning. I am the inventor and lead developer of a series of novel theoretical methods and computational related to machine learning, data analytics, model diagnostics, and data inference tools. I am also a co-inventor of LANL-patented machine-leaning methodology. Over the years, I have been the principal investigator of several projects for machine learning, model development, model analyses, uncertainty quantification and decision support", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9862, "guid": "b333e9b7-0c50-57ad-a169-d1747ee287a1", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9862-a-quick-dive-into-julia-s-type-inference-algorithm", "url": "https://pretalx.com/juliacon2021/talk/ZZ8KFP/", "title": "A quick dive into Julia's type inference algorithm", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "This poster will introduce the abstract interpretation algorithm proposed by \"Mohnen, M., 2002, April. A graph-free approach to data-flow analysis\", that Julia's type inference routine is based on, along with a sample Julia implementation of it.\r\nWe will also explain how the original algorithm is partially wrong as well as how it can be fixed, and also hopefully present the corrected proofs of the algorithm's termination and correctness.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 4222, "code": "8BZR7G", "public_name": "Shuhei Kadowaki", "biography": "A research programmer working at Julia Lab, MIT. Working on Julia's compiler technology stack, mainly around its abstract interpretation based type inference. Aso a maintainer of Julia IDEs, [julia-vscode](https://www.julia-vscode.org/) and [Juno](https://junolab.org/).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9668, "guid": "6f9b4ed5-3b23-5c76-9daf-2e703f699509", "logo": "/media/juliacon2021/submissions/MHNZUS/logo_8UOj0Of.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9668-cobrexa-jl-constraint-based-reconstruction-exa-scale-analysis", "url": "https://pretalx.com/juliacon2021/talk/MHNZUS/", "title": "COBREXA.jl: COnstraint-Based Reconstruction & EXa-scale Analysis", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "COBREXA.jl is a Julia package for high-performance huge-scale constraint-based reconstruction and analysis of biological models at the exa-scale. This package allows billions of individual genome-scale metabolic models to be constructed simultaneously, and makes analysis of the resulting trillions of reactions straightforward and efficient. We will show the functionality of COBREXA.jl on biological datasets, demonstrate the user interface, and highlight where and how COBREXA.jl addresses current", "description": "The primary purpose of the newly developed COBREXA.jl package is to facilitate the construction and analysis of community-sized, genome-scale metabolic models in high-performance computing (HPC) environments. By taking advantage of Julia's rich ecosystem of high-performance computational tools, as well as many language features unique to Julia, we enable the massively parallel processing of constrained-based metabolic models. This unlocks the ability to screen vast amounts of organism variants and generate novel biological insights about large-scale communities of microorganisms. We will demonstrate the flexible user interface and the scalability of the package, utilizing an HPC cluster for demonstration. Additionally, we will showcase the new SBML.jl package for loading and working with the models stored in the community standard Systems Biology Markup Language (SBML). Finally, we will highlight some easily achievable results on concrete multi-organism models using this interface.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4287, "code": "AVXQCK", "public_name": "Miroslav Kratochv\u00edl", "biography": "I'm a postdoctoral researcher at the Luxembourg Centre for Systems Biomedicine, recently finished my PhD at Charles university in Prague, Dept. of SW engineering. I'm working on various computationally intensive problems in bioinformatics and cheminformatics.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9291, "guid": "d009d40a-96a9-5040-a5bd-5ca24ab53704", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9291-deferredacceptance-solving-and-analyzing-school-choice-problems", "url": "https://pretalx.com/juliacon2021/talk/ALS3ZQ/", "title": "DeferredAcceptance: Solving and analyzing school-choice problems", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "I introduce DeferredAcceptance, a Julia package that solves both discrete and nonatomic school-choice problems using a variety of modern algorithms.", "description": "The stable assignment problem, introduced in the 1960s by David Gale and Lloyd Shapley, has recently elicited new interest due to its applications in public school assignment and a new, nonatomic framing that relates stable school assignments to market-clearing cutoff vectors. I introduce DeferredAcceptance, a Julia package for solving and analyzing school-choice problems. It provides several variations of the discrete Gale-Shapley and top-trading cycles algorithms, as well as a trio of memory-efficient algorithms for computing an equilibrium in nonatomic admissions markets. In the discrete case, while there are some open-source tools available for running the basic form of the Gale-Shapley algorithm, DeferredAcceptance enables seamless comparison of a variety of assignment procedures for given market data. In the nonatomic case, DeferredAcceptance provides school-demand functions based on the multinomial logit choice model and a variety of scoring schemes; it also permits a user-defined demand function, enabling simulation of a wide range of competitive scenarios.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9733, "code": "ZJHGRZ", "public_name": "Max Kapur", "biography": "I am a graduate student  in the department of industrial engineering at Seoul National University in South Korea.\r\n- Github: [https://github.com/maxkapur](github.com/maxkapur)\r\n- Email: maxkapur@gmail.com\r\n- Blog: [maxkapur.com](maxkapur.com)", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9903, "guid": "deee4f9f-76b7-5e57-bbbf-c8018b5aefd5", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9903-soft-realtime-control-of-an-exoplanet-imaging-instrument", "url": "https://pretalx.com/juliacon2021/talk/ATNVGH/", "title": "Soft Realtime Control of an Exoplanet Imaging Instrument", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "To photograph nearby systems of exoplanets, astronomical instruments require the use of advanced real time control techniques to counteract the shimmering turbulence of the Earth\u2019s atmosphere. We will show how we are using Julia in our lab to record and process images from high speed cameras, send control signals hundreds of times per second, and present a rich graphical interface with live telemetry. We will discuss technical considerations on using Julia in this domain.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10488, "code": "BHARS7", "public_name": "William Thompson", "biography": "I am a PhD student at the University of Victoria and Canada's National Research Council working on astronomy instrumentation and the science of exoplanet direct imaging.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9946, "guid": "4afb35b5-755d-586a-936c-10fa9b3c762c", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9946-simulation-of-additive-manufacturing-processes-in-julia", "url": "https://pretalx.com/juliacon2021/talk/TQ8GS3/", "title": "Simulation of additive manufacturing processes in Julia", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "Illustrated on the example of a heat transfer problem (Additive manufcaturing process simulation) where individual voxels are actived over time, we review the porting from MATLAB Code to Julia. Furthermore, we investigate the resulting increase of performance, emerging challenges, GPU usage and newly created opportunities.", "description": "In selective laser melting, a powder material is locally melted by a laser and forms a coherent solid structure after cooling. As a major advantage this process allows the fabrication of complex geometries and is suitable for various materials. On the downside, the process is associated with extreme cooling rates and therefore large temperature gradients, which lead to anisotropic material properties and, in worst case, to inferior component properties. Hence process parameters such as laser power, scanning speed and layer height must be determined optimally and individually for each component. Due to vast range and variety of influencing factors and parameters, simulations provide an ideal environment for test and development purpose. In order to consider process effects and interactions in a uniform manner to take the effects and interactions of the process into account in a uniform manner, simulations from micro to macro level with associated time scales are necessary. As a consequence, computational heavy and tedious models need to be solved. Current implementations are mostly available in MATLAB, which leads to performance bottlenecks at several points. Due to its performance, syntax and free availability by MIT license, Julia provides an excellent opportunity to completely detach previous implementations from MATLAB and to use Julia as a holistic framework in the future. Particularly the possibility of fully integrating the graphics processing unit (GPU) into computation while still programming in Julia, promises a well readable and still very performant code for the high performance computing (HPC) application.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10515, "code": "GEKS77", "public_name": "Luca Lubeto", "biography": "My name is Luca Luberto and I am a PhD student at the Institute of Computational Phyiscs in Engineering, Technical University of Kaiserslautern. \r\nCurrently I am working on the simulation of selective laser melting.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9635, "guid": "839f82dc-1c75-5e2b-bfc4-18949d33d9c4", "logo": "/media/juliacon2021/submissions/YZSNLC/Turkie-logo_11Ei5Nc.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9635-sampling-live-visualizations-with-turkie-and-turingcallbacks", "url": "https://pretalx.com/juliacon2021/talk/YZSNLC/", "title": "Sampling Live Visualizations with Turkie and TuringCallbacks", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Markov Chain Monte Carlo methods are like cooking milk you better watch what's happening! In order to do this we propose two complementary approaches: Turkie.jl based on Makie.jl and TuringCallbacks.jl based on Tensorboard.\r\nBoth package allow you to finely pick which variables and which statistics to watch for and display the results in real time while sampling.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 4213, "code": "EWDVK7", "public_name": "Th\u00e9o Galy-Fajou", "biography": "Hi! I am a PhD student at TU Berlin and Julia adept since 0.4! I develop packages for probabilistic inference and more especially Gaussian Processes. For more info check my website [theogf.github.io](https://theogf.github.io)", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9906, "guid": "7b69f3be-ad61-5e39-b3ff-7931ac8ee7ad", "logo": "/media/juliacon2021/submissions/ZSCFTW/MDP_AMZsDnt.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9906-towards-mdp-jl-the-julia-library-of-md-potentials", "url": "https://pretalx.com/juliacon2021/talk/ZSCFTW/", "title": "Towards MDP.jl: The Julia Library of MD Potentials", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "MDP.jl, the Julia library of Molecular Dynamics (MD) potentials, is being developed to provide fast and accurate potentials for classical MD simulations on exascale supercomputers. Its goals include coupling empirical and machine learning (ML) potentials and quantifying uncertainties in trained ML potentials. This talk presents the latest developments in MDP.jl regarding descriptors and force field computation.", "description": "Molecular Dynamics (MD) simulations require a potential energy function to describe the force field governing the interaction among atoms. Force calculation often takes between 50% and 90% of the overall complexity, thus, determining an adequate potential is a crucial task. Classical MD simulations use Empirical Potentials (EP), such as Lennard-Jones or Tersoff, and Machine Learning Potentials (MLP), such as Neural Network Potentials (NNP) or Spectral Neighborhood Analysis Potentials (SNAP). Despite their success, some potentials present limitations when solving complex study cases as ultrahigh temperature ceramics in hypersonic flows. Particularly, existing EP, ReaxFF and COMB, do not produce satisfactory results since they require retraining, while MLP demand a significant amount of Density Functional Theory (DFT) data for the training process. Coupling both potentials is a promising approach for reducing the amount of training data, leveraging physics information coded in the EP. Currently, there are no open-source libraries that allow this coupling and at the same time offer other key features, such as quantifying uncertainties in the trained MLP or identifying near-optimal configurations to include in the training data. MDP.jl, the Julia library of MD potentials, is being developed to fill this gap, aiming to provide fast and accurate potentials for classical MD simulations on exascale supercomputers. In this talk, the latest developments in MDP.jl regarding the descriptors and force field calculation are presented.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10491, "code": "JERCK8", "public_name": "Emmanuel Lujan", "biography": "Postdoctoral Associate at Julia Lab, Massachusetts Institute of Technology.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9880, "guid": "8ee2ccf8-b59f-5c4e-852c-c9717c274262", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9880-bayesian-network-regression-with-applications-to-microbiome-data", "url": "https://pretalx.com/juliacon2021/talk/CMYWPV/", "title": "Bayesian network regression with applications to microbiome data", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Microbial communities are among the main driving forces of human, soil and plant health. To understand the connection between microbial interaction networks and human or plant features, we have translated into Julia a Bayesian network regression model originally developed on brain connectome data. We aim to create a Julia package to extend this model to the microbiome, to identify relationships between the overall network structure of the microbiome and human, soil or plant response variables.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10413, "code": "X8DQ9H", "public_name": "Samuel Ozminkowski", "biography": "Samuel Ozminkowski is a M.S. student in Statistics at the University of Wisconsin-Madison, in the Solis-Lemus lab. His work is focused on using Bayesian models with network predictors, specifically focusing on microbiome networks. He earned his undergraduate degree in Computer Science at the University of Michigan.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9738, "guid": "4f3e583f-6ff0-5bc6-b546-2d919cf7af00", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9738-sonification-exploring-streaming-data-using-live-music-coding", "url": "https://pretalx.com/juliacon2021/talk/XKJKTB/", "title": "Sonification: Exploring streaming data using live music coding", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "Hooks is a new package exploring Sonification (representing data as audio) using Julia and Pluto integrated with SuperCollider, processing streaming data to create music using live music coding techniques. The presentation also includes brief observations as a first-time Julia coder.", "description": "Sonification is an exciting field exploring how data can be represented as audio, using advantages afforded by the sense of hearing to enhance our sensory perception of the data. \r\nThe presentation will introduce \u201cHooks\u201d, a package using live music coding techniques to process streaming data and represent both raw data and statistical analysis metrics as music. It uses Julia integrated with the SuperCollider synthesis engine and takes advantage of the interactivity and reactivity of the Pluto notebook. \r\nHooks began as a Masters degree project; one of the aims of presenting at JuliaCon is to spread awareness and engage anybody interested in collaboration to help solve some of the technical challenges to take the package from its current proof-of-concept stage to a fully-fledged application.\r\nAs a newcomer to the Julia language and this community, this presentation will also cover a couple of brief notes about the author\u2019s first-time experiences with Julia and Pluto.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10362, "code": "G39NKQ", "public_name": "Nicki Cartlidge", "biography": "My coding and musical lives began early, starting piano lessons at the age of 4 and computing with the advent of the ZX80! After an undergrad Masters degree in Electronic Engineering Science and a 20+ year career in Software Testing, I recently completed a Masters of Applied Data Science at the University of Canterbury, New Zealand. I had the opportunity to bring together my love of data, computing and music to explore Sonification for my degree project and I hope to build on it beginning work on a PhD later this year. \r\nAlthough experienced in software engineering, I am new to Julia and keen to contribute to the friendly, supportive, growing community.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9660, "guid": "9a3b7b6a-01ad-5b3a-a35b-892a71433426", "logo": "/media/juliacon2021/submissions/ZRWZJW/MPPC_Close_up_3KJOuRf.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9660-using-julia-to-simulate-non-linearity-in-photon-counters", "url": "https://pretalx.com/juliacon2021/talk/ZRWZJW/", "title": "Using Julia to simulate non-linearity in photon counters", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "I'll be showing how Julia and it's libraries can be used to simulate non-linearity in photon counting detectors used in LiDAR", "description": "A Monte-Carlo simulation of a photon counting detector is modelled in Julia using libraries such as Distributions.jl and ACME.jl.  In this poster I will explain how various libraries and native Julia functions are used to translate sensor characteristic tables into a full sensor model.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10299, "code": "C3WHVH", "public_name": "Dino Butron", "biography": "Dino Butron is a Senior Applications Engineer at Hamamatsu Corporation in Bridgewater, NJ where his focus is on high sensitivity photodetectors for use in various markets. He is currently involved in leading discussions for detector selection and developing simulation tools.\r\n\r\nDino is an expert in the operating principles and application of various detectors such as photodiodes, avalanche photodiodes (APD), SPPC (SPAD), MPPC (SiPM), and photomultiplier tubes (PMT). He has worked on many photodetector experiments resulting in a deep understanding of detector performance. In addition, he has vast knowledge programming signal-to-noise ratio and output simulations. He received his Bachelor\u2019s degree in Electrical Engineering from Manhattan College, Riverdale, NY, in 2012.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9904, "guid": "53c9431d-b166-5484-927f-c1d906befadc", "logo": "/media/juliacon2021/submissions/7WWKSK/heat_kGTS6CX.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9904-probabilistic-k-nearest-neighbours", "url": "https://pretalx.com/juliacon2021/talk/7WWKSK/", "title": "Probabilistic K-Nearest Neighbours", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "In this presentation, I talk about my experience creating the Pknn.jl library for modelling probabilistic K-nearest neighbours and how Julia solved running a sampling an algorithm in Python for hours to only a couple of minutes.", "description": "Probabilistic K-nearest neighbours were first proposed by Holmes and Adams in 2001. Their model assumes a distribution on the number of neighbours required to perform inference over a datapoint. \r\n\r\nIn this presentation, I talk about the practical aspects of the model, and the effortlessly transition from Python code to Julia code for both speed and parallelism.\r\n\r\nThe project can be found at [this](https://github.com/gerdm/pknn.jl) link.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10489, "code": "3FK7YD", "public_name": "Gerardo Duran-Martin", "biography": "Msc student in Mathematics at Queen Mary University of London", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9834, "guid": "f08b069f-3781-57ae-9a4d-b381190f007d", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9834-my-experience-trying-to-reinvent-the-fluxml-website", "url": "https://pretalx.com/juliacon2021/talk/GD99DH/", "title": "My experience trying to reinvent the FluxML website", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "In this Virtual Poster session, I talk about my experience during the Google Season of Docs program to reinvent the FluxML website and documentation. Also, I discuss the challenges I'm facing as I continue to contribute to Flux documentation.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10420, "code": "9P33LA", "public_name": "Liliana Badillo Sanchez", "biography": "I have been working as a data scientist and technical writer for about 2.5 years. In my projects, I try to combine both disciplines either by documenting thoroughly a data science project, or following a data-driven approach (if possible) when documenting products and technical processes.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9905, "guid": "c1f2eb38-4bc7-5287-a5ca-84c5b6731ca1", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9905-scalable-material-simulations-in-a-julia-infrastructure", "url": "https://pretalx.com/juliacon2021/talk/P8ZEEB/", "title": "Scalable Material Simulations in a Julia Infrastructure", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "We describe a materials design project where we unify Julia packages such as DFTK.jl and NBodySimulator.jl in order to create an infrastructure for what will ultimately be a large parallel simulation.  It is our hypothesis that rebuilding this infrastructure from the ground up in Julia, will be more competitive than existing codes from the national labs because of the simplicity, maintainability, and composability available in the Julia Language.", "description": "We are developing a composable end-to-end Julia pipeline for Molecular Dynamics simulations. The current components in the Julia ecosystem (as referenced in the recording) include:\r\n- [NBodySimulator.jl](https://github.com/SciML/NBodySimulator.jl) (general-purpose dynamics simulator)\r\n- [DFTK.jl](https://github.com/JuliaMolSim/DFTK.jl) (plane-wave density-functional theory toolkit)\r\n- [PotentialLearning.jl](https://github.com/cesmix-mit/PotentialLearning.jl) (library of nuclear potential codes) -- note that I called this package MDP.jl in the recording, but it has since been renamed\r\n- [Atomistic.jl](https://github.com/jrdegreeff/Atomistic.jl) (orchestration of all components) -- note that I called this package CESMIX.jl in the recording, but it has since been renamed\r\n\r\nIf you would like to get in touch with me or any of my collaborators, feel free to contact me by email at degreeff@mit.edu.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10483, "code": "MDTTZU", "public_name": "Jeremiah DeGreeff", "biography": "Second year undergraduate at MIT studying Computer Science and Engineering.\r\n\r\ndegreeff@mit.edu\r\nhttps://github.com/jrdegreeff", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9277, "guid": "93b4fc7f-2d48-5eb7-9cb9-c841aa03209f", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9277-optimal-control-problems-in-chemical-engineering-with-julia", "url": "https://pretalx.com/juliacon2021/talk/78L3MP/", "title": "Optimal control problems in Chemical Engineering with Julia", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "I would like to show how Julia/JuMP can be used to solve nonlinear (large-scale) optimal control problems in chemical processes by applying a direct method. The problem is solved as an NLP after applying orthogonal collocation on constant or moving finite elements with control parametrization. Collocation points and Butcher tableau are generated with Jacobi.jl. NLP problems are solved in JuMP with Ipopt and MA27 solvers. An ilustrative example is shown and future directions are discussed.", "description": "Optimal control plays a key rol in the operation of chemical processes. It provides \r\ncontrol profiles that minimize or maximize a performance index subject to the dynamic model of the system and constraints on the state and control variables.  Some packages such as NLoptcontrol.jl and InfiniteOpt.jl implement direct methods (discretize-then-optimize) to transform the problem into a NLP model that can be solved with efficient NLP algorithms. However, in chemical processes, we often deal with challenging problems that require more rigurous strategies to deal with stiff models, unstable operating points, ill-conditioned problems, etc. In this talk, I would like to show how Julia/JuMP can be used to solve nonlinear and possible large-scale optimal control problems in chemical processes by applying a customized direct method. Particularly, I would show how to implement orthogonal collocation on constant and moving finite elements with different control parametrization schemes. Collocation points and Butcher tableau are generated with the package Jacobi.jl, NLP problems are solved in JuMP with Ipopt and MA27 solvers. An ilustrative example is shown and future directions are discussed.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9700, "code": "JHM77R", "public_name": "Oswaldo A.M", "biography": "PhD in Engineering Science by Tecnologico de Monterrey, Mexico. \r\nCurrent postdoctoral fellow at University of Waterloo.\r\nMy research interests include: optimal control, model predictive control, scheduling and nonlinear optimization of chemical and energy processes.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9477, "guid": "8bb59507-cd4e-5f0a-8432-ee23a0d732e5", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9477-julia-healthcare-technology-assessment-analytics", "url": "https://pretalx.com/juliacon2021/talk/TLGXCD/", "title": "Julia & Healthcare Technology Assessment Analytics", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "Healthcare technology assessment plays a key role in shaping healthcare policy decisions with respect to granting access to new healthcare programs.  Analytics are critical for informing these decisions.  Julia\u2019s performance offers significant advantages especially for complex health economic models.  This talk will highlight opportunities for bridging fields and forming a Julia community of data scientists for the advancement of healthcare technology assessment analytics.", "description": "Few in the healthcare technology assessment data science community use Julia for their analytics.  I have found the many qualities of the language (e.g., thoughtful design, performance, and open-source) could transform how data science is conducted in my field.  I would like to find others in the Julia community who would have an interest in building a network and community of data scientists that contribute to advancing our healthcare technologies assessment analytics.  These types of analytics include foundational epidemiology, healthcare database studies,  transmission dynamic differential equation infectious disease models, cost off illness studies, meta-analyses, budget impact models, and cost-effectiveness models.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10009, "code": "9GQ97K", "public_name": "Erik J Dasbach", "biography": "Erik Dasbach joined Merck 20+ years ago and his work experiences have included mathematical modeling, clinical trial design and analytics, population health and epidemiologic studies, patient reported outcome measure development and analytics, real-world database analytics, and platform development for sharing data, models, and analytics. \r\n\r\nPrior to joining Merck, Erik worked in a variety of scientific and technology roles in the healthcare industry including the Centers for Disease Control and Prevention, the National Cardiovascular Network, the hospital industry, business development, and software development.  \r\n\r\nErik received his Ph.D. from the University of Wisconsin-Madison in Industrial & Systems Engineering with a specialty in decision sciences and health technology assessment.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9740, "guid": "1ac79ac1-e741-5fdc-8a90-902046301cc3", "logo": "/media/juliacon2021/submissions/ACFGRM/GL_ycmBktQ.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9740-ml-for-gl-machine-learning-for-general-ledger-using-julia", "url": "https://pretalx.com/juliacon2021/talk/ACFGRM/", "title": "ML for GL, Machine Learning for General Ledger using Julia", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Machine learning for General Ledger provide a complete Data Science framework for Finance Data Analytics. Scope of this package includes Finance General Ledger, sub-ledgers, accounting entries analytics and complex Data Science operations using The Julia language.\r\nThis package/presentation is meant for ERP consultants, IT Developers, Finance, Supply chain, HR & CRM managers, executive leaders, or anyone curious to implement data science concepts in ERP apps for small, medium & large Org.", "description": "ERPs are backbone systems to any living organization, whether small, medium, or large. Almost every organization use ERP concepts, whether in a piece of paper, excel file, MS Access DB or large sophisticated systems like SAP, Oracle data warehouse & databases. \r\n\r\nOrganizations deal with many ERP modules like Buy to Pay, Order to Cash and GL to manage Finance, Supply chain operations daily.\r\n\r\nERP systems aren\u2019t luxury apps anymore, Often Small businesses see GL (or perhaps entire ERP system), intended only for Big organizations. However, even Big Org operate in small units and merge later into a Corporate Ledger. \r\n\r\nHaving a system to read, write and understand your financials books brings extraordinary benefits to any size of business.\r\n\r\nRecent popularity of software like Quick-books, NetSuite, Tally are proof that ERP are the way to manage business successfully. People use piece of papers, notebooks, excels, word documents in their daily life to manage expenses, record Actuals, plan future Budgets and even forecast future savings to some extent.\r\n\r\nMedium, Big Org just happen to use sophisticated ERP systems like SAP, Oracle, PeopleSoft, Coupa etc. but conceptually, they don\u2019t do anything different other than following simple ERP concepts daily to manage critical business operations, record Actual and forecast earnings.\r\n\r\nProblem Statement: IT industry & Giant Market leaders created extraordinary ERP systems to record transactions. Even a small merchant, now uses his mobile to take picture of invoice and pays vendor online. Medium organizations can auto-correct invoices and process vouchers, and Big Org\u2019s ERPs can count live inventory across regions. These systems provide a unified platform for all small, medium and large entities to record i.e. write their data in structured or unstructured forms into their secured on-premise or cloud locations.\r\n\r\nRead, Write and Understand are 3 different aspects of ERP data, while these ERP systems achieved perfection in \u201cwrite\u201d, there is a lot more to do in \u201cread and understand data\u201d.\r\n\r\nThis Julia Language GeneralLedger.jl is built to serve this purpose only.\r\n\r\nThis package will provide a complete Analytic Software environment, which can be deployed as a bolt-on or independent app for all data extract, load, transformation, ad-hoc reporting & analytics, visualizations and tooling to support Data Science using AI, ML predictive Analytics.\r\n\r\nWhy Julia Language:- because it take a village to create Analytics platform, Julia is not solving 2 language problem here in ERP space, ERP systems already have 4, 5 or 6 language problems.\r\nTransactions systems are not primarily used for Reporting/analytics purpose, imagine using Walmart pay register to run data analytics.\r\n\r\nOrganizations spend millions of $$s to move their data to appropriate data platform, they use ELT, ETL, create Data warehouses, Data lakes to keep this data in sync.\r\n\r\nERP systems run complex data operations to clean this data set before it\u2019s made available to business users, supply chain managers and executive leaders in form of analytics tools like Cognos Data marts, Tableau, Power BI, Oracle OACs, Kibana or Google Analytics like business intelligence tools.\r\nWhile these tools are great for operational reporting, they lack analytics. \r\n\r\nI am not talking about simple data operations like removing duplicates, drill down, drill through reporting or creating bar- graphs, drawing moving average lines on simple graphs.\r\n\r\nBy Data Science, I mean, plotting entire company General Ledger data on a single graph. I am talking about using Network science/ graph theory to manage supply chain, using Machine Learning prediction for Real time inventory use charts.\r\n\r\nJulia solves this problem, it\u2019s one Data Science language, which can be used for data loading, cleansing, transformations, visualizations and then running advance AI, ML or Deep learning computational operations on huge data sets.\r\n\r\nReal time, real life statistics:- \u201cWalk Like Python; Run Like C\u201d is enough to pick this language for all my daily work.  ERP leaders have a business to run, and a community to serve.\r\n\r\n\u201cJulia is high performance\u201d, made for Asynchronous, parallel, distributed GPU computing,\r\n\r\nJulia language provides fast computations for large data sets and great assets for Statistical programming, makes Julia Language is THE language for ERP Analytics.\r\n\r\nIn this presentation, I will share my Julia notebooks for General Ledger. I will share, how Julia provide data structure for LEDGER, FINANCE using sophisticated TYPE system. How data can be quickly transformed to Fact/Dimension star schema for self-service and real-time reporting. and I will share some of my Julia notebooks I used to perform Time Series, Deep Learning and Graph analysis on Finance data.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10365, "code": "R9ZVLC", "public_name": "Amit Shukla", "biography": "Hands-on Executive Consultant, ERP Implementation, AI Data Science, Machine Learning, Deep Learning, Business Intelligence, Flutter DART Angular Mobile apps.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9786, "guid": "eb7f4e49-f6e7-5539-88a6-b3a07400ca27", "logo": "/media/juliacon2021/submissions/QLSE8R/Dr.Aftab_Ara_0EbmgmZ.jpg", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9786-visualization-storytelling", "url": "https://pretalx.com/juliacon2021/talk/QLSE8R/", "title": "Visualization storytelling", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "As evidenced by the Covid19 epidemic, big data and data science are becoming critical sciences in a variety of application contexts, owing primarily to the abundance of big data collections from which valuable patterns of information can be mined.Data pre-processing and analytics phases account for approximately 70% and 20% of the total data analytics operation, respectively,", "description": "As evidenced by the Covid19 epidemic, big data and data science are becoming critical sciences in a variety of application contexts, owing primarily to the abundance of big data collections from which valuable patterns of information can be mined. Data pre-processing and analytics phases account for approximately 70% and 20% of the total data analytics operation, respectively, This talk will focus on visualization effectively, tools used for data visualization, and guidelines for effective Data Visualization technique.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10393, "code": "9UW3XS", "public_name": "Dr.Aftab Ara", "biography": "I am a dynamic educational professional, data science enthusiast, speaker, board member, book author, researcher, and L&D coach greatly passionate about different applications of data science, and enjoy speaking on various data science topics and creating a learning experience by reinventing technology.\r\nCurrently, I am working on several projects to create more engaging and exciting educational opportunities by using Data Science, AI, and Machine Learning project for education\r\n\r\nI actively work to share insights and perspectives through writing, consulting, and coaching with clients, practitioners, students, and fellow academicians in the field of learning. When not reading or writing, one can find me doodling away to my heart\u2019s content.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9747, "guid": "91cb3f9d-3519-56ae-8af7-d6cdf43e8f38", "logo": "/media/juliacon2021/submissions/BRTTKB/deloitte_logo_SHxO7xD.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9747-a-new-openstreetmap-interface-lightosm-jl", "url": "https://pretalx.com/juliacon2021/talk/BRTTKB/", "title": "A new OpenStreetMap interface: LightOSM.jl", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "LightOSM.jl is a package for downloading, processing and analysing OpenStreetMap geospatial data. This talk explores its key features and how it can be used for transport simulation, route finding, map querying and map visualisation. We discuss how LightOSM.jl is differentiated from other packages by its fast path-finding, custom edge weighting, turn restriction implementation, improved user interface, kd-tree implementation for querying nearest nodes and ability to download building polygons.", "description": "Visit the official GitHub page for more information: https://github.com/DeloitteDigitalAPAC/LightOSM.jl\r\n\r\nSee the shortest path finding algorithm benchmarks for a comprehensive comparison against other packages: https://deloittedigitalapac.github.io/LightOSM.jl/notebooks/benchmarks/\r\n\r\nTry the tutorial for LightOSM.jl to learn about its features and the visualisations it can produce: https://deloittedigitalapac.github.io/LightOSM.jl/notebooks/tutorial/", "recording_license": "", "do_not_record": false, "persons": [{"id": 10373, "code": "UQWF7L", "public_name": "Jack Chan", "biography": "I am a software developer from Deloitte Digital Australia, currently working with a talented team of individuals on Deloitte's Optimal Reality offering (https://optimalreality.com/),  a cloud based platform for delivering digital twin capability based on simulation techniques pioneered in Formula One racing.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9717, "guid": "9a1d1a0c-5481-59a7-8f53-7b35b3bf95f5", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9717-julia-for-end-to-end-financial-analysis", "url": "https://pretalx.com/juliacon2021/talk/BYW9KR/", "title": "Julia for end to end financial analysis", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "This session will give a quick demo of how we used Julia for our workflow of a financial analysis application. The application itself performs multi-objective optimization on historical stock data to create a pareto frontier of optimal risk - return combinations. We will talk about Julia's optimization packages such as JuMP and MultiJuMP, as well as its easy to use reporting and visualization packages such as Weave and Plots that help us communicate and visualize results.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10351, "code": "HFKJQF", "public_name": "Mohamed Zahran", "biography": "A Machine Learning Engineer with a background in robotics and mechatronics system. My primary focus is in the areas of optimization and AI.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9655, "guid": "01033736-0bd8-56a7-9932-7dfcb4dcf778", "logo": "/media/juliacon2021/submissions/FLLZNF/Modes_niPclDP.PNG", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9655-flywheel-1-d-finite-element-tool-for-gyroscopic-systems", "url": "https://pretalx.com/juliacon2021/talk/FLLZNF/", "title": "Flywheel: 1-D Finite element tool for gyroscopic systems", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Satellite reaction wheels, laboratory centrifuges, kinetic energy storage et.c. all rely on mechanical design of rotating systems of varying complexity. The current tool written in Julia, offers students and engineers a visual environment for designing their own, custom machine based on a blueprint file and obtain the resulting finite element matrices. In this way, one can analyse performance metrics such as unbalance response, critical speeds, bearing reaction forces and static deformations.", "description": "The Julia module Flywheel is a mechanical engineering tool for one dimensional finite element analysis of the lateral dynamics of gyroscopic systems. It allows one to import a custom machine, described by a blueprint text file containing geometric features and relevant material properties. The core of the module is the calculation of the finite element matrices of inertia, damping, gyroscopy and stiffness. These matrices can then be used to estimate a variety of performance metrics. Application examples are:\r\n1) Static deformation due to gravity or other operation loads\r\n2) Critical speeds, where resonance frequency and rotational speed coincide\r\n3) Orbit response due to unbalance placed at defined locations of the machine\r\n4) Insight into rotor dynamics in general\r\nThe user can easily export the matrices for use in another software environment as well. Two literature references describe the approach and are helpful for understanding finite element method in general. They can be used for creating similar or advanced modules of relevant functionality.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10295, "code": "Q9SQD7", "public_name": "Lysandros Anastasopoulos", "biography": "After completing studies in mechanical engineering in Germany, worked for a coupled of years in the industry and academia. Now working in Switzerland in the aviation sector and developing code as a hobby.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9916, "guid": "91e0eb8d-947c-5f7a-b890-791a0a284456", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9916-yawipa-a-comprehensive-and-extensible-wiktionary-parser", "url": "https://pretalx.com/juliacon2021/talk/XR9MLU/", "title": "Yawipa: a comprehensive and extensible Wiktionary parser", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "Wiktionary is a large, free multilingual dictionary with a wealth of information. Yawipa is designed to be easily extensible and comprehensive, and (of course) it is written in Julia. It can extract numerous types information from Wiktionary, including pronunciations, part ofspeech, translations, etymology, and a wide range of word relations, and normalize it into an easy-to-process tabular format. Yawipa is available at https://github.com/wswu/yawipa, and we welcome your contributions.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10499, "code": "XDXAHF", "public_name": "Winston Wu", "biography": "PhD student at Johns Hopkins University, studying computational linguistics.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9485, "guid": "2d8536e2-f11e-5395-8a36-4ce543a7caf8", "logo": "/media/juliacon2021/submissions/TZUQYY/lDJI_0739_-_DJI_0741_rj5SK4W.jpg", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9485-julia-managed-sensor-actuator-network-for-antarctic-studies", "url": "https://pretalx.com/juliacon2021/talk/TZUQYY/", "title": "Julia managed sensor - actuator network for Antarctic studies", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Our work presents a technological part of an interdisciplinary study carried out in cooperation with plant physiologists, which investigates Antarctic plants' response to the ongoing climate change. The project involves an active thermal system, which simulates the future growing conditions of the plants. The systems consist of more than 100 temperature/humidity sensors and 30 thermal actuators distributed in the field (vicinity of the \u201cH. Arctowski Station, King George Island) as a CAN network.", "description": "Near Henryk Arctowski Station(Lat: 62\u00b009\u00b445\u00b4\u00b4S Long: 58\u00b028\u00b4W) was implemented an actuation and data recollection system managed by Julia. The system consists of a network of sensors and thermal actuators distributed on the field in individual nodes interconnected using CAN protocol. The objective of this network was to monitor the diverse conditions of two species of plants divided into three different groups.\r\nThese experiments were in the context of Antarctic Sciences and Global Warming Studies.\r\n\r\nThe CAN network had more than 100 sensors in total. These sensors were distributed on the field, some of them were inside of structures called OTC (Open Top Chamber), OTC + Warming, and others in open space (just on the field). Some of the sensors measured the ambient temperature and humidity, others infrared sensors measured the temperature of the plants.\r\nThe network also had five power control nodes, and these nodes controlled the temperature of the plants inside of some OTC.\r\n\r\nThe network was controlled by Julia running on Embedded Linux.\r\nDifferent scripts running on one principal Julia Script, this script had different asynchronous functions which assign actions and orders to the network of nodes.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10048, "code": "9VRJUR", "public_name": "Mauricio Montanares", "biography": "I'm a bachelors student of Automation Engineering. I have experience working on embedded systems, Data analysis, Machine learning Topics and Wireless Communications. All of these topics in real world applications.\r\n\r\nThe last two years i was be a part of the Chilean Antarctic Scientific Expeditions, I collaborated with scientists of different nationalities and specialities in interdisciplinary works relatives to Antarctic Sciences.", "answers": []}, {"id": 10050, "code": "HE7REJ", "public_name": "Krzysztof Herman", "biography": "I am a full time academic teacher and researcher at the University of the Bio Bio, Concepcion, Chile.  My research interests are related with sensors and embedded solutions for extreme and hostile environments like polar regions. I am also interested in low level digital hardware development like FPGA and ASIC.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9923, "guid": "1fb2b22f-83c6-5c17-aa14-98e8c599cd09", "logo": "/media/juliacon2021/submissions/EWMZKD/R-vine_representation_nVrLiXV.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9923-vine-copula-package-for-the-analysis-of-non-gaussian-processes", "url": "https://pretalx.com/juliacon2021/talk/EWMZKD/", "title": "Vine-Copula package for the analysis of non-Gaussian processes", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "The literature on vine-copula constructions provides applied statisticians with tools for the exact inference on non-Gaussian distributions.\r\n\r\nThe few existing R packages that provide copula-related functionality are suited for the analysis of i.i.d. multivariate specifications but not the dynamic stochastic processes.\u00a0\r\n\r\nMy package Copulas provides a sparse implementation for R-vine arrays, which scales up very well\u00a0in typical parsimonious specifications, such as 1st order Markov processes.", "description": "The main algorithmic challenge is that R-vine arrays, which encode pairwise decompositions of the joint likelihood function into bivariate copula functions, are order N^2 in the cardinality of the dataset. For even modest-sized datasets therefore, implementing the R-vine arrays as dense collections requires traversing a huge amount of individual copula instances, even when most of them are expected to be trivial. This results in large memory footprint and enormous computing times for the basic inference operations, such as likelihood evaluation and sampling.\r\n\r\nMy package uses sparse data structures to reduce the memory required for object storage and to significantly speed up likelihood evaluations and sampling.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10504, "code": "NRJTSD", "public_name": "Andrei Sarychev", "biography": "Andrei Sarychev has taught Economics at the University of British Columbia and London School of Economics before joining the UK financial sector regulator. He devised the first scenario design framework for use in the UK stress-testing. At the Bank of England he developed a broad variety of analytical models for use in forecasting, policy analysis, and risk assessment. He also designed the European Central Bank's macro-financial platform. His research interests lie in modelling complex multivariate distributions and Bayesian methods.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9702, "guid": "217a7c11-9df5-5233-8b30-ab8ba67a7f21", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9702-fitting-plate-reader-curves-with-julia", "url": "https://pretalx.com/juliacon2021/talk/7VNJWV/", "title": "Fitting Plate-reader Curves with Julia", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "PlateReaderCore and PlateReaderCurves are Julia packages for fitting and visualizing results from optical plate-readers and similar equipment. The presentation will introduce these packages and describe my experience developing and deploying them.", "description": "Optical plate-readers record time-courses of optical readout, typically absorbance or fluorescence. They are used in biology labs for measuring cell growth and enzymatic reactions. I developed the Julia packages PlateReaderCore and PlateReaderCurves for my work with this type of data. Previously, I have developed similar functionality in R, and I'll describe how I have experienced the shift to Julia.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10342, "code": "UPFEMA", "public_name": "Thomas A. Poulsen", "biography": "MS in mathematics, Phd in mechanical engineering. Has worked in biotechnology for 20 years. Programmed in FORTRAN 3 years, Perl 5 years and R 15 years. Has been dipping toes in Julia for 2 years.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9940, "guid": "477e86c3-57e0-5534-b059-fadba7f5fe53", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9940--canceled-the-wonderfully-helpful-julia-community", "url": "https://pretalx.com/juliacon2021/talk/8KCB3E/", "title": "[Canceled] The wonderfully helpful Julia community", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "This short session will share the wonderful experience I've had engaging with the Julia community as a new Julia learner. Overall, I want to share these experiences as a way to celebrate it but also to encourage other new Julia learners to connect and engage with this friendly community. Topics include what one can expect on the various platforms as well as how I got help on some of my projects like getting help to accelerate my Julia image processing code that I use to make art.", "description": "One of my favorite things about Julia is its community. I want to share this treasure with other people who might not know what to expect from the Julia Slack, Discourse, or Zulip. As a short 3 minute presentation, the primary goal would be to just emphasize my experiences with how incredibly helpful the Julia community is, with knowledge on various topics and how a new Julia learner can just say hi and meet other friendly like-minded people from all over the world.\r\n\r\nA small portion of the presentation will also show some examples of my interactions with the community. As an example, it could be on how I got help on Discourse with accelerating my Julia image-processing code that I use to make digital art (Julia code uses Luxor.jl, Images.jl, and HDF5.jl alongside with Blender, a 3D digital modelling software).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10512, "code": "3PPANS", "public_name": "Kim Paolo Laberinto", "biography": "Started learning Julia a year ago! Electrical Engineering B.Sc graduate in May 2021 from Winnipeg, Canada. Aspiring Julia data scientist with interests in scientific machine learning.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9743, "guid": "af6a8ebe-895c-5fbe-a303-0b285d9caecd", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9743-composite-interfaces-for-bioinformatics", "url": "https://pretalx.com/juliacon2021/talk/KLPEG3/", "title": "Composite Interfaces for Bioinformatics", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "There are plenty of user interface elements for bioinformatics available on the web, but most of them are dispersed and written in JavaScript. With Julia, we can adapt and augment these elements to make interfaces that are more relevant to user projects, have denser information, can be run/tweaked locally, and create new connections between data.", "description": "There are so many great websites and databases with nice interactive figures and tons of information presented on the screen out there. However, it can be inconvenient to reach the data or interface one is looking for on some of these sites, and there might be a lot of clutter. One aim here is to enable users to basically collect the most relevant elements together. Another aim is to connect data and events together for these elements, and to ultimately control it all with Julia. Plotting and interface packages in Julia can be used to construct new elements that provide whatever functionality or representation is missing. The result is an interface that can be optimized for a particular project, person, or purpose. The scientific machine learning and computational ecosystems in Julia can be used as a natural backend to enable powerful new data science controls and techniques.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4391, "code": "DRPANN", "public_name": "Daniel Kool", "biography": "I grew up in Grand Rapids, Michigan, but now I live in Ames, Iowa. Both are great places to live, but I hope to move closer to GR eventually. I first became truly interested in science in high school chemistry class. Later, I found organic chemistry to be the most fun, and this interest spread to biochemistry and math (BS double major). I decided to continue my exploration and get an MS in chemistry, during which I studied a family of DNA polymerases that are recruited to replicate past lesions in the DNA. After that, I still wanted more time to study, so here I am at Iowa State in a great bioinformatics and computational biology PhD program. I want my life to be about exploration of STEM, and my favorite set of tools is Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9787, "guid": "e0c237e8-20e7-50db-b516-b054314b4757", "logo": "/media/juliacon2021/submissions/TCBRVL/galaxybrain_W4XbRt7.jpeg", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9787-disrupting-esoteric-language-microbenchmarks-with-an-80-line-jit", "url": "https://pretalx.com/juliacon2021/talk/TCBRVL/", "title": "Disrupting Esoteric Language Microbenchmarks with an 80-line JIT", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "When Julia 1.6 is released, a concerned Hacker News commenter wonders if Julia's performance claims are overblown, citing a series of microbenchmarks that measure the speed with which a language can interpret the esoteric programming language Brainfuck. Using powerful metaprogramming utilities, 80 lines of Julia are enough to transpile Brainfuck to a native Julia function instead, resulting in performance times that outpace every other language in the test suite.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10311, "code": "YMTEYP", "public_name": "Seth Chapman", "biography": "they/them\r\n\r\nSeth is a frontend web developer for [Beacon Biosignals](beacon.bio) and part-time [Exercism](exercism.io) mentor for the Julia language. They've been developing in Julia since November 2019 and are a contributor to [StaticArrays.jl](https://github.com/JuliaArrays/StaticArrays.jl). Their specialty is [esoteric languages](https://github.com/OTDE/GalaxyBrain.jl).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9805, "guid": "17dbaaf3-d233-5528-934b-4bb551adbe6d", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9805-ellipticalslicesampling-jl-mcmc-with-gaussian-priors", "url": "https://pretalx.com/juliacon2021/talk/WPUYVZ/", "title": "EllipticalSliceSampling.jl: MCMC with Gaussian priors", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "EllipticalSliceSampling.jl is a package for elliptical slice sampling (ESS), a simple Markov chain Monte Carlo method for models with Gaussian priors. Models can be specified with an arbitrary Julia function of the log-likelihood and a Gaussian prior that follows a simple interface (Distributions.jl works out of the box). Features such as progress logging and parallel sampling are provided automatically by AbstractMCMC.jl. Turing.jl supports ESS, also within Gibbs, through this package.", "description": "**The Pluto notebook of this poster is available at https://talks.widmann.dev/2021/07/ellipticalslicesampling/**\r\n\r\nElliptical slice sampling is a simple Markov chain Monte Carlo (MCMC) method for models with Gaussian priors. As such it is particularly interesting for models based on Gaussian processes. In this talk we\r\npresent [EllipticalSliceSampling.jl](https://github.com/TuringLang/EllipticalSliceSampling.jl), a Julia package for elliptical slice sampling.\r\n\r\nThe package offers a simple yet very general implementation of the algorithm. Users can specify models that with an arbitrary Julia function of the log-likelihood and a Gaussian prior that has to satisfy a simple interface. This interface ensures that sampling can be performed efficiently for custom types of priors. It is implemented for Gaussian distributions in Distributions.jl, and hence EllipticalSliceSampling.jl supports these distributions as priors out of the box. ArrayInterface.jl is used to optimize sampling automatically for mutable types of samples, regardless of the employed prior.\r\n\r\nSince EllipticalSliceSampling.jl implements the AbstractMCMC.jl interface for MCMC algorithms, features such as progress logging, thinning, discarding of initial samples, and parallel sampling with multiple threads or processes are provided automatically. Due to the simple nature of the elliptical slice\r\nsampling algorithm, EllipticalSliceSampling.jl contains a concise and minimal implementation of the interface and can serve as a reference implementation for other developers.\r\n\r\nIn general, EllipticalSliceSampling.jl integrates well with other Julia packages. For instance, it can be used to perform inference of Gaussian process models built with AbstractGPs.jl. Additionally, the Turing probabilistic programming language contains first-class support for elliptical slice sampling via\r\nEllipticalSliceSampling.jl. It can serve as inference method for models with solely Gaussian priors and as component of a Gibbs sampler for more general classes of models that contain non-Gaussian priors as well.\r\n\r\n### References\r\n\r\nMurray, I., Adams, R. & MacKay, D.. (2010). Elliptical slice sampling. Proceedings of Machine Learning Research, 9:541-548.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1081, "code": "BKDQGH", "public_name": "David Widmann", "biography": "I am a PhD student at the [Division of Systems and Control](https://www.it.uu.se/research/systems_and_control) within the [Department of Information Technology](https://www.it.uu.se) and the [Centre for Interdisciplinary Mathematics](https://www.math.uu.se/CIM) in Uppsala, supervised by [Fredrik Lindsten](https://liu.se/en/employee/freli29), [Dave Zachariah](http://www.it.uu.se/katalog/davza513), and Erik Sj\u00f6blom. The main focus of my PhD studies is [uncertainty-aware deep learning](http://www.math.uu.se/digitalAssets/396/c_396868-l_1-k_lindsten.pdf). Currently, I am particularly interested in analyzing and evaluating [calibration](https://en.wikipedia.org/wiki/Calibration_(statistics)) of probabilistic models. Please visit [my webpage](https://widmann.dev/research/) for more information.\r\n\r\n[My GitHub profile](https://github.com/devmotion/) provides an overview of my contributions to the Julia ecosystem. Currently, I am a member of the [steering council of SciML](https://sciml.ai/governance.html) and the [Turing team](https://turing.ml/dev/team/).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9739, "guid": "295ef094-2c00-5f0e-bd20-eba11ee5d4c7", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9739-hojbot-a-community-driven-discord-bot", "url": "https://pretalx.com/juliacon2021/talk/JC8S3R/", "title": "HoJBot: a community-driven Discord bot", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Discord is a popular online chat platform that initially appeals to gamers and younger generations but has grown in scope significantly recently. The Humans-of-Julia is a Discord community server founded during the fall last year. The community started building a chatbot called HoJBot in March 2021. This poster will cover some background information, our motivation and the bot\u2019s functionalities", "description": "The HoJBot has several overarching goals:\r\n\r\n1) Help members learn Julia. The bot provides convenient functionalities for members to quickly look up documentations from Julia and popular packages, as well as performing a search at the Julia Discourse site. \r\n\r\n2) Promote open-source collaboration. As we encourage members to contribute to the bot, it becomes a natural playground for members to learn Julia and go through open-source development process.\r\n\r\n3) Automate moderation duties. The bot can detect inappropriate words that potentially violate community rules and automatically hide them as spoiler tags. Moderators are notified automatically in case that the event requires manual investigation. Offensive message can be reported by members, and can be auto-deleted upon reaching a threshold.\r\n\r\n4) Build games and have fun.  The bot provides some simple text-based games that our members can enjoy together. For example, a trading game is created for members to buy/sell stocks using virtual money in real-time. It is one of the most popular features enjoyed by our members.\r\n\r\nThe bot is currently under active development. They are too many contributors to list here. See more details at https://github.com/Humans-of-Julia/HoJBot.jl", "recording_license": "", "do_not_record": false, "persons": [{"id": 1226, "code": "ZVXXQA", "public_name": "Tom Kwong", "biography": "Tom Kwong is an experienced software engineer with over 28 years of industry programming experience. He has spent the majority of his career in the financial services industry. His expertise includes software architecture, design and development. In 2017, he discovered the Julia language and started working on several open-source projects such as SASLib.jl, BinaryTraits.jl and ContextTracking.jl. He has an MS Computer Science degree from University of California, Santa Barbara. He currently works at Facebook.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9669, "guid": "4cb45fa0-11bb-5db0-bc85-17e95cfe6060", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9669-reproducibility-julia-and-renku", "url": "https://pretalx.com/juliacon2021/talk/SBLEKM/", "title": "Reproducibility, Julia, and Renku", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "*Reproducibility* should be a central consideration for data science processes, but it requires some support to achieve. In this talk, we present the **Renku** reproducibility platform and how to take advantage of it from **Julia** focusing two examples: 1. Using Renku to build reproducible workflows in Julia and 2. Facilitating the teaching of Julia-based courses with Renku.", "description": "Doing data science effectively means working reproducibly. Although commitment to reproducibility as an ideal is non-controversial, in practice, it can be challenging to achieve. Many know this from their own experience, and the disconnect between ideal and reality has been well documented in recent years (see the [Fall 2020 issue of the Harvard Data Science Review](https://hdsr.mitpress.mit.edu/pub/hn51kn68/release/3) for just one recent example).\r\n\r\n**Renku** is open-source software being developed at the **Swiss Data Science Center** as a solution for making reproducible data science easier to achieve. It builds upon established software such as *git*, *Docker*, and *Kubernetes* to provide tools necessary to work reproducibly, while offering the flexibility to support a variety of use cases and users working in any language they choose, including *Python*, *R*, and, of course, **Julia**.\r\n\r\nIn this presentation, we will explain the architecture of the Renku platform and show how it can interact with Julia tools, in particular the `Pkg` package manager, to provide scaffolding for portable, reproducible Julia projects. Once we have a project set up, we will work through an example of building a reproducible workflow in Julia using Renku.\r\n\r\nThe same tools that support an individual working reproducibly can be used to [solve some of the hurdles that are encountered teaching a class to many students](https://discourse.julialang.org/t/issues-encountered-teaching-classes-with-julia-for-the-first-time/56553/8). As an example, we will present a set-up that could be used for teaching a class with Julia and provide a comparison of Renku vs. alternatives like Binder for this purpose.\r\n\r\nWe will conclude by looking at some more advanced topics for customizing a Julia-based environment for reproducibility by combining Renku with tools like VSCode, [Dr.Watson](https://juliadynamics.github.io/DrWatson.jl/dev/), or [Pluto.jl](https://github.com/fonsp/Pluto.jl).", "recording_license": "", "do_not_record": false, "persons": [{"id": 1488, "code": "89TPKE", "public_name": "Chandrasekhar Ramakrishnan", "biography": "Chandrasekhar Ramakrishnan studied mathematics at the University of California, Berkeley (B.A. 1997) and art and computer science at the University of California, Santa Barbara (M.A. 2003). He has worked as a software developer and data-science consultant for companies, research institutions, and NGOs in the US, Germany, and Switzerland. Since 2009, he has been at **ETH Z\u00fcrich** supporting projects by developing software solutions for data management, analysis, and visualization.", "answers": []}, {"id": 12073, "code": "ME3HKJ", "public_name": "Gavin Lee", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9798, "guid": "99e150e7-0ab6-54f2-949b-a4e67d69892f", "logo": "/media/juliacon2021/submissions/VDMLMY/00003_nNvfvfk.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9798-typedbclient-jl-interface-to-a-strongly-typed-database", "url": "https://pretalx.com/juliacon2021/talk/VDMLMY/", "title": "TypeDBClient.jl - interface to a strongly-typed database", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "The TypeDBClient.jl provides an interface to a novel type of database called TypeDB. TypeDB is a strongly-typed database, with a rich and logical type system. TypeDB empowers you to solve complex problems, using TypeQL as its query language. It offers a higher abstraction of the entity relation model known in SQL.", "description": "### Introduction\r\nThe project is built by several members from the  Humans of Julia community on Discord. The team has diverse backgrounds and skill levels. It is a joint effort of enthusiastic people to enhance the Julia ecosystem and serves as an educational and open source project.\r\n\r\nThe goal is to implement a new client library in Julia, in addition to the existing clients in Java, NodeJS and Python. Users of the Julia client will benefit from the Julia specific features like clean syntax, strong typing, multiple dispatch and speed. \r\n\r\nBuilding this client requires the team to push forward a couple of technologies:\r\n\r\n- Use Behavior.jl package for  BDD (behaviour driven development)  \r\n- Stabilize  gRPC.jl and related packages (now we are using gRPCClient.jl)\r\n- Dealing with protocol buffers\r\n\r\n### Applicability to the Julia community.\r\nThe Julia community can benefit from having access to the TypeDB database, in all fields related to data science, which can make use of automatic inference and gain new insights from knowledge like in pharmacological research, financial services, machine learning, text mining and more. It is a new tool in the chain to tackle modern problems in modern ways.\r\n\r\n### Contributions to the community.\r\nThe TypeDBClient.jl package will be available in the general registry as a MIT licensed package.\r\nRepository: https://github.com/Humans-of-Julia/TypeDBClient.jl\r\n\r\n### Clarity and what to expect from the talk\r\nThe talk is giving an introduction to the development process and what challenges we face so far and in which way we approach them. This includes the use of other libraries that have been brought back to life, like gRPC.jl or Behavior.jl. Also, it gives some insights of the team approach from a community perspective, working from different time zones and backgrounds.\r\n\r\n### Significance to the community.\r\nThe significance of this package comes from its diverse capabilities of application. As a so-called intelligent database, it can help with all kinds of use cases that incorporate data and knowledge engineering.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9699, "code": "R9LNUF", "public_name": "Mark Schulze", "biography": "Mark Schulze is a legal expert on corporate law & tax, but that only happened to happen after trying to settle in the information & electrical engineering field. After working as an audio engineer in the first place, he continued to work on web applications as a hobby and now approaches to learn backend orientated skills in Julia, that would help to go further in legal tech practises and knowledge engineering.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9573, "guid": "c273c477-f140-5ddc-a57a-679e4ee7aac9", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9573-strengths-and-challenges-of-julia-for-learning-linear-algebra", "url": "https://pretalx.com/juliacon2021/talk/KWNMHU/", "title": "Strengths and Challenges of Julia for learning Linear Algebra", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "Julia notebooks seem like the perfect foundation for learning and teaching linear algebra, but\r\nthe feature sets of the competition (python, Matlab) are deep, and as the concepts get more\r\ninvolved, the functionality involved challenges the capabilities of Julia and its ecosystem of\r\nmodules and visualizations.  The strengths however shine through, making this a platform\r\nworth fighting for.", "description": "Starting with a class historically taught using matlab, I set out to redo the the semester curricula\r\nusing Julia notebooks, learning Julia, graphing, the nature of Juliadata structures and the\r\ndynamic/static tension of the language along the way, while also brushing into regressions\r\nin module updates, and bumping into shortcomings of the current Julia ecosystem compared to\r\ncommercial software.\r\n\r\nAs I work my way through linear systems, iterative methods, curve fitting, optimization,\r\nintegration and differentiation, differential equations, singular value decomposition\r\nand Fourier transforms; my understanding of Julia data structures progress, I gain\r\nbetter command of manipulation and transformation of vectors and matrixes, I produce\r\ndeeper plots of underlying phenomena, I struggle to match the interactive demonstrations\r\nof desktop software, and I begin to glimpse the complex structure going on behind the scenes\r\ntransforming the high level language into the algorithms that ultimately run.\r\n\r\nAfter completing the majority of this endeavor, I see a number of strengths and some\r\nchallenges to completing this work and setting up Julia as a viable platform for education.\r\n\r\nSome key strengths for Julia as a learning platform:\r\n* web notebooks make a beautiful interactive environment\r\n* support of unicode for variables and TeX for text allow for great presentation of math\r\n* powerful language features for building transformation routines\r\n* amazing performance on underlying algorithms once coded properly\r\n\r\nSome opportunities to improve:\r\n* Still a lot of legacy documentation for early Julia version confusing search results\r\n* Lack of mechanism for natively generating figures/diagrams.\r\n* Current documentation focus on what, but not why or how.\r\n* Notebook support for two way interactions with web elements rudimentary at best\r\n* Performance issues with heavy plotting animations, and regressions in GL support\r\n\r\nThe successes show that the potential is there, but there are more advanced visualizations\r\nand simulations that come into play near the end of these courses where Julia falls\r\nshort of matching the current tools used in academia.  A further challenge is the evolving\r\nnature of the language itself, strata of conflicting documentation addressing different\r\ngenerations of the language, and the regressions and shifting functionality of components\r\non the bleeding edge.  With some work, Julia could become the dominant platform for\r\nundergraduate courses; widening its exposure a great deal.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10168, "code": "7VQBNR", "public_name": "John Woolverton", "biography": "Infrastructure programmer building high performance distributed systems, mobile applications, or embedded systems depending on the era.  Historically a C/C++ programmer, but have also spent parts of my career programming in pascal, perl, javascript and other more obscure languages.  Every seven years, I pick up a new tool for my toolbox and this time it was Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9608, "guid": "b56b1de9-fd35-5f60-a31e-d50016053479", "logo": "/media/juliacon2021/submissions/R7G87P/WIN_20210322_14_41_54_Pro_uFmgqYN.jpg", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9608-bootstrapping-data-science-and-diversity", "url": "https://pretalx.com/juliacon2021/talk/R7G87P/", "title": "Bootstrapping Data Science and Diversity", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "The JuliaLang Survey results highlighted lack of Black representation in the Julia community. Learning Data Science on your own can be intimidating, especially coming from a nontraditional career path, and formal tutoring is expensive. Luckily, Julia\u2019s community is willing to help! We are a mentor and mentee who met on Julia Discourse in 2018 and have been working together since. Our experience shows the value of mentorship when bootstrapping your data science career\u2014and how fun and rewarding it", "description": "The 21st century is powered by Big Data, and learning the techniques to extract insights from it will empower individuals and their communities. The JuliaCon 2019 Community Survey Results highlighted a lack of minority representation inside the Julia community. This problem is not just isolated within the Julia community, but is present across the Tech Industry, where Blacks often represent less than ~5% of the workforce. Learning Data Science on your own is hard and can just be flat out discouraging, and formal tutorship programs are often  prohibitively expensive. Luckily, the Julia community has many talented scientists who are willing to help! In this talk, we will share our experience as a mentor and mentee who met on the Julia Discourse in 2018 and have been meeting regularly since then to discuss the programming, statistical, and professional aspects of data science in Julia.  We provide advice and encouragement to anyone else in the Julia community looking to embark on a similar journey.  Help is out there, and in some cases, you may even discover a lifelong mentor and friend.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10203, "code": "GJP3ZR", "public_name": "Matthew A Tillman-Hart", "biography": "Will Fill out later", "answers": []}, {"id": 10212, "code": "QJ98Z7", "public_name": "Sam Urmy", "biography": "Sam Urmy, PhD (@ElOceanografo), is a Research Fish Biologist at the US National Oceanic and Atmospheric Administration's Alaska Fisheries Science Center.  He has used Julia for simulating seabirds, detecting dolphin clicks, and, currently, analyzing sonar surveys of fish in Alaska.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9462, "guid": "1c60101c-3566-5ae9-9786-b5cc4ceac495", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9462-training-deep-learners-and-other-iterative-models-with-mlj", "url": "https://pretalx.com/juliacon2021/talk/AVZECZ/", "title": "Training deep learners and other iterative models with MLJ", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "MLJ.jl (Machine Learning in Julia) is a is a toolbox written in Julia providing  meta-algorithms for selecting, tuning, evaluating, composing and comparing over 150 machine learning models written in Julia and other languages. We describe new developments enabling a user to wrap  iterative models , such as a gradient tree booster or a Flux neural network, in a \"control strategy\".  Wrapping hyper-parameter tuning in a control strategy is a particularly powerful possibility discussed.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 1046, "code": "CK3MKJ", "public_name": "Anthony Blaom", "biography": "Anthony Blaom is a mathematician, publishing chiefly in the areas of differential geometry and dynamical systems, and a scientific computing consultant. He is a co-creator and lead contributor for [MLJ](https://alan-turing-institute.github.io/MLJ.jl/dev/), an open-source machine learning platform written in Julia, which began as a project at the  Alan Turing Institute, London.\r\n\r\nInitially trained as an a mechanical engineer, Anthony earned a PhD in Mathematics at Caltech in 1998. He is currently a Senior Research Fellow in the Department of Computer Science, University of Auckland.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9943, "guid": "8b4f7588-2bb5-5671-ac5f-a995b4ac6fc2", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9943-bounding-the-moments-of-polynomial-jump-diffusion-processes", "url": "https://pretalx.com/juliacon2021/talk/HUUC3C/", "title": "Bounding the Moments of Polynomial Jump-Diffusion Processes", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "We present MarkovBounds.jl -- A meta-package composing several existing packages from the Julia ecosystem to enable the computation of hard, theoretically guaranteed bounds on the stationary and transient moments of jump-diffusion Markov processes with polynomial data from high-level, practitioner-friendly user inputs.", "description": "Stochastic models, especially Markov process models, find numerous applications across various fields such as mathematical finance, control theory and systems biology, for example. While in many of these applications stochastic models offer crucial fidelity over their deterministic counterparts, their analysis is generally more involved. In particular, even the simplest stochastic models rarely admit an analytical solution such that numerical approximation techniques dominate the analysis of stochastic models in practice. Many such techniques, however, rely on unverifiable assumptions and only few provide mechanisms to rigorously quantify the induced approximation error. Recently developed moment bounding schemes [1-7] seek to address this shortcoming. By means of convex optimization, such bounding schemes enable the computation of hard, theoretically guaranteed bounds on the stationary as well as transient moments associated with jump-diffusion processes with polynomial data. While the Julia ecosystem has everything in store to set up and solve the respective optimization problems through JuMP with the help of extensions like MomentOpt.jl and SumOfSquares.jl, it still requires expert knowledge to do so. To close this gap and make moment bounding more accessible to practitioners with a diverse background, we present the meta-package MarkovBounds.jl which integrates the functionalities of the aforementioned packages to automatically generate and solve the respective moment bounding problems from high-level input data. \r\n\r\nIn this brief talk, we sketch the idea of moment bounding schemes and showcase with toy examples drawn from stochastic chemical kinetics and mathematical finance how MarkovBounds.jl enables non-expert users to readily apply them.\r\n\r\n[1]  Garrett R. Dowdy and Paul I. Barton. Bounds on stochastic chemical kinetic systems  at  steady  state. The  Journal  of  chemical  physics,  148(8):84106,2018.\r\n\r\n[2]  Garrett R. Dowdy and Paul I. Barton. Dynamic bounds on stochastic chemical kinetic systems using semidefinite programming. The Journal of Chemical Physics, 149(7):74103, 2018.\r\n\r\n[3]  Khem Raj Ghusinga, Cesar A. Vargas-Garcia, Andrew Lamperski, and Abhyudai Singh. Exact  lower  and  upper  bounds  on  stationary  moments  instochastic biochemical systems. Physical Biology, 14(4):04LT01, 2017.\r\n\r\n[4]  Juan  Kuntz,  Michela  Ottobre,  Guy-Bart  Stan,  and  Mauricio  Barahona. Bounding stationary averages of polynomial diffusions via semidefinite programming. SIAM  Journal  on  Scientific  Computing,  38(6):A3891\u2013A3920,2016.\r\n\r\n[5]  Juan  Kuntz,  Philipp  Thomas,  Guy-Bart  Stan,  and  Mauricio  Barahona. Bounding  the  stationary  distributions  of  the  chemical  master  equation via   mathematical   programming. The Journal of   Chemical Physics,151(3):34109, 2019.\r\n\r\n[6]  Yuta  Sakurai  and  Yutaka  Hori. A  convex  approach  to  steady  state  moment analysis for stochastic chemical reactions.  In2017 IEEE 56th Annual Conference on Decision and Control (CDC), pages 1206\u20131211. IEEE, 2017\r\n\r\n[7] Holtorf, Flemming, and Paul I. Barton. \"Tighter bounds on transient moments of stochastic chemical systems.\" arXiv preprint arXiv:2104.01309 (2021).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10514, "code": "39MLZ3", "public_name": "Flemming Holtorf", "biography": "Flemming is a 3rd year PhD student in the Chemical Engineering Department at MIT working on the moment-based analysis of stochastic processes.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9657, "guid": "fb1b4daf-8aa4-5c74-bd0e-47fe69d8393d", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9657-doctordocstrings-jl-an-interactive-docstrings-worfklow-tool", "url": "https://pretalx.com/juliacon2021/talk/ZVAKDW/", "title": "DoctorDocstrings.jl - an interactive docstrings worfklow tool", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Copy-pasting docstrings formatting from your REPL is repetitive, error-prone and fickle - which is why I created a tool for copy pasting from your previous REPL history entries straight into the source code of your target function. This development tools eases contributions for beginners and facilitates package maintenance for veterans.", "description": "DoctorDoctsrings.jl works by scanning a user's REPL history, prompting the user with TerminalMenus.jl for a selection of their history and desired format and using `@edit` to jump to the target function's source code to alter its docstrings. Additionally, This tool lets a user quickly see which exported names from a package don't have docstrings and/or examples.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1182, "code": "JE89PF", "public_name": "Miguel Raz Guzm\u00e1n Macedo", "biography": "Physics Undergraduate based in Mexico City, UNAM. I enjoy handstands and coding in Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9693, "guid": "76484c96-f20b-59d1-b847-7664f9cddc26", "logo": "/media/juliacon2021/submissions/WJEXYM/TBU_cluster_DaKJEtX.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9693-detection-of-tear-film-breakup-using-julia", "url": "https://pretalx.com/juliacon2021/talk/WJEXYM/", "title": "Detection of tear film breakup using Julia", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Tear film breakup (TBU) is thought to be a major contributor to dry eye syndrome, which afflicts millions worldwide. Although clinicians can easily conduct fluorescence imaging during patient visits and observe what appears to be TBU, there are no widely accepted objective characterizations of TBU, let alone software that can automatically detect it. Julia is being used to detect the corneal region in fluorescence videos, collect regional intensity, and cluster regions based on TBU likelihood.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10331, "code": "HXUXL9", "public_name": "Toby Driscoll", "biography": "Toby Driscoll is a Professor of Mathematical Sciences at the University of Delaware and founding director of the Center for Applications for Mathematics in Medicine. His research is in scientific computing, numerical methods for differential equations, modeling, and biomedical applications. He is the author of the Schwarz-Christoffel Toolbox for MATLAB and a leading contributor to the Chebfun software project. He is author or co-author of four books and is working on a Julia version of the textbook *Fundamentals of Numerical Computation*.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9781, "guid": "96b35cf5-44c5-5d8b-ab38-3af94006afdd", "logo": "/media/juliacon2021/submissions/E9PXP9/Screenshot_from_2021-03-30_11-32-52_Iu88bxo.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9781-pebble-games-time-and-space-to-differentiate-a-program", "url": "https://pretalx.com/juliacon2021/talk/E9PXP9/", "title": "Pebble games - Time and space to differentiate a program", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "The trade-off between time and space is a central issue in reverse mode automatic differentiation. The optimal checkpointing allows people to access computational states in a reversed order with only logarithmic overheads in time and space. Bennett's reversible computing scheme also allows efficient time and space trade-offs. This talk is about the pros and cons of two time and space trade-off schemes within the simple pebble game setup that even a gorilla can understand.", "description": "Youtube Video: https://youtu.be/Qf10_ngKMRw\r\n\r\n## References\r\n1. Reversible programming\r\nhttps://github.com/GiggleLiu/NiLang.jl\r\n2. Optimal checkpointing\r\nhttps://www.tandfonline.com/doi/abs/10.1080/10556789208805505", "recording_license": "", "do_not_record": false, "persons": [{"id": 1062, "code": "QBUZQE", "public_name": "JinGuo Liu", "biography": "https://giggleliu.github.io/about/", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9843, "guid": "7487cbc1-be37-52fb-aab9-830740657526", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9843-musical-julia", "url": "https://pretalx.com/juliacon2021/talk/CMPNPF/", "title": "Musical Julia", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "Why would a 6th grader like myself learn about Julia? I had heard of a language called Julia and started programming in Julia with the help of an amazing book called the \"Little Book of Julia Algorithms\". Programming in Julia was great fun and made me perceive things from a coding point of view and I want to share my experiences as I begin my journey in Julia with my first project-A Musical Note Convertor.", "description": "I used to do pictorial block programming in languages like Scratch. But these pictorial blocks were quite basic, and though they could enable me to do quite a lot, I preferred to try to make my own things, some of which were beyond the blocks given in Scratch.   \r\n\r\nProgramming in Julia was great fun and made me perceive things from a coding point of view. I also used the Math I had learned from school to program simple things like a calculator, and I started thinking about how I could use Julia to change or improve some aspects of human life or just make things easier. I\u2019m very fond of music and had been taught both the Western notation and the Indian Classical ones. However, my mother was having trouble deciphering the western notes, since she had been only trained in Indian Classical Music. \r\n\r\nThen the idea hit me. What if I could use Julia to create a Musical Note converter? If I entered the notes of a song, it could translate it into western or Indian Classical Music, according to the user\u2019s need. I then made a simple if-loop program which converts a single note. Now, I plan to work on this idea further. It will be a bit of a challenge but I\u2019m excited to do it. To conclude, there are limitless possibilities of things I want to do and create in Julia, and it\u2019s really quite interesting to learn. I know this idea seems quite simple, and will be in front of all the other Julia Con submissions. But I\u2019d really love to come ahead and share my experience on Julia Con. \r\n\r\nI would love to talk about Julia and my wonderful experience so far. I also hope I\u2019ll have many more in the future.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10429, "code": "ZAHQEL", "public_name": "Radhika Ivaturi", "biography": "Age: \r\n10 Years\r\n\r\nEducation: \r\n6th Grade, Sree VidyaNikethan International School, Hyderabad, India", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9840, "guid": "34422806-3ba7-5589-89e6-2b7ef9bdfd94", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9840-view5d-jl", "url": "https://pretalx.com/juliacon2021/talk/88MYCE/", "title": "View5D.jl", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Visualizing multiple-dimensional (ND) datasets (AbstractArrays) is important for data research and debugging of ND algorithms. `View5D.jl`  (https://github.com/RainerHeintzmann/View5D.jl) is a Java-based viewer for up to 5-dimensional data (including `Complex`). It supports three mutually linked orthogonal slicing displays for XYZ coordinates, arbitrary numbers of colors (4th `element` dimension) which can also be used to display spectral curves and a time slider for the 5th dimension.", "description": "# View5D\r\nThe Java viewer `View5D` has been integrated into julia with the help of `JavaCall.jl`.  The viewer has its full Java functionality which includes displaying and interacting with 5D data and a decent way of interaction from the Julia side (see section **Interaction with Julia** below). Generating up to three-dimensional histograms and interacting with them to select regions of interest in the 3D histogram but shown as a selection in the data. It allows selection of a gate `element` where thresholds can be applied to which have an effect on statistical evaluation (mean, max, min) in other `element`s if the `gate` is activated. It further supports multiplicative overlay of colors. This feature is nice when processed data (e.g. local orientation information or polarization direction or ratios) needs to be presented along with brightness data. By choosing a gray-valued and a  constant brightness value-only (HSV) colormap for brightness and orientation data respectively, in multiplicative overlay mode a result is obtained that looks like the orientation information is staining the brightness. These results look often much nicer compared to gating-based display based on a brightness-gate, which is also supported.\r\nColor display of floating-point or 16 or higher bit data supports adaptively updating colormaps.\r\nZooming in on a colormap,  by changing the lower and upper display threshold, for some time the colormap is simply changed to yield a smooth experience but occasionally the cached display data is recomputed to avoid loosing fine granularity on the color levels.\r\n\r\n`View5D` also supports displaying and interacting with tracking in 3D over time (and other combinations) datasets.  This can come in handy for single particle or cell tracking. A particularly interesting feature is that the data can be pinned (aligned) to a chosen track. \r\n\r\n`View5D` has 3 context menus (main panel, element view panel and general) with large variety of ways to change the display. \r\n\r\n## Interaction with Julia\r\nThe interaction to Julia supports calling the viewer via one main method `view5d` supporting various options. Since the viewer is most useful for quick visualization and debugging, a multitude of short-hand convenience functions are provided:\r\n- `vv(data)`: starts a new viewer (window) and displays the data\r\n- `vp(data)`: starts a new viewer (window) and displays the data as complex values with a **color-phase** (multiplicative) overlay as a second channel. This is particularly useful for displaying complex-valued data. By default the `gamma ` correction for display is set to 0.3 enhancing the low-values. Naturally this can be prevented by the optional named argument `gamma` for all of the calls.\r\n- `ve(data)`: concatenates the data to display to the currently \"active\" viewer as a new entry along the element (==color) direction.\r\n- `vt(data)`: concatenates the data to display to the currently \"active\" viewer as a new entry along the time (slider on the right side) direction.\r\n- `vtp(data)`, `vep(data)`: concatenates color-phase display (see `vp`) along respective data directions.\r\n- `vr(data)`: replaces the currently displayed data in the currently \"active\" viewer by this new `data`.\r\n- `vrp(data)`: replaces color-phase display data in the currently \"active\" viewer by this new color-phase display `data`.\r\n\r\nAll of these function have corresponding macros (`@vv`, `@vp` etc.) to be used in analogy to the `@show` method. This eases debugging. If the preceding expression is a viewer reference, display is directed to this specific viewer. Here an example to update a specific viewer display every second in a for loop:\r\n```julia\r\nv= @vr rand(10,10,10,3); for n in 1:10  sleep(1); @vr v rand(10,10,10,3) end\r\n```\r\nImporting and exporting hierarchical sets of markers into and from the viewer are supported (`export_marker_lists`, `import_marker_lists`).\r\n\r\nView5D features a wide range of data formats: `Float32`, `Float64`, `UInt8`, `Int8`, `UInt16`, `Int16`, `UInt32`, `Int32`, `Int`, `Complex32`, `RGB` and `Gray`, also the outputs of the `Images.jl` `BioformatsLoader.jl` package. If context information such as axes sizes is available, it will shown accordingly in the viewer.\r\n\r\nDisplay of `Complex`-valued data can be toggled between `magnitude`, `phase`, `real` and `imaginary` part.  A complex-valued array by default switches the viewer to a `gamma` of 0.3 easing the inspection of Fourier-transformed data. However, gamma is adjustable interactively as well as when invoking the viewer.\r\n\r\nSince the viewer is written in Java and launched via JavaCall its thread should be pretty independent from julia. This should make the user experience pretty smooth also with minimal implications to julia threading performance. \r\n\r\nA current problems of `View5D` is that it is not well suited to displaying large datasets. This is due to memory usage and slow display due to on-the-fly calculations of features such as averages and the like.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10334, "code": "CNV3SE", "public_name": "Rainer Heintzmann", "biography": "My research focuses on developing tools to image cellular function at high resolution. We develop techniques to measure multidimensional information in small biological objects such as cells, cellular organelles or other small structures of interest. Computer-based reconstruction methods, especially inverse-modeling based in automatic differentiation are of primary interest.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9775, "guid": "5447d182-3503-561d-81f1-317ae80af99e", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9775-gift-orders-of-magnitude-of-speed-up-to-random-strangers", "url": "https://pretalx.com/juliacon2021/talk/YYJCM8/", "title": "Gift orders of magnitude of speed up to random strangers", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Certain mathematical problems have a structure that makes them easy to solver compared to the base problem. A rigid body mechanics problem given in a generic interface for differential equations is transformed into an easier problem which can be solved many orders of magnitude faster.", "description": "A special subclass of linear differential equations are nilpotent linear differential equations. If the matrix exponential of such a matrix is calculated (as is done commonly to accelerate solving linear differential equations) the matrix exponential is actually just a polynomial, if this known before (at the time when the ODE object is created) the time solution and be reduced drastically at increased accuracy.\r\nWhile this transformation is obscure it can be readily available to anyone using the SciML ecosystem thanks to the magic of multiple dispatch.\r\nWe will look at an unconstrained rigid body dynamics problem that occur in video games and demonstrate a 100x to 1000x performance advantage over other solvers available from DifferentialEquations.jl. This not only introduces a neat example of mathematical trickery but should serve to guide and inspire the audience how they can integrate this one strange trick from a problem domain they have experience in and make the larger Julia ecosystem better.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4362, "code": "CCLRPG", "public_name": "Johann-Tobias Sch\u00e4g", "biography": "Student of Technical Cybernetics (Technische Kybernetik und Systemtheorie) at TU Ilmenau, Germany.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9857, "guid": "16cdeca4-fdac-5f10-bab9-e5883816de3d", "logo": "/media/juliacon2021/submissions/YGLES8/notch_ikJuIeS.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9857-peridyn-a-peridynamics-package", "url": "https://pretalx.com/juliacon2021/talk/YGLES8/", "title": "PeriDyn: A Peridynamics Package", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "PeriDyn is an implementation of peridynamics, an integral reformulation of continuum equations of motion. PeriDyn uses DifferentialEquations_jl for solvers, i.e., integrate equations of motion and provides helper functions to stage simulations. It provides an easy implementation of custom material and contact models, allowing the simulation of complex systems. It also writes particle trajectory (similar to MD trajectory in LAMMPS), which can be visualized using software like Ovito.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10447, "code": "9FJ38N", "public_name": "Ravinder Bhattoo", "biography": "Ravinder works on machine learning in material design, dynamic fracture and cracks propagation on ballistic impact, and two-dimensional materials. He completed his B.Tech in Civil Engineering from IIT Roorkee. He worked in the industry for a year after which joined M3RG, IIT Delhi as a research scholar.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9871, "guid": "7d69fc1f-923d-50d3-aa4d-9f8ce2634ff3", "logo": "/media/juliacon2021/submissions/VEUKD9/simulated_lagr_float03_LbusBgl.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9871-oceanrobots-jl-ocean-robots-simulation-and-data-ingestion", "url": "https://pretalx.com/juliacon2021/talk/VEUKD9/", "title": "OceanRobots.jl -- Ocean Robots Simulation And Data Ingestion", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "This package simulates data collected by autonomous, remotely operated, or manned vehicles in the Ocean. The simulated robots readily have three-dimensional navigation (e.g. isopycnal) and flexible sampling (e.g. profiles) capabilities. The package can also ingest real data collected by such means, which enables effective model-data combination workflows (e.g. model training, state estimation, UQ).", "description": "OceanRobots.jl leverages the [IndividualDisplacements.jl](https://github.com/JuliaClimate/IndividualDisplacements.jl) package for simulating robot trajectories in the ocean and the [ArgoData.jl](https://github.com/JuliaOcean/ArgoData.jl) package for collecting vertical profiles of ocean variables along the way. \r\n\r\nThe initial focus is on simulating major data sets being collected by the Argo array of profiling floats (physical oceanography, chemistry, and ecology), Global Drifter Program (surface buoys), glider deployments (underwater vehicles), and repeat hydrography (ships).\r\n\r\nEnvisioned applications include:\r\n\r\n- model training, state estimation, uncertainty quantification\r\n- oceanography field experiment planning, optimization of observing systems\r\n- monitoring, navigation, and programing of robots deployed in the real Ocean", "recording_license": "", "do_not_record": false, "persons": [{"id": 10449, "code": "PFYSJ9", "public_name": "Gael Forget", "biography": "I work as a reseach scientist at the Massachusetts Institute of Technology (MIT) where I investigate oceanography and climate. As part of the Department of Earth, Atmospheric and Planetary Sciences, my work focuses on ocean modeling and the analysis of global ocean data sets such as Argo profile collections, satellite records of sea level, or ocean color retrievals. I co-develop computer programs in various languages and carry out ocean state estimation using the MIT general circulation model in order to interpolate and interpret ocean observations. My scientific interests include: ocean circulation and climate variability; tracer transport and turbulent transformation processes; interaction of ecological, geochemical, and physical processes; global cycles of heat, water, and carbon; observational statistics; forward and inverse modeling.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9706, "guid": "6477cd9c-9ab0-5eaa-94ea-945f4c6b2260", "logo": "/media/juliacon2021/submissions/3CJQWH/Drawing.sketchpad_TZtAsrs.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9706-auto-parallelization-at-cloud-scale-with-banyan", "url": "https://pretalx.com/juliacon2021/talk/3CJQWH/", "title": "Auto-Parallelization at Cloud Scale with Banyan", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Running Julia code at scale can be quite difficult. First, running at scale typically requires rewriting a significant amount of code to use libraries such as MPI.jl, Dagger.jl, Spark.jl, etc. Second, it requires developing a strategy for deploying a cluster either on-premise or in the cloud. In our talk, we discuss how the Banyan suite of libraries enables instant offload of existing code to multi-node clusters in the cloud with maximal utilization of RAM and CPU cache.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10346, "code": "MQTPBB", "public_name": "Caleb Winston", "biography": "Caleb Winston is a co-creator of Banyan and the creator of Emu, a GPGPU framework for Rust. In the past, he has worked on GPU-accelerated data science at NVIDIA and virtualization for wet labs at the Molecular Information Systems Lab at the University of Washington, Seattle. His primary interests are in making computing at both massive scale and the edge accessible for anyone to easily program.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9561, "guid": "d5987e4b-8e7b-5666-b053-07663b6a230e", "logo": "/media/juliacon2021/submissions/MFAQKW/JuliaCon2021_wFberyq.jpg", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9561-use-of-julia-language-in-the-forest-inventory", "url": "https://pretalx.com/juliacon2021/talk/MFAQKW/", "title": "Use of Julia Language in the Forest Inventory", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "The present work aims to develop a package with the sampling processes existing in the Forest Inventory in Julia Programming Language, intending to provide didactic materials, facilitating the process of data processing, teaching, and learning for students and professionals in the field.", "description": "The Forest Inventory is a name given to forest stand administration. It assesses changes in a forest, such as growth and development, and quantifies its total or commercial bulk. In the Forest Engineering course, it is one of the subjects of the greatest importance in the college curriculum. Most forest inventories are carried out by sampling, aimed to evaluate just one part of the stand that makes up the sample. They can be categorized into sampling techniques according to their periodicity, structure, and population approach. In this context, Julia Language is a promising programming software in the field of forest science because it is open access and high performance, faster to data analysis, easily learning, and has vast knowledge in other scientific and numerical computing systems. In this way, it will be able to process the data collected from the forest inventory with agility, saving time and costs. Thus, the project aims to develop a package contend the created functions about each sampling existing in the forest inventory with Julia Programming Language, intending to provide didactic materials, facilitating the process of teaching and learning of students and professional in the field which carry out processes sampling indispensable in the forest sector. In the development of the functions and creation of a package about the sampling processes in the forest inventory, the Julia programming language will be used, together with the Visual Studio Code source code interface. The basic aspects will be improved to make it easier for forest engineers to understand, taking into account that most are not specialists in the programming language. The creation of the programming package will be based on the sampling processes by researchers Sylvio P\u00e9llico Netto and Do\u00e1di Ant\u00f4nio Brena in the Forest Inventory book, 1997. In this sense, each process of sampling will be created with an individual function being they: simple random sampling, stratified sampling, systematic sampling, two-stage sampling, cluster sampling, systematic sampling with multiple random starts, and sampling on multiple occasions (independent sampling, with total repeat, double repeat, and partial repeat). To evaluate the use of the package created in Julia Language, tests will be carried out with students, and professionals from Forest Engineering. From the tests, it will be possible to evaluate the acceptance of the data processing package in the different sampling processes of the forest inventory.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10147, "code": "XKFD7A", "public_name": "Claiton Nardini", "biography": "Forest Engineer, from the Federal University of Santa Maria (UFSM) Frederico Westphalen Campus. Currently a Master's student in the Graduate Program in Agronomy: Agriculture and Environment at UFSM - FW. He develops works in the areas of Forest Engineering, Agrometeorology, Vegetable Production, Forest Biomass, Agroforestry Systems and Julia Language applied in the Forest Inventory.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9878, "guid": "0f4e56ca-87b8-5c11-a846-38be1aa4860e", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9878-julia-for-charge-transport-in-condensed-matter", "url": "https://pretalx.com/juliacon2021/talk/ZZTJ3U/", "title": "Julia for Charge Transport in Condensed Matter", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Charge transport and reactions in electrochemical and semiconductor devices are described by systems of nonlinear PDEs for the electric field and the diffusive and convective movement of charged particles.\r\nA finite volume discretization approach turns these into a system of nonlinear algebraic equations.  The Julia package VoronoiFVM.jl provides an infrastructure or this discretization approach and uses forward mode AD to set up the sparse Jacobi matrices for the solution with Newton's method.", "description": "In the talk we give a short introduction into the application case and provide some simulation examples highlighting the capabilities of Julia and the VoronoiFVM.jl package. In addition we give an overview on a number of Julia packages for meshing, sparse matrix handling and visualization which have grown around the package and are now part of the Meta package PDELib.jl. \r\n\r\n[1] J.Fuhrmann & contributors: https://github.com/j-fu/VoronoiFVM.jl \r\n\r\n[2] D. Abdel, P. V\u00e1gner, J. Fuhrmann, and P. Farrell, \u201cModelling charge transport in perovskite solar cells: Potential-based and limiting ion vacancy depletion,\u201d Preprint 2780, 2020. URL: http://www.wias-berlin.de/preprint/2780/wias_preprints_2780.pdf.\r\n\r\n[3] V. Milo\u0161, P. V\u00e1gner, D. Bud\u00e1\u010d, M. Carda, M. Paidar, J. Fuhrmann, and K. Bouzek, \u201cGeneralized Poisson-Nernst-Planck-based physical model of O2 | LSM | YSZ electrode,\u201d Preprint 2797, 2020. URL: http://www.wias-berlin.de/preprint/2797/wias_preprints_2797.pdf.\r\n\r\n[4] B. Gaudeul and J. Fuhrmann, \u201cEntropy and convergence analysis for two finite volume schemes for a Nernst-Planck-Poisson system with ion volume constraints.\u201d 2021. URL: http://www.wias-berlin.de/preprint/2811/wias_preprints_2811.pdf.\r\n\r\n[5] D. Abdel, J. Fuhrmann, and P. Farrell, \u201cAssessing the quality of the excess chemical potential flux scheme for degenerate semiconductor device simulation,\u201d Opt. Quant. Electr, vol. 41, no. 53, p. 163, 2021.\r\n\r\n[6] C. Canc\u00e8s, C. Chainais-Hillairet, J. Fuhrmann, and B. Gaudeul, \u201cA numerical-analysis-focused comparison of several finite volume schemes for a unipolar degenerate drift-diffusion model,\u201d IMA Journal of Numerical Analysis, vol. 41, no. 1, pp. 271\u2013314, 2021. \r\n\r\n[7] P. V\u00e1gner, C. Guhlke, V. Milo\u0161, R. M\u00fcller, and J. Fuhrmann, \u201cA continuum model for yttria-stabilized zirconia incorporating triple phase boundary, lattice structure and immobile oxide ions,\u201d Journal of Solid State Electrochemistry, vol. 23, pp. 2907\u20132926, 2019.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4392, "code": "XR3TFU", "public_name": "J\u00fcrgen Fuhrmann", "biography": "Born 1961 in Erfurt, Germany. Diploma in mathematics from Moscow State University in 1984,  Ph.D from Technical University Chemnitz-Zwickau in 1995.  Joined the Karl-Weierstra\u00df-Institute Institute of Mathematics of the Academy of Sciences of the GDR in 1984.\r\nSince  1992 with Weierstrass Institute for Applied Analysis and Stochastics (WIAS). Currently, deputy head of the Numerical Analysis group of WIAS. Main field of activity is algorithm and software development for nonlinear systems of partial differential equations. Interdisciplinary research activities include numerical modeling of various phenomena in fuel cells, batteries, semiconductors, subsurface flow processes.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9459, "guid": "c74754d7-7902-56e7-99b8-88d53947bd74", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9459-distributed-computing-using-awsclustermanagers-jl", "url": "https://pretalx.com/juliacon2021/talk/Z9UL8P/", "title": "Distributed Computing using AWSClusterManagers.jl", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Distributed computing is a common approach to accessing large amounts of resources. The AWSClusterManagers.jl package allows users to leverage AWS to run scaled computing environments with Docker, Elastic Container Service (ECS), or Batch.", "description": "AWSClusterManagers.jl is a package which allows you to run your distributed workload on AWS. You can now free up your own machine, and quickly and easily run your work load in parallel in the cloud.\r\n\r\nAn example demo showcased can be found below:\r\n- https://github.com/mattBrzezinski/AWSClusterManagersDemo.jl", "recording_license": "", "do_not_record": false, "persons": [{"id": 4110, "code": "M99LZJ", "public_name": "Matt Brzezinski", "biography": "Software Developer at Invenia Technical Computing.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9537, "guid": "80c1b936-58b6-51ed-90ea-e502d3bcf913", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9537-lale-in-julia-a-package-for-semi-automated-data-science", "url": "https://pretalx.com/juliacon2021/talk/KQAN8F/", "title": "Lale in Julia: A package for semi-automated data science", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Lale.jl is a Julia wrapper of lale Python library for semi-automated data science. Lale.jl offers scikit-learn compatible AutoML with algorithm selection and hyper-parameter tuning. Lale.jl provides a consistent high-level interface to existing AutoML optimizer backends such as Hyperopt, GridSearchCV, and SMAC. It has a standard search space specification with out of the box search space for 180 operators from scikit-learn, imblearn, AIF360, SnapML and more.", "description": "The talk will cover a demo of Lale (https://github.com/IBM/Lale.jl) usage including its highly flexible pipeline grammar to describe its support for more complicated workflows and their optimization. We will start with the basics followed by its typical usage and gradually disclose more features for AutoML application. Lale's simple and expressive pipeline grammar provides a great flexible toolkit for data scientists in Python and Julia which makes the creation and evaluation of different machine learning pipelines including complex ones, trivial.\r\n\r\nSlides: https://github.com/IBM/Lale.jl/blob/main/docs/lale-julia.pptx", "recording_license": "", "do_not_record": false, "persons": [{"id": 1072, "code": "3EKCYY", "public_name": "Paulito Palmes, PhD", "biography": "I am a research scientist at the IBM Research working on the following areas: AutoML, AutoAI, RL/ML Optimization, and Decision Optimization.", "answers": []}, {"id": 10268, "code": "3XBVLH", "public_name": "Kiran Kate", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9909, "guid": "3e616b98-c990-5630-bfc6-6b2840f41a56", "logo": "/media/juliacon2021/submissions/BNUBRB/Screenshot_2021-07-05_at_12.17.10_Mt1SzQ8.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9909-decomposition-physics-informed-neural-networks-pinns-", "url": "https://pretalx.com/juliacon2021/talk/BNUBRB/", "title": "Decomposition Physics-Informed Neural Networks (PINNs)", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Physics-Informed Neural Networks is a method for solving PDE based on train neural networks, which give an approximate solution for nonlinear partial differential equations (PDEs).\r\nUsing one huge neural network to solve a whole problem has its limitations and difficulty for obtaining prediction. One way to overcome this, to split the problem into subtasks.\r\nThe purpose of the report is to demonstrate the methods implemented in NeuralPDE for separating the learning process of PDE into subtasks.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10492, "code": "BMB8P3", "public_name": "Kirill Zubov", "biography": "developer NeuralPDE", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9634, "guid": "2bb0c8fb-885f-545c-b67e-e40d73ffd6a8", "logo": "/media/juliacon2021/submissions/Z7X3DP/bp_abstract_UTwFBar.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9634-bioprofiling-jl-profiling-for-high-content-cell-imaging", "url": "https://pretalx.com/juliacon2021/talk/Z7X3DP/", "title": "BioProfiling.jl: Profiling for high-content cell imaging", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "We present BioProfiling.jl, which provides an end-to-end and efficient solution for assembling and curating informative cellular morphological profiles in Julia.\r\n\r\nThis contains all the necessary data structures to curate morphological measurements, helpers functions to transform, normalize and visualize profiles as well as ways to quantify the statistical significance of the morphological changes observed.\r\n\r\nThe Julia package is freely and openly [available on GitHub](https://bit.ly/318opt4).", "description": "High-content imaging screens provide a cost-effective and scalable way to assess cell states across diverse experimental conditions. The analysis of the acquired microscopy images involves assembling and curating morphological measurements of individual cells into morphological profiles suitable for testing biological hypotheses. Despite being a critical step, there is currently no standard approach to morphological profiling and no solution is available for the high-performance Julia programming language.\r\n\r\nHere, we introduce BioProfiling.jl, an efficient end-to-end solution for compiling and filtering informative morphological profiles in Julia. The package contains all the necessary data structures to curate morphological measurements and helper functions to transform, normalize and visualize profiles. Robust statistical distances and permutation tests enable quantification of the significance of the observed changes despite the high fraction of outliers inherent to high-content screens. This package also simplifies visual artifact diagnostics, thus streamlining a bottleneck of morphological analyses. We also showcase the features of the package by analyzing a chemical imaging screen, in which the morphological profiles prove to be informative about the compounds\u2019 mechanisms of action and can be conveniently integrated with the network localization of molecular targets.\r\n\r\nIn this virtual poster, we will (i) present what BioProfiling.jl can do, (ii) discuss how to make it useful for more biological and scientific applications relying on curating tabular measurement data and (iii) consider how to improve its performance and reduce its external dependencies, aiming to make it a pure-Julia package.\r\n\r\nThe Julia package is available on [GitHub](https://github.com/menchelab/BioProfiling.jl). We also provide [Jupyter notebooks reproducing our analyses](https://github.com/menchelab/BioProfilingNotebooks).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10267, "code": "BXUBLV", "public_name": "Loan Vulliard", "biography": "Interested in networks medicine, systems biology and bioinformatics, I am currently a predoctoral researcher in the group of J\u00f6rg Menche at the Max Perutz Labs and the Research Center for Molecular Medicine in Vienna, Austria. You can learn more about me on [my personal website](http://hub.vulliard.loan/).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9828, "guid": "10d50438-b13c-5387-80cd-ca11cb631686", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9828-a-tool-for-julia-bloggers", "url": "https://pretalx.com/juliacon2021/talk/ZS9XPN/", "title": "A Tool for Julia Bloggers", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "A tool is demonstrated that generates static web pages from a Jupyter notebook. The web page is both higher in fidelity and smaller in character count than that produced by Jupyter's \"export\" function. The resulting static page is used to create blog posts for the \"Red White and Julia\" blog on Blogger.com.", "description": "After creating more than 60 Jupyter notebooks using Julia, it dawned on me to post static versions of these notebooks on a blog. Then the weeping and gnashing of teeth started, for the static pages generated by Jupyter's \"export\" function have extremely high character counts, the code cells are missing line numbers, and etc.\r\n\r\nA custom exporter tool was written to fix this. This tool generates HTML files that can almost be immediately moved to the \"Red White and Julia\" blog at https://red-white-and-julia.blogspot.com/\r\n\r\nThe features of Jupyter notebooks that are successfully exported by this tool include markdown, LaTeX, code cells, and some types of charts. All this will be demonstrated, along with a complete Jupyter to Blogger workflow.\r\n\r\nThe presentation will conclude by enumerating some planned features for this tool as well as plans for making it widely available.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10360, "code": "7NGC73", "public_name": "Mike Klepper", "biography": "Mike Klepper is a software engineer working in web-database connectivity and IoT arenas. He holds a BSc in mathematics from the University That Shall Not Be Named, and a MSc in computer science from Franklin University in Columbus, Ohio.\r\n\r\nHe is the author of several blogs including \"Patriot Geek\" and \"Red White and Julia\".\r\n\r\nHe is currently pursuing a master's degree in mathematics from the Open University in the UK.\r\n\r\nIn his copious spare time he is the operations officer for a community support group in eastern Pennsylvania, where he is developing the concepts of \"counter-logistics\" and \"logistic system reverse engineering.\"", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9379, "guid": "d14458ca-ae14-5a50-8267-588f50da01a7", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9379-applications-of-julia-for-network-science-text-analysis", "url": "https://pretalx.com/juliacon2021/talk/QNWEDW/", "title": "Applications of Julia for Network Science Text Analysis", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "I will discuss my experience using Julia to perform semantic text processing on short texts, which was a lot of firsts for me: my first time using Julia, and first project tracked through Github. I will talk through how we used Julia specifically to perform the text analysis, my experience trying to troubleshoot and find Julia documentation online (which can be difficult yet rewarding!), and in particular, the ways in which Julia allowed us to vary our use of methods and display of our results.", "description": "I will discuss my experience using Julia to perform semantic text processing on short texts, which was a lot of firsts for me: first big research project, first time using Julia, and first project tracked through Github. I will talk through how we used Julia specifically to perform the text analysis, my experience trying to troubleshoot and find Julia documentation online (which can be difficult yet rewarding!), and in particular, the ways in which Julia\u2019s compiling and use in Jupiter Notebooks expedited our work, and allowed us to vary our use of methods and display of our results. I really enjoyed using Julia, and although I don\u2019t like text-processing, coding in Julia made our semantic text analysis interesting and intuitive.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9843, "code": "ABQCVC", "public_name": "Mira Tellegen", "biography": "I'm a third-year Math/Computer Science major at Grinnell College. I'm interested in data protection, cybersecurity, and user interface. In my free time, I'm a captain of Grinnell's Mock Trial Team, and I bake and cook.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9769, "guid": "f4250f79-6df8-5e26-b02d-27c65c49f037", "logo": "/media/juliacon2021/submissions/93E8GZ/ML4Geo_v01-square_8GMxvLv.jpg", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9769-ml4geo-machine-learning-for-geosciences", "url": "https://pretalx.com/juliacon2021/talk/93E8GZ/", "title": "ML4Geo: Machine Learning for Geosciences", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "ML4Geo is an open-source machine-learning framework designed for various types of analyses of geoscience data.  ML4Geo has been already applied to investigate diverse datasets related to Earth sciences, including climatic, geologic, geophysics, geothermal, carbon storage, oil/gas, and wildfire applications", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10383, "code": "PMRGDL", "public_name": "Velimir Vesselinov", "biography": "My expertise is in applied mathematics, computer science and engineering. My research is in the general area of data analytics, model diagnostics and machine learning. I am the inventor and lead developer of a series of novel theoretical methods and computational related to machine learning, data analytics, model diagnostics, and data inference tools. I am also a co-inventor of LANL-patented machine-leaning methodology. Over the years, I have been the principal investigator of several projects for machine learning, model development, model analyses, uncertainty quantification and decision support", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9802, "guid": "281dbdab-692d-5bc1-b5af-5ed095a0f2b8", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9802-in-situ-inference-for-exascale-simulations-with-julia", "url": "https://pretalx.com/juliacon2021/talk/Q7WXPH/", "title": "In-Situ Inference for Exascale Simulations with Julia", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Exascale simulations, like those of interest to the Department of Energy, will produce more data than can be stored for post hoc statistical analysis. To address this, we are using Julia as an HPC-embedded language to develop workflows for statistical analysis inside simulations as they run. Our project, PRISM, is being developed to fit Bayesian hierarchical models to answer scientific questions using the high resolution data that will be produced on the next generation of supercomputers.", "description": "High performance computing (HPC) has enabled predictive simulation models that have revolutionized physics, chemistry, biology, and other sciences. Modern supercomputers with exascale performance (one billion billion calculations per second) will create massive new quantities of simulation data. Saving this data has become a computational bottleneck: because storage is much slower than processors, only a tiny fraction of data generated by an exascale simulation can be saved to disk for later statistical analysis. Larger supercomputers will simulate physical systems with unprecedented detail, opening new avenues for scientific advancement, but as computational speed increases, a decreasing fraction of simulation data can be analyzed, limiting the scientific gains that can be realized.\r\nIn response to this barrier, \u201cin-situ\u201d approaches have emerged to analyze data within the simulation itself, as the data are being generated, without needing to first save them to disk. Most of these approaches focus on compressing data by extracting scientifically informative features, such as the locations of interesting events within the simulation. However, they do not address the broader problem of inference: fitting statistical models, such as large-scale regressions, to spatial and time series data. A large body of advanced statistical analysis techniques therefore cannot be applied to exascale simulation data.\r\nWe have begun developing the algorithms and software tools to fit sophisticated statistical models in-situ. We are using Julia to implement new statistical algorithms that can analyze scientific data efficiently on exascale supercomputers, dealing with unique computational challenges presented by in-situ analysis. These challenges include distributing the calculation of data correlations in parallel across many computational nodes while minimizing slow inter-node communication; analyzing data one piece at a time when they are too large to hold in memory at once; and constructing faster algorithms to fit statistical models that will not slow down the simulation while analysis\r\noccurs. We are applying these new analysis techniques in the context of modeling extreme events in climate and space weather simulations.\r\nOur project\u2019s primary deliverable is the Programming Repository for In Situ Modeling (PRISM). PRISM is a set of tools for fitting statistics and machine learning models to simulation data inside the simulations as they are running. The tools are designed to implement a wide variety of data analyses with an emphasis on spatiotemporal hierarchical Bayesian models. PRISM is intended to be efficient, scalable, and streaming with estimation based on variational inference, advanced Monte Carlo techniques, and fast optimization methods. The core modeling components aid this goal by imposing sparsity and approximate inference wherever possible. All of these components are being written in Julia to enable data scientists to write code in a high-level programming language that is performant enough to keep up with the C/C++ and Fortran codes it will be embedded within. PRISM also contains tools for interfacing with large-scale scientific simulations written in Fortran and C/C++. This layer of abstraction allows the data scientist to construct analysis models in Julia without concern for the implementation details of the simulation capability. With these components, PRISM can be used to unlock the full scientific potential of next-generation HPC simulations.\r\nThus far, we have implemented methods for distributed sparse Gaussian processes, Gaussian mixture modeling for clustering, and extreme value modeling. We have also implemented fast estimation techniques based on sequential variational inference (an approximation scheme for estimating Bayesian posterior distribution) and deep neural networks to optimize parameters of Gaussian process models. This work also includes domain-specific analyses for the detection of sudden stratospheric warming in a climate simulation and the identification of fast plasma flow channels in a space weather simulation. These techniques have been demonstrated on high-performance computing hardware at Los Alamos National Laboratory.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10053, "code": "KDURNQ", "public_name": "Ayan Biswas", "biography": "Ayan Biswas is a scientist in the Data Science at Scale team (CCS-3) at Los Alamos National Laboratory. His research interests include exascale data analysis and reduction, in situ workflows, uncertainty quantification, statistical analysis/inference and high-dimensional data visualization. He also has vast experience in working with vector fields and information theory applications for visualization and analysis. He received his PhD in Data Visualization from The Ohio State University in 2016. Contact him at ayan@lanl.gov.", "answers": []}, {"id": 10405, "code": "GEBDZP", "public_name": "Earl Lawrence", "biography": "Group leader for Statistical Sciences at Los Alamos National Laboratory", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9591, "guid": "85ac1f76-6a6e-552e-9412-8d44dd06ecda", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9591-optimization-based-gap-finding-and-filling-in-julia", "url": "https://pretalx.com/juliacon2021/talk/WHD7HK/", "title": "Optimization-based gap finding and filling in Julia", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Metabolic reconstructions are widely used to study metabolism of biological systems. The application of network curation tools is currently hampered by the scalability of algorithms and the availability of software supports. GapFindFill.jl is a high-level and open-source implementation of an optimization-based gap finding and filling algorithm in Julia that overcomes those issues.", "description": "Metabolic reconstructions of different organisms from experimental evidence and bioinformatics based knowledge are widely used to facilitate the study of biological systems.  All of these reconstructions are inherently incomplete due to our lack of complete experimental and/or homology information.  A number of computational approaches have been proposed to detect gaps in a metabolic network and subsequently generate hypotheses to fix these gaps. The optimization based GapFind and GapFill approach proposed by Maranas and coworkers is one of the most widely used. \r\n \r\nThe previous implementation of GapFind and GapFill was in GAMS, which charges a significant amount of license fee from every single user, even though many solvers are free for an academic purpose.  To promote the usage of this computational model, we developed an open-source Julia package, GapFindFill.jl, which enables researchers to use this framework for free by harnessing the power of academic free solvers.\r\nBuilt upon Julia and its optimization language JuMP, GapFindFill.jl provides users interfaces to a well-established metabolic reconstruction curation model.  Benefited from the high-performance and general-purpose features of Julia, GapFindFill.jl allows users to embed network curation problems into other computational tasks, which the previous implementation in GAMS could not due to the limitation of GAMS itself.\r\nTo demonstrate the effectiveness of GapFindFill.jl, two examples from a published paper were used for validation. The package is a registered package and can be installed easily in Julia.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10191, "code": "TZ33RB", "public_name": "Peter Zhiping Zhang", "biography": "Ph.D. in Chemical & Biomolecular Engineering at Cornell University", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9926, "guid": "a6643a55-64a7-5c79-af16-eab966d0093a", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9926-feasible-nonlinear-optimization-with-lfp-sqp", "url": "https://pretalx.com/juliacon2021/talk/9PXXFE/", "title": "Feasible nonlinear optimization with LFP-SQP", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "We introduce a Julia package for nonlinear optimization that guarantees feasibility with respect to the imposed primal equality and inequality constraints at each step. The code is based on the theory of optimization on Riemannian manifolds and takes advantage of Julia's ability to perform fast numerical linear algebra and automatic differentiation (including mixed-mode automatic differentiation for Hessian-vector products).", "description": "Nonlinear optimization algorithms that only take feasible steps are sometimes desirable. For example, objective functions may not be defined outside of the domain determined by the constraints. Feasible steps also eliminate the need for specially constructed merit functions. Using theory established for optimization on Riemannian manifolds, we have developed a general high-performance numerical code for feasible sequential quadratic programming with smooth nonlinear equality and/or inequality constraints. Each step of the algorithm is dominated by an O(Nm^2)-flop factorization, where N is the number of variables and m is the number of constraints. Subroutines for retractions and fast truncated Newton steps that exploit automatic differentiation and Krylov subspace methods will be discussed.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10422, "code": "WYGWZR", "public_name": "Kevin Silmore", "biography": "I'm a PhD candidate in Chemical Engineering and Computation and DOE Computational Science Graduate Fellow at MIT.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9621, "guid": "b5ec05f8-c7fb-5151-b9cc-6a084222b82b", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9621-designbycontract-jl-enforcing-interfaces-between-functions", "url": "https://pretalx.com/juliacon2021/talk/UZXFSE/", "title": "DesignByContract.jl: Enforcing interfaces between functions", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "The Julia programming language has been evolving in many complex scientific fields. The rising adhesion of the language is a great opportunity to make Julia production-suitable. As an additional endeavor, I present a Design By Contract interface built entirely in Julia using its many features for Metaprogramming. My work takes the praised method of defining contracts to enforce interfacing between methods from Eiffel and hopes to extend it to different structures available in Julia.", "description": "Design By Contract is a method recommended in several Software Engineering best practices books such as the \"Pragmatic Programmer\" and \"Clean Code\". Design By Contract uses the paradigm of failing as fast and as often as possible to make sure we can detect the majority of bugs and unexpected behavior inside our code. This is done by ensuring the program in development will maintain state by executing a given set of assertions in every function, loop, or even data type, i.e. by making sure some conditions will always be true. Different from Unit Testing, Design by Contract will run all these assertions in runtime, reaching edge cases that are only found when using the program daily. It also makes the code cleaner and more literate by expressing the bounds of every structure, helping out when reading and unit testing it. Our implementation can disable the assertions for a more efficient runtime in production. Our Julian implementation of DBC uses macros and multiple dispatch, enabling for cohesive software development and review.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10230, "code": "V8B8TS", "public_name": "Guilherme Gomes Haetinger", "biography": "I am a Computer Science student at the *Universidade Federal do Rio Grande do Sul*. My interests hop around the fields of Operating Systems, Algorithm Design, Computer Graphics and Image Processing. Currently, I am working as a Back End Development intern at DeepX , using Elixir and Rust. I've been using Julia for a couple of years in order to get fast image processing results with easy-on-the-eyes code.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 11680, "guid": "e7b1686b-756a-5069-8634-3d829e79e60e", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-11680-parameter-identifiability-in-ordinary-differential-equations", "url": "https://pretalx.com/juliacon2021/talk/QCR9JA/", "title": "Parameter Identifiability in Ordinary Differential Equations", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Ordinary differential equations are a ubiquitous tool for modeling real-world phenomena. To ensure the best quality of a model, one tends to focus on the ability to discover model parameters from experiment. Property of structural parameter identifiability can help solving this problem. I will show examples of parameter identifiability types, talk about some existing solutions and their Julia Language implementations, and discuss what I am working on during this year's Summer of Code.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 12271, "code": "WGLCHQ", "public_name": "Ilia Ilmer", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 8924, "guid": "6a447fe2-d6a2-50ce-9d4e-8f5c53764dd5", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-8924-building-the-bestx-event-risk-model-using-hawkesprocesses-jl", "url": "https://pretalx.com/juliacon2021/talk/PLBXYX/", "title": "Building the BestX Event Risk Model using HawkesProcesses.jl", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "At BestX we provide analytics for traders to make better decisions in financial markets. We have built an event risk model that measures the level of distress in markets and predicts the probability of further distress. The model is built using a Hawkes process and this talk will demonstrate how we use my HawkesProcesses.jl package to fit, validate and interpret the parameters for these types of models.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 9239, "code": "BPSXJZ", "public_name": "Dean Markwick", "biography": "I am a quant for BestX and use Julia in my day to day work of assessing trading costs across different financial markets. Outside of my day job you'll find me writing on a variety of topics for my blog or tinkering away on different Julia packages.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9815, "guid": "24a6213b-da9b-5bb0-938b-1e357a46fe32", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9815-algorithmic-variants-of-nested-sampling", "url": "https://pretalx.com/juliacon2021/talk/SKNH7J/", "title": "Algorithmic Variants of Nested Sampling", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Nesting sampling is a methodology for computing the evidence (a high-dimensional integration of the likelihood over the prior density), and the posteriors simultaneously. Implementation in Julia of three algorithmic variants of nested sampling: Random Staggering, Slicing, and Random Slicing, are discussed in this work. Much of this work was inspired by the Python package, dynesty, and its modular approach to nested sampling which Julia\u2019s multiple dispatch made even more effective.", "description": "This work was done as a part of [Google Summer of Code 2020](https://gist.github.com/SaranjeetKaur/37086fea06076bd3ec76d052cc166378) with [The Turing Team](https://turing.ml/dev/team/\r\n) of [The Julia Language Organisation](https://julialang.org/\r\n). The code for this work is included in the Julia package [NestedSamplers.jl](https://github.com/TuringLang/NestedSamplers.jl) and is inspired from the Python package [dynesty](https://github.com/joshspeagle/dynesty). The slides for this presentation are available in this [GitHub repository](https://github.com/SaranjeetKaur/Juliacon2021_Slides_Virtual_Poster).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10410, "code": "MCGB3X", "public_name": "Saranjeet Kaur Bhogal", "biography": "I am currently pursuing MPhil in Statistics from University of Pune, India. I have worked as a Student Developer for Google Summer of Code 2020 with The Julia Language Organisation, during which I built the algorithmic variants of the nested sampling algorithm in Julia. I am also working with the R Contribution Working Group to develop a novice-friendly \"R Developer's Guide\".", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 8941, "guid": "df66f558-b750-5aae-b273-9e0432ccc56f", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-8941-three-mini-utilities-to-manage-computing-resources", "url": "https://pretalx.com/juliacon2021/talk/N3ANEL/", "title": "Three mini-utilities to manage computing resources", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Julia is quite greedy for computing resources: processor cores, physical memory and time. When using all three intensively, for example in Machine Learning, it is useful to be able to implement fine control. Watch core temperatures, memory availability and task completion as heavy computation proceeds calling on Linux utilities: free, watch, sensors and flite. Please see https://github.com/colbec/juliacon2021poster for working detail.", "description": "Machine learning can be quite demanding on computing resources. If users worry about processor core temperatures getting too high or not being aware when a long process finishes so that others may be started with new information, we can get the computer to take action. In particular while a computer may be able to use a swap drive when physical memory is fully utilized if this event happens it can take a long time to regain control of the machine. Better to run checks at appropriate moments to avoid problems rather than have them happen.\r\n\r\nLinux (and other OS as well I am sure) offer utilities that can help. In Flux we can bury a check for core temperatures and memory availability in the callback to the train!() function. And then at appropriate moments we can have the computer announce that a task has finished or that the exception side of a try block has been entered.\r\n\r\nUse Julia run() function to call on bash utilities free, watch sensors and use the sound system through flite to alert users to events. Talk to be backed up with github repository of examples.\r\n\r\nPlease see https://github.com/colbec/juliacon2021poster for working detail", "recording_license": "", "do_not_record": false, "persons": [{"id": 9264, "code": "CQ7UC3", "public_name": "Colin Beckingham", "biography": "Economist by training and horticulturist by experience. Erstwhile volunteer CTA for Andrew Ng's early Coursera courses in machine learning.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9674, "guid": "516f4d0f-7a11-581f-8f3e-1560facf83fc", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9674-gasmodels-jl-optimization-for-natural-gas-systems-in-julia", "url": "https://pretalx.com/juliacon2021/talk/ACVGEZ/", "title": "Gasmodels,jl: Optimization for Natural Gas Systems in Julia", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "We discuss GasModels.jl , a Julia package for Steady-State and Transient Gas Network Optimization. It is designed to enable computational evaluation of emerging gas network formulations and algorithms in a common platform. The code decouples problem specifications (e.g. gas flow, expansion planning, economic objectives, etc.) from network formulations. We discuss different formulations, computational performance, and how such models are used to address such problems.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10312, "code": "LJTGEG", "public_name": "Russell Bent", "biography": "Russell Bent (Ph.D.) is a scientist in the Applied Mathematics and Plasma Physics Group (T-\r\n5), where he leads LANL\u2019s inter-organizational Advanced Network Sciences Initiative (ANSI).\r\nANSI is an interdisciplinary initiative that enables fundamental and applied research to\r\naddress long-term challenges in critical infrastructure design, operation, and security. Dr.\r\nBent is the principal investigator for several DOE projects in critical infrastructure systems\r\nresearch and development that focus on improving robustness of infrastructure systems to\r\nextreme events, increasing resilience of distribution networks, modeling interdependencies\r\nbetween systems, managing disasters that impact critical infrastructure, modeling smart\r\ngrid technologies, and developing methods for mixed-integer, non-linear optimization. He is\r\nalso the lead developer for the software Alpine, A Global Solver for Nonconvex MINLPS and\r\nthe software GasModels.jl, a toolbox for modeling natural gas systems. He is the author of\r\none book, Online Stochastic Combinatorial Optimization, and over 100 peer reviewed\r\njournal and conference publications.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9544, "guid": "2b82b7ae-ecc1-5a76-a3c5-5c3540b4042e", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9544-distributed-quantum-circuit-simulation", "url": "https://pretalx.com/juliacon2021/talk/JFDMPR/", "title": "Distributed Quantum Circuit Simulation", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "In this talk we present a framework called [QuantEx](https://github.com/JuliaQX/QXSim.jl). This framework is designed to make it easy to perform simulations of quantum circuits on large distributed compute clusters. It users tensor network approaches and makes use of the excellent OMEinsum.jl, TensorOperations.jl and ITensors.jl packages along with MPI.jl to distribute the work across large numbers of distributed nodes.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 5629, "code": "33NEL3", "public_name": "Niall Moran", "biography": "Niall is a computational scientist at the Irish Centre for High End Computing where he works on a variety of projects covering quantum computation, AI and data analytics.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9578, "guid": "ffe435d5-6c6e-5af0-b4a1-07336382d016", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9578-surrogate-models-of-multiscale-dynamical-systems", "url": "https://pretalx.com/juliacon2021/talk/7BDGGA/", "title": "Surrogate Models of Multiscale Dynamical Systems", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "We present a general data-driven method, continuous time echo state networks, \r\nto produce surrogates of nonlinear multiscale systems, \r\nwhich can then be used to accelerate simulation, design, control and optimization. \r\nWe showcase the ability to handle highly stiff systems, which have been shown to \r\ncause failures in other common machine learning methods, and then showcase the ability to embed these surrogates in ModelingToolkit  for control, design and optimization.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 1148, "code": "AZXJH3", "public_name": "Ranjan Anantharaman", "biography": "I am a PhD Candidate at the Julia Lab at MIT. I've been working in Julia for the past 6 years.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9784, "guid": "1a284687-0600-5547-a8d4-1e2ef1abdd82", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9784-mitosisstochasticdiffeq-jl-filtering-guiding-for-sdes", "url": "https://pretalx.com/juliacon2021/talk/ZLXBVA/", "title": "MitosisStochasticDiffEq.jl - Filtering & Guiding for SDEs", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Stochastic differential equations (SDEs) arise naturally in many scientific and industrial disciplines, e.g., due to the interaction of a system with some environment. Inverse problems such as the inference of the model parameters of an SDE are of paramount importance. I describe the Backward Filtering Forward Guiding paradigm, capable of solving this task based on trajectories observed according to some observation scheme, suitable for neural SDEs, and scalable to high-dimensional systems.", "description": "In this virtual poster, I present the MitosisStochasticDiffEq.jl package (see https://github.com/mschauer/MitosisStochasticDiffEq.jl) for filtering and guiding of SDEs. Possible fields of application for these tools range from the control of the time evolution of the states of an SDE to the inference of the model parameters.\r\n\r\nMitosisStochasticDiffEq.jl implements the automatic Backward Filtering Forward Guiding (BFFG) paradigm [1,2] for programmable inference on latent states and model parameters in models described by stochastic differential equations. We start from a generative model that describes how the stochastic process evolves forward and how (potentially noisy and indirect) observations are generated from the process. In Backward Filtering Forward Guiding the information provided by those observations is backpropagated through the model to transform the generative (forward) model into a pre-conditional model guided by the data. This pre-conditioned SDE model approximates the actual (intractable) conditional model with known likelihood-ratio between the two.\r\n\r\nHaving this guided generative model at hand allows one to sample efficiently latent states and parameters conditional on observations. Since the BFFG paradigm can be formulated in terms of a set of transformation rules, it can be straightforwardly incorporated into a probabilistic programming context. The MitosisStochasticDiffEq package is based on the SciML ecosystem and thus it automatically integrates high-performing and specialized SDE solvers, sensitivity analysis tools, as well as distributed, multithreaded, and GPU parallel ensemble simulations. \r\n\r\nI demonstrate the workflow on the challenging study of parameter inference on a stochastic trait evolution model on a phylogenetic tree, which may be used to model the evolutionary relationships between biological species. \r\n\r\nCo-authors:\r\n\r\nFrank van der Meulen, Delft Institute of Applied Mathematics (DIAM), Delft University of Technology\r\nMoritz Schauer, Chalmers University of Technology and University of Gothenburg\r\n\r\n\r\n[1] Marcin Mider, Moritz Schauer, Frank van der Meulen (2020): Continuous-discrete smoothing of diffusions. arxiv:1712.03807.\r\n[2] Frank van der Meulen, Moritz Schauer (2020): Automatic Backward Filtering Forward Guiding for Markov processes and graphical models. arXiv:2010.03509.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10043, "code": "RFETFM", "public_name": "Frank Sch\u00e4fer", "biography": "PhD candidate in physics at the University of Basel.\r\nMember of the SciML open source software organization for scientific machine learning.\r\nGoogle Summer of Code 2020 student with the project: High weak order SDE solvers and their utility in neural SDEs. Google Summer of Code 2021 student with the project: Neural Hybrid Differential Equations and Adjoint Sensitivity Analysis.\r\n\r\nGithub & Slack: @frankschae", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9889, "guid": "4509e432-b385-5d44-b8ea-870f98099c32", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9889-gerrychain-jl-detecting-gerrymandering-with-markov-chains", "url": "https://pretalx.com/juliacon2021/talk/AGCHEV/", "title": "GerryChain.jl: detecting gerrymandering with Markov chains", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Markov chain-based sampling is an increasingly popular method for detecting gerrymandering of voting districts. GerryChain.jl implements optimized versions of the flip chain and the ReCom chain (DeFord, Duchin, Solomon 2019) for sampling large ensembles of districting plans that satisfy legal criteria. The package also provides a suite of tools for preprocessing geospatial data and computing statistics over ensembles of districting plans.", "description": "A districting plan is a partitioning of a geographical region, such as a city or a state, into connected pieces with approximately equal population. U.S. law requires that states redraw their districts every ten years, and district lines have a significant effect on voter representation. Gerrymandering is the practice of drawing districts that increase the power of one group of voters at the expense of others, typically along partisan or racial lines. Recently, a community of mathematicians, computer scientists, and policy experts have developed a suite of techniques for drawing districting plans and detecting gerrymandering. Ensemble analysis\u2014the sampling of many reasonable districting plans from a distribution, with the goal of establishing the range of typical outcomes\u2014is an increasingly popular method in this domain that has recently been used effectively by expert witnesses in high-profile voting rights lawsuits. In these analyses, a districting plan is represented as a weight-balanced _k_-partitioning of the dual graph of geographic units; these units might be counties, voting precincts, or U.S. Census blocks, depending on the granularity of the analysis.\r\n\r\nTo sample from a _known_ distribution of districting plans, it is useful to employ a Markov chain. Our research group maintains the popular Python package GerryChain (github.com/mggg/GerryChain), which implements a variety of Markov chains for redistricting and has been used in court cases and published academic research. However, this package\u2019s performance is severely limited for many types of chains, such as the recombination (ReCom) chain developed by DeFord et al. Recombination chains are attractive because they sample from a diverse set of reasonable plans by merging two contiguous districts at a time, drawing a random spanning tree, and cutting the tree into population-balanced halves. GerryChain.jl improves on the performance of the recombination chains implemented in the original GerryChain package by over an order of magnitude in a single-core setting, and the powerful worker pool-based parallelization features in Distributed.jl yield an additional 5x speedup. Through our continuing work on GerryChain.jl, we hope to advance the state of Julia\u2019s geospatial packages and popularize Julia in the computational public policy community. Our work is available at github.com/mggg/GerryChainJulia.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10423, "code": "PRBVXZ", "public_name": "Parker J. Rule", "biography": "I am a research associate and software engineer at Tufts University's MGGG Redistricting Lab, an interdisciplinary research group that applies mathematical techniques to the study of gerrymandering.", "answers": []}, {"id": 10475, "code": "8XQH7L", "public_name": "Bhushan Suwal", "biography": "I am a computational researcher at the Metric Geometry and Gerrymandering Group at Tufts University, where I develop open-source tools for redistricting research.", "answers": []}, {"id": 10482, "code": "LQVD7M", "public_name": "Matthew Sun", "biography": "Computer Science PhD student at Princeton University's Center for Information Technology Policy (CITP).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9898, "guid": "c94336a0-e0ac-5704-8026-8bf108cdea08", "logo": "/media/juliacon2021/submissions/BBDRQ3/Logo_Fermi_Prancheta_1_wjjVqGv.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9898-fermi-jl-a-modern-design-for-quantum-chemistry", "url": "https://pretalx.com/juliacon2021/talk/BBDRQ3/", "title": "Fermi.jl: A modern design for quantum chemistry", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Fermi.jl is a quantum chemistry package for computation of many-electron wave functions for molecules.  Many traditional packages written in C or Fortran exists, but the difficulty of inserting new implementations hinders the development of new methods. Fermi.jl is written completely in Julia and it is designed to be simple to read and maintain. Fermi.jl is aimed to serve as an efficient platform for methods development allowing the application of these on a wide variety of systems.", "description": "In 1929, the influential physicist Paul Dirac stated ``The underlying physical laws necessary for the mathematical theory of a large part of physics and the whole of chemistry are thus completely known, and the difficulty is only that the exact application of these laws leads to equations much too complicated to be soluble\". Nearly a century later, theoretical and computational chemists have developed a multitude of sophisticated methods to model the electronic structure of atoms and molecules. Paired with the advances in computational power, approximate solutions to the electronic Schr\\\"{o}dinger equation for many electron systems ($\\hat{H}\\Psi = E\\Psi$) are employed by scientists to solve important problems in chemistry, physics, biology and materials science. Implementation of these quantum chemistry methods are available in well known packages such as Psi4, Cfour, NWChem, and MRCC to name a few. Approximating molecular wave functions involves heavy numerical effort; therefore, codes are written completely or partially in efficient languages such as C, C++, and Fortran. While the contribution of these codes are invaluable to the field, the development of new methods is often hindered by the learning curve of the programming languages that they are built upon.\r\n\r\nIn order to accelerate the production of new implementations and ameliorate the maintenance of the code base, packages such as Psi4 and PySCF are written, as much as possible, in Python. This facilitates collaboration of computational chemists towards producing new programs and update existing ones. The emergence of Julia as a powerful tool in scientific computing motivated our development of the Fermi.jl package for quantum chemistry computations. Fermi.jl is written completely in Julia, with only external interfaces to resources written in other languages, such as libcint, a C library for molecular integrals evaluation. Currently, Fermi.jl can handle energy computations for a few important \\textit{ab initio} methods: Restricted Hartree--Fock (RHF), M\\o{}ller--Plesset perturbation theory (MP2) and Coupled Cluster theory up to perturbative triples [CCD, CCSD, and CCSD(T)]. The code design is based on readability, simplicity and extensibility, utilizing dynamic multiple dispatch for an elegant control flow. For example, MP2 computations can be done with single or double precision and with or without density fitting approximation for integrals. The main body of the code is the same for all combinations, with specific dispatches being called depending on the data type of the molecular integrals. The coupled cluster module leverages the capabilities of the TensorOperations.jl library, in particular allowing for automatic factorization of the tensor contractions. Each line of the code expresses a contraction that can be mapped to the corresponding mathematical term from the theory (often represented as diagrams). Unlike most electronic structure packages, Fermi.jl does not have an input file structure. It can be used interactively or one can write simple Julia scripts, both cases are facilitated by macros offering shortcuts for settings and routine calls. As Fermi.jl is improved and expanded, we hope to motivate computational chemists to consider Julia as modern alternative to traditional computing in electronic structure modeling.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10480, "code": "3DSWEY", "public_name": "Gustavo Aroeira", "biography": "PhD candidate in chemistry at the University of Georgia. Currently working at the Center for Computational Quantum Chemistry under supervision of Prof. Henry Schaefer. \r\nI am originally from Sao Paulo, Brazil where I got my degree in chemistry. Upon realizing that I was not talented enough for lab work, I found a new passion in programming. Today my main interests are the development of wave function methods and their application in chemical problems.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 8998, "guid": "fe7c4a16-e139-5567-8f75-1139cf45c85b", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-8998-jumping-into-the-julia-community-via-advent-of-code", "url": "https://pretalx.com/juliacon2021/talk/LNPMBP/", "title": "Jumping into the Julia Community via Advent Of Code", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "Learning a new language is a lot of fun when it comes with reindeer and peer support! Every December, thousands of developers take part in Advent of Code (AoC), a free, elf-themed series of 25 daily programming puzzles. These challenges ramp up in difficulty over the month, making it a great opportunity to try out Julia. The most valuable resource for learning and for developing confidence is the Julia AoC community on Twitter and Zulip, a welcoming space to explore the richness of the language.", "description": "Advent of Code (AoC) is a free, annual online programming event featuring daily puzzles every December 1st-25th. These two-part puzzles start with basic programming concepts, and ramp up in difficulty over the course of the month. Although there is a competitive aspect to solving each puzzle before the other 100,000 participants, people from all sorts of backgrounds join for all sorts of reasons.\r\n\r\nI wrote my first lines of Julia code to solve Day 1 of Advent of Code 2020. I shared my solutions on Twitter, and discovered the Julia community is quick to provide encouragement, and happy to give constructive feedback appropriate to your level of familiarity with the language! As the event continued, my favorite part of the day quickly became checking in to see how others in the Julia community solved that day's problem. On some days, I learned something new and was able to improve on my own approach. On other days, I discovered I'd tackled the challenge the same way as experienced Julia users, instilling me with confidence in my new-found abilities.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9297, "code": "FPS93N", "public_name": "Jasmine Hughes", "biography": "Jasmine is the Director of Data Science at InsightRX, a precision medicine company. She writes software and develops models to help pharmacists tailor medications to their patients. Jasmine received her PhD in Bioengineering from the University of California, Berkeley. Her thesis was about the interplay between growth factors and mechanical cues in the progression of brain cancer. She also teaches introductory programming workshops.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9732, "guid": "c85d1d45-f437-55bc-b17a-73db5605f0da", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9732-introducing-qxgraphdecompositions", "url": "https://pretalx.com/juliacon2021/talk/38TG38/", "title": "Introducing QXGraphDecompositions", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "QXGraphDecomposition is a Julia package for analysing graph structures describing a tensor network. Tensor networks provide efficient representations of data in high dimensional spaces with applications in areas ranging from quantum simulation to neural network compression. QXGraphDecompositions provides functions for solving graph theoretic problems which can be used to find an efficient method to contract a tensor network, a task which can easily become intractable if not done efficiently.", "description": "QXGraphDecompositions is a Julia package for analysing and manipulating graph structures describing a tensor network. In this talk we will introduce, at a high level, the problem of tensor network contraction as a motivating use case for QXGraphDecompositions. We will then demonstrate some of the main functions defined in QXGraphDecompositions by using it to find an efficient solution to such a problem and highlight the algorithms it uses in the process. Namely, we demonstrate a wrapper function for the flow cutter algorithm for finding a tree decomposition of a graph and an implementation of a greedy method for solving the treewidth deletion problem. While these methods have important applications in the field of tensor networks, QXGraphDecompositions has potential to be used in other fields. For example, tree decompositions are frequently used in graph theoretic computations and have been used to identify interesting structures in social networks.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10359, "code": "FRCXZB", "public_name": "John Brennan", "biography": "I am a theoretical physicist working at Irelands national supercomputing centre ICHEC.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9886, "guid": "7381132b-b52e-50ae-8ceb-acdcee29a71f", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9886-transpilers-jl-transpile-all-the-things", "url": "https://pretalx.com/juliacon2021/talk/Y3DRKK/", "title": "Transpilers.jl - Transpile all the things", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Have you ever wished some NumPy/jax/PyTorch/TensorFlow code was written in Julia instead? Have you ever translated ODEs written in Matlab to Julia by hand? Would you like to use sparse arrays or GPU computation in a legacy Stan model? Transpilers.jl is a common interface for translating numerical code into Julia. Currently it has backends for R and Python. Matlab and Stan backends are in development.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 4397, "code": "Z7JSAN", "public_name": "Kusti Skyt\u00e9n", "biography": "A Biostatistics PhD student from the University of Oslo. I'm working on combining computer simulations with Bayesian statistical models. I have been a big fan of Julia since version 0.4. My research interests are Bayesian statistics, symbolic computing and applied category theory.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9921, "guid": "124f5144-16d5-525e-b946-28c7f4653298", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9921-deploying-julia-on-a-brand-new-supercomputer-at-nersc", "url": "https://pretalx.com/juliacon2021/talk/QDHGNV/", "title": "Deploying Julia on a Brand New Supercomputer at NERSC", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "NERSC\u2019s new \u201cPerlmutter\u201d supercomputer was brought online in April 2021. We have identified a set of applications from our user community (eg. https://github.com/marius311/CMBLensing.jl). Of particular interest are applications that make use of multiple GPUs per node. We report the performance of these applications at scale. We hope that our findings will inspire more users to embrace Julia to develop extreme-scale simulation codes.", "description": "NERSC\u2019s new \u201cPerlmutter\u201d supercomputer (https://www.nersc.gov/systems/perlmutter/) was brought online in April 2021. The first phase consists of 1500 nodes with 1 AMD \u201cMilan\u201d CPU and 4 NVIDIA A100 GPUs each. In this talk we give an account of our experiences deploying Julia applications on Perlmutter. We manage a central installation of Julia 1.6.x (containing a minimal set of packages -- such as MPI and IJulia -- which require special configuration to run on Perlmutter). We have identified a set of applications from our user community (eg. https://github.com/marius311/CMBLensing.jl). Of particular interest are applications that make use of multiple GPUs per node. We report the performance of these applications at scale. We hope that our findings will inspire more users to embrace Julia to develop extreme-scale simulation codes.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10503, "code": "K9PVSE", "public_name": "Johannes Blaschke", "biography": "Johannes Blaschke is a computer systems engineer at the National Energy Research Scientific Computing Center (NERSC), where he is engaging with scientists to help them optimize their software for the next-generation supercomputers. His work focuses on enabling the real-time reconstruction of x-ray scattering data using extreme-scale computing environments. Johannes received his PhD in Theoretical Physics from the University of Goettingen, while researching statistical mechanics problems at the Max Planck Institute for Dynamics and Self-Organization. After his PhD, Johannes developed fluid-structure interaction codes for fluctuating hydrodynamics simulations of multi-phase and active matter simulations at the Technical University of Berlin and the Center for Computational Sciences and Engineering at Lawrence Berkeley National Laboratory. In 2019 Johannes joined the Data Science Engagement Group at NERSC.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9845, "guid": "2564fa15-17f3-51dd-8ec8-fd2805125f0f", "logo": "/media/juliacon2021/submissions/ZTDMHC/thumbnail_C15UWGi.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9845-probabilistic-numerics-for-differential-equations", "url": "https://pretalx.com/juliacon2021/talk/ZTDMHC/", "title": "Probabilistic Numerics for Differential Equations", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "The field of Probabilistic Numerics aims to quantify numerical uncertainty arising from finite computational resources. By treating the solution of an ordinary differential equation (ODE) as a problem of Bayesian inference, probabilistic numerical ODE solvers return a posterior probability distribution over ODE solutions. This poster presents ProbNumDiffEq.jl, a package for probabilistic numerical solvers for ODEs, built on OrdinaryDiffEq.jl.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10432, "code": "NHKMML", "public_name": "Nathanael Bosch", "biography": "I'm a PhD student at University of T\u00fcbingen, working on probabilistic numerics, machine learning, and Bayesian inference.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9712, "guid": "b4a8841f-4145-532a-a97d-86b4e51eaaab", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9712-indexfunarrays-jl-fun-with-indices-and-functions-on-them-", "url": "https://pretalx.com/juliacon2021/talk/XWXEH3/", "title": "IndexFunArrays.jl | Fun with indices (and functions on them)", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "[IndexFunArrays.jl](https://github.com/bionanoimaging/IndexFunArrays.jl) provides a convenient way to work with index dependent functions. \r\nIn signal processing it often occurs that an array needs to processed (e.g. applying a window functions) depending on the indices. One could write for loops processing the data in-place. However, a different technique is to create arrays which do not allocate memory but instead generate the desired value when accessed.", "description": "The creation of an `IndexFunArray` in principle only needs two parameters: size and an index operating function.\r\nThe index function operates on the index of an element and could for example create a window function. Size specifies the size of the output array. The resulting `IndexFunArray` subtypes `AbstractArray` and behaves almost like a normal array but apart from storing the size and the function there is no size dependent memory allocation needed. All values are calculated once they are accessed.\r\nIn our packages we already provide several window functions and other index related functions like `rr2` measuring the squared distance to a reference pixel and many more.\r\nSince `IndexFunArray` subtypes `AbstractArray` it usually can be incorporated to other packages easily.\r\nWe also provide several other keyword arguments to specify options like scaling.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9921, "code": "U3YH9P", "public_name": "Felix Wechsler", "biography": "[Felix Wechsler](https://felixwechsler.science) studied Physics and Informatics at the Technical University of Munich in Germany. For his master studies in Photonics he moved to Jena (city of light). Currently he finishes his master thesis in the field of computational microscopy at the [Biomedical Imaging Group of Leibniz Institute of Photonic Technology](https://nanoimaging.de/) under the joint supervision of Rainer Heintzmann and Ivo Ihrke.", "answers": []}, {"id": 11263, "code": "KTPRLZ", "public_name": "Rainer Heintzmann", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9671, "guid": "d3350293-e5cd-5a72-97c0-8f50d0d864e8", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9671-makie-showcases-and-future", "url": "https://pretalx.com/juliacon2021/talk/FLQBDG/", "title": "Makie showcases and future", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "This talk will show off some noteworthy examples demonstrating Makie's capabilities for publications, interactive visualizations in the web and desktop apps using OpenGL.\r\nThe talk will also outline, what one can expect from Makie in the future and how we plan to make dependency less Recipes work.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 966, "code": "JSJDXE", "public_name": "Simon Danisch", "biography": "Simon Danisch is a senior developer at Beacon-Biosignals. Simon has been part of the Julia community for more than 8 years and has contributed many Julia packages:\r\n\r\n* [GeometryBasics](https://github.com/JuliaGeometry/GeometryBasics.jl)\r\n* [GPUArrays](https://github.com/JuliaGPU/GPUArrays.jl)\r\n* [Makie](https://github.com/JuliaPlots/Makie.jl/)\r\n* [PackageCompiler](https://github.com/JuliaLang/PackageCompiler.jl/)\r\n* [JSServe](https://github.com/SimonDanisch/JSServe.jl)\r\n* [FileIO](https://github.com/JuliaIO/FileIO.jl)", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9529, "guid": "83494ce0-93d1-5973-abaa-e0306209859f", "logo": "/media/juliacon2021/submissions/L9EAPP/BellScenario_jl_logo_mAc0gpH.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9529-bellscenario-jl-computing-quantum-nonlocalty", "url": "https://pretalx.com/juliacon2021/talk/L9EAPP/", "title": "BellScenario.jl - Computing Quantum Nonlocalty", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Quantum nonlocality is a puzzling phenomenon of the physical world that has technological advantages in distributed information processing and security. BellScenario.jl is an open-source package designed to help understand nonlocality and its advantages. It combines Polyhedra.jl and Convex.jl with state of the art polyhedral decomposition and optimization techniques. This poster will cover how Julia is leveraged to solve the computational problems behind nonlocality.", "description": "Quantum nonlocality is one of the most puzzling phenomena of the physical world.  Physicists such as Albert Einstein were deeply unsettled by the quantum mechanical prediction that distant regions of spacetime can be correlated beyond what is physically allowed by causality and determinism. In recent years, the existence of quantum nonlocality has been proven beyond reasonable doubt, and a myriad of technological advantages in information security and distributed computation result from this fascinating physical phenomenon.\r\n\r\nTo help understand quantum nonlocality and harness its technological advantages, I\u2019ve developed the BellScenario.jl package. This open-source Julia package computes the bounds of classical physics, and more importantly, establishes the quantum parameters at which nonlocality arises. The computational task at hand is daunting, however, the Julia ecosystem facilitates the  amalgamation of disparate computational tools allowing meaningful results to be procured. More specifically, BellScenario.jl  brings together the polyhedral computations of Polyhedra.jl, the convex optimization of Convex.jl and JuMP.jl,  and state of the art techniques for polyhedral decomposition  and quantum  optimization. A possibility which is easily realized within the Julia ecosystem.\r\n\r\nIn this talk, I will cover the basics of quantum nonlocality, its applications, and the computational problems involved. Then, I will present how I leverage the Julia ecosystem to make this quantum nonlocality research tangible, transparent,  and reproducible. In a broader scope, BellScenario.jl serves as an essential component of a rapidly developing ecosystem of Julia tools geared towards quantum information. This  talk will be of interest to the growing number of quantum information researchers, and its foundational concepts will entertain any scientific thinker with an ear towards quantum quandaries and their philosophical implications.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10120, "code": "K3WUDL", "public_name": "Brian Doolittle", "biography": "Brian Doolittle (They/Them) is 3rd year physics PhD student at the University of Illinois Urbana-Champaign where they research nonlocality in quantum networks. Before graduate school Brian worked as a  software engineer at AthenaHealth developing clinical decision support systems and open standards for healthcare interoperability.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9492, "guid": "d9d08bb8-e0a4-5440-a0f0-117af99de6b6", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9492-ros-jl-beta-release-the-c-robot-operating-system-wrapper", "url": "https://pretalx.com/juliacon2021/talk/MVZKVK/", "title": "ROS.jl beta release: The C++ Robot Operating System wrapper", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "ROS.jl is a full-featured wrapper of the Robot Operating System C++ client. It was recently released in a non-stable (beta) state. The beta offers all C++ client features (and simplifies on them), but not the required stability due to lack of tests in real-life robot scenarios. This talk includes a brief introduction to the Robot Operating System and its advantages, addresses all features included in the current ROS.jl release and finally invites the Julia community to use and test the package.", "description": "", "recording_license": "", "do_not_record": true, "persons": [{"id": 10065, "code": "YDL7VL", "public_name": "George Stavrinos", "biography": "www.github.com/gstavrinos", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9667, "guid": "37657396-cc57-5d1b-92af-6d2a2882d51d", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9667-learning-during-the-pandemic", "url": "https://pretalx.com/juliacon2021/talk/KTDNM8/", "title": "Learning during the pandemic", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "Learning Julia takes time. Unfortunately, as a high schooler balancing school and extracurriculars, time is a hard resource to find. Combining learning Julia and chemistry/calculus with Pluto notebooks works around that constraint. At first, the programs were basic but as time passed, the notebooks became more advanced through packages like Catalyst.jl and DifferentialEquations.jl. The next step is to learn more specifics about these packages as I learn more chemistry/calculus.", "description": "This talk will discuss the various tools used to build the notebooks and why the notebooks helped with comprehension and retention.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9454, "code": "EVDMDJ", "public_name": "Krithika Natarajan", "biography": "I am a 16 year old student at Wilton High School in Wilton, CT. Currently, I am self-teaching myself Julia and I am also learning Java in my AP Computer Science Class in school.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9779, "guid": "4ea09130-ad15-5b2e-8c58-762d2c37539c", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9779-learn-about-blockchain-development-in-julia", "url": "https://pretalx.com/juliacon2021/talk/AEP3PA/", "title": "Learn about Blockchain Development in Julia", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Most people have heard about how Blockchain is going to \"change the world\" and such, but what does that really mean? This talk aims to shed light on this via carefully constructed learning materials built to showcase the concepts of the blockchain using Julia.", "description": "Ever wondered what Blockchain is or how to use it? This Virtual Poster will share some of the resources available to Julia developers who want to learn about blockchain development. Most if not all of the resources shared have been intentionally built for the Julia community in order to help accelerate the learning and participation in this rapidly growing field.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1032, "code": "UNR7XZ", "public_name": "Logan Kilpatrick", "biography": "Logan is the Community Manager for the Julia Language. Get in contact with him here: https://twitter.com/OfficialLoganK", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9701, "guid": "7bba4dfa-3f4b-5dd3-bfd9-a65ad4f1993e", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9701-modeling-species-co-occurrence-with-turing-jl", "url": "https://pretalx.com/juliacon2021/talk/STAZ9L/", "title": "Modeling species co-occurrence with Turing.jl", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Modeling the co-occurrence of multiple species is a commonly used tool in biodiversity conservation. We present a Julia-based version of an existing multispecies occupancy model. Benchmark results show a substantial reduction in running time when fitting the co-occurrence of four carnivore species using Turing.jl compared with the one yielded by Stan. We encourage ecologists to use Julia for probabilistic models in order to improve the scalability of ecological science.", "description": "Predicting species occurrence is fundamental to biodiversity conservation and local policy-making. Multispecies occupancy models inform us about what species co-occur in a region and what factors make that region suitable for them. [Rota et al (2016)](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12587) proposed a generalization of the single-species occupancy model ([MacKenzie et al 2002](https://esajournals.onlinelibrary.wiley.com/doi/10.1890/0012-9658%282002%29083%5B2248%3AESORWD%5D2.0.CO%3B2)) by assuming the latent occupancy state is a multivariate Bernoulli variable that is linked to an observed detection process. We compare the performance of Rota et al\u2019s model fitted in **Stan** probabilistic language via the **RStan** interface with an equivalent model in **Turing.jl**. While both approaches resulted in similar parameter estimates, we found that Turing.jl required lower running times depending on model specification. We show that Turing\u2019s performance was two hours faster than the one yielded by Stan, and the number of code lines was reduced from ~200 to ~100. Further code optimization by vectorizing observations from the multivariate Bernoulli distribution may reduce even more computation time. \r\nThere is an increasing number of ecologists interested in using the Julia language for implementing probabilistic modeling in their research. Providing them with programming resources that reduce computation time in their day-to-day modeling routines has become a major challenge in the big data era. Here, we report **benchmark** results that demonstrate the efficiency of the Julia language in terms of computation time when fitting complex occupancy models to a large data set. We encourage ecologists to use Julia for probabilistic models in order to improve the scalability of ecological science.\r\n\r\n**Authors**:\r\nJuan M Requena-Mullor. University of Michigan\r\nAndrii Zaiats. Boise State University\r\nCristina Barber Alvarez-Buylla. Boise State University", "recording_license": "", "do_not_record": false, "persons": [{"id": 10172, "code": "QQ7JQE", "public_name": "Juan M Requena-Mullor", "biography": "I am a quantitative ecologist currently working as a postdoctoral research fellow at the University of Michigan. My research is focused on using quantitative methods and scientific programming to move forward in our understanding of how species, ecological, and ecosystem processes are affected by Global Change. I am particularly interested in encouraging the use of Julia language for ecological research and to this end, I am developing programming resources for ecologists. Some examples can be found at my GitHub repository (https://github.com/jmrmcode).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9422, "guid": "d09329bf-5f4d-5778-8c32-0112249419e8", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9422-faster-scripts-in-julia-with-daemonmode-jl", "url": "https://pretalx.com/juliacon2021/talk/KJNRGA/", "title": "Faster scripts in Julia with DaemonMode.jl", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "One of the main perceved", "description": "One of the disadvantages most perceived by new users, and much talked about is the initial time required for running a program in Julia, mainly due to the compilation phase, that is called well-known time-to-first-plot. While it is true that developers are well-awake of that problem, and it is being reduced in new versions of Julia, it is huge problem when it is wanted to use Julia as a language to program, small programs, scripts, specially when these scripts need to load packages (like CSV or DataFrames, very common in data science scripts).\r\n\r\nIn order to tackle that problem, I developed the DaemonMode.jl, that allows users to run all scripts sending them in a specific process to be run by it. Because the same process run all Julia scripts, the packages compiling is only done the first time any script load it, being able to run very quickly the scripts, even when these scripts are changed.\r\n\r\nThe package is available at the General Register, or https://github.com/dmolina/DaemonMode.jl, with more than 85 starts.\r\n\r\nThe aim of that talk is to show the possibilities of the packages, showing the reduction in time with different scripts. I will talk about new features of last versions: better error stack, managing logs, return error code if any problem is detected, .... Even more, because the communication between the client and the server is done through sockets, I have developed a small client in binary to avoid even the initial time for loading the interpreter. Using the binary client, even the more simple scripts are faster. Also, I will talk about future changes, mainly oriented to allow remote scripts, and to receive feedback of users.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4442, "code": "LM37DY", "public_name": "Daniel Molina", "biography": "I am associate professor at the University of Granada, in Computer Science, with experience in Artificial Intelligence, in particular in Intelligence Optimization and in Machine Learning. In my daily life I am a  believer of free software (use daily Emacs, Linux, ...). I have been for years a great Python fan, and more recently fan of Julia, in which I have created several small  but useful packages.  [personal website](https://dmolina.github.io/).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9789, "guid": "87ccc050-4ebe-5524-82de-ef16550bb513", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9789-fast-simulation-based-power-analyses-for-mixed-effects-models", "url": "https://pretalx.com/juliacon2021/talk/7CQYQB/", "title": "Fast Simulation-Based Power Analyses for Mixed-Effects Models", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Simulation is the gold standard for power analysis of mixed-effects models. Traditionally, realistic simulations have been both hard to set up and computationally intractable. Here we present a Julia-based workflow for fast and easy power analysis of mixed-effects models. With MixedModelsSim.jl, we can easily simulate realistic datasets, which we can then quickly analyze with MixedModels.jl. Combined with Pluto.jl, users can explore the impact on power of design decisions interactively.", "description": "For this demonstration, we will use MIxedModelsSim.jl to quickly simulate a dataset from scratch, including both fixed and random effects, then use that simulated data to perform a power analysis. We will show how the speed in Julia enables rapid exploration of the experimental design space -- for example whether it's better to include more items or more subjects in a repeated-measures design.  We will briefly touch upon a few advanced topics, such as\r\n- how singular model fits can arise and what this means for power analysis (e.g., what happens when a random effect goes to zero in practice even when that component is known not to be zero in theory)\r\n- the impact of correlation in the random effects and how that influences statistical power, as well as the impact of tools such as forcing the estimated correlations to be zero (with `zerocorr`)\r\n- how to extend these approaches to generalized linear mixed models for e.g. logistic regression", "recording_license": "", "do_not_record": false, "persons": [{"id": 3828, "code": "3EFERC", "public_name": "Phillip Alday", "biography": "Phillip was a struggling mathematician, then a linguist and now a neuroscientist, but always a hacker.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9837, "guid": "e0d559c9-c4fb-58b4-8c13-32ddb83f4d91", "logo": "/media/juliacon2021/submissions/TJ3J79/bioreactor_constraints_x2_result_L590mP1.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9837-constrained-control-with-neural-feedback-policies-in-diffeqflux", "url": "https://pretalx.com/juliacon2021/talk/TJ3J79/", "title": "Constrained Control with Neural Feedback Policies in DiffEqFlux", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "We explore the neural ODE approach to solve nonlinear optimal feedback control problems with constraints using DiffEqFlux.\r\nThe original controls of the problem definition are substituted by the output of a neural network feedback policy whose parameters become the new control variables.\r\nConstraint satisfaction is enforced on the states with barrier methods, while constraints in controls are enforced by saturation from the last activation of the neural controller.", "description": "We explore the differentiable control approach implemented in DiffEqFlux for solving general constrained nonlinear optimal control problems with neural network controllers.\r\nThe original control variables of the problem are substituted for the output of an embedded neural controller, turning the weights of the neural network the time-independent optimization variables.\r\nThe controller is of closed-loop form, being only a function of time through its feedback dependence on state at each timepoint.\r\nLeveraging DiffEqFlux, adjoint sensitivity analysis is used to estimate the gradient of the Bolza-type optimal control problem with respect to the parametrization of the neural network and first order optimization methods are then used to iteratively approximate an optimal solution.\r\nWe emphasize the relation of this problem setting with the origins of the backpropagation algorithm through the Kelley-Bryson gradient procedure and with control vector iteration as its continuum time counterpart in the numerical optimal control literature.\r\nThe capabilities of the technique to handle state constraints are explored through relaxed logarithmic barrier functions that act as a running penalty functional, while the control constraints are naturally enforced through saturation from the final activation function of the neural network policy.\r\nThe effectiveness of the technique is showcased with nonlinear control problems in bioprocesses, including setpoint tracking objectives and economic running costs.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10426, "code": "XMHEGM", "public_name": "Ilya Orson Sandoval", "biography": "I am a PhD student in Imperial College working at the intersection of reinforcement learning, optimal control and process systems engineering. Previously, I worked in data science and software engineering within the energy and food industries in Mexico. I have a background in physics.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9570, "guid": "c652c959-7123-5e5e-91d6-f720dae2c327", "logo": "/media/juliacon2021/submissions/D8E9HH/HssMatrices_aR2yjeJ.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9570-hssmatrices-jl", "url": "https://pretalx.com/juliacon2021/talk/D8E9HH/", "title": "HssMatrices.jl", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Hierarchically semi-separable (HSS) matrices are a type of structured matrix that arise in a range of scientific computing and engineering problems. Most notably, they have been used to develop novel direct and approximate high-performance solvers for linear systems. HssMatrices.jl provides HSS compression algorithms, arithmetic and visualisation tools. This allows Julia users to easily experiment with HSS matrices and corresponding algorithms.", "description": "I am planning to shortly introduce HssMatrices.jl and it's functions. Moreover, I will speak about the lessons learned from the implementation. You can find the package here:\r\nhttps://github.com/bonevbs/HssMatrices.jl", "recording_license": "", "do_not_record": false, "persons": [{"id": 10164, "code": "HJ78M8", "public_name": "Boris Bonev", "biography": "I am a PhD student in applied mathematics with Prof. Jan S. Hesthaven at EPFL. I am interested in novel computational methods for problems arising in engineering and scientific computing. I have been working in the field of Computational Linear Algebra to help develop new methods for solving linear systems. Coming from Matlab, Julia has taught me that fast code and readable code are not mutually exclusive.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9772, "guid": "33100675-78fe-5a4f-8b66-5de6392a1f66", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9772-speeding-up-cosmological-data-analysis-with-julia", "url": "https://pretalx.com/juliacon2021/talk/8ATSN3/", "title": "Speeding up cosmological data analysis with Julia", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "In the next few years, upcoming cosmological survey are going to produce a large amount of data. In order to extract as much information as possible, we need adequate software tools to analyze data. I translated my Python3 code, that I use to predict cosmological observable, in Julia. After a month of work, with no previous Julia exposure, I obtained a speed up of about 20. Now I am looking further to extend my Julia code and to apply extensively it in my research.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10300, "code": "PPMTQ9", "public_name": "Marco Bonici", "biography": "I am a PhD Student at Universit\u00e0 degli Studi di Genova. I am a memeber of the Euclid Consortium. Euclid is a space-based mission which will map the galaxy distribution in order to study the nature and origin of Dark Energy and Dark Matter. In the consortium, I am active in the developement of tools used to analyze data and perform cosmological analysis.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9896, "guid": "7a542328-871f-5cc7-93cc-c1dadedf1600", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9896-to-the-moon-and-beyond-with-julia", "url": "https://pretalx.com/juliacon2021/talk/GLTEMP/", "title": "To the Moon and Beyond with Julia", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Commercial space is taking off and new programs developed by the space agencies such as NASA's Commercial Lunar Payload Services (CLPS) are encouraging private companies to venture beyond Low Earth Orbit. Telespazio Germany aims to support NewSpace companies taking to the skies by providing the necessary infrastructure on the ground. We believe that Julia could play an instrumental part in this and we want to show what we have been working on and what we have planned for the future!", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10348, "code": "KDTCJJ", "public_name": "Helge Eichhorn", "biography": "I am a mechanical engineer working on ground systems software in the European space industry.\r\n\r\nWorking on reimagining space exploration with Open Source at [JuliaAstro](https://github.com/JuliaAstro), [JuliaSpace](https://github.com/JuliaSpace), and [OpenAstrodynamics](https://github.com/openastrodynamics).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9751, "guid": "8eec6445-91c6-526c-be2f-48e52b34a497", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9751-parameterhandling-jl", "url": "https://pretalx.com/juliacon2021/talk/3BFJZ7/", "title": "ParameterHandling.jl", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Any time you want to fit a model you have to figure out how to manage its parameters, and how to work with standard optimisation and inference interfaces.\r\nThis becomes complicated for all but the most trivial models.\r\n[ParameterHandling.jl](https://github.com/invenia/ParameterHandling.jl/) provides an API and tooling to help you manage this complexity in a scalable way.\r\nWe'll show how you might use ParameterHandling.jl, how to extend it, and how it relates to other tools.", "description": "Models with tunable parameters are ubiquitous throughout mathematical modelling -- they are essentially the name-of-the-game in statistics, machine learning, and many other areas.\r\nThere are many model-agnostic learning and approximate inference algorithms for finding said parameters, such as various flavours of gradient ascent and Hamiltonian Monte Carlo, etc. Indeed, the development of such algorithms is the core goal of multiple fields.\r\nSeparately, many modelling frameworks have been developed that allow users to easily specify models (Flux.jl, Turing.jl, Tensorflow, PyTorch, JAX, etc), which are agnostic to the learning algorithm that is ultimately used.\r\n\r\nUnfortunately, this very pleasant separation-of-concerns story gets messy when we look at how these two classes of software interact with one another.\r\nLearning algorithm software typically wants to receive a \"flat\" vector of real-valued parameters (e.g. Optim.jl, AdvancedHMC.jl) from a model, while most modelling frameworks naturally represent a model in terms of a structured collection of parameters, often spread out through a large data structure of some kind.\r\nThe traditional solution has been to either adapt the learning algorithms to make them aware of the modelling software (e.g. Flux.jl), or implement custom functionality to generate flat representations of parameters from structured objects (e.g. Turing.jl).\r\n\r\nThis is where [ParameterHandling.jl](https://github.com/invenia/ParameterHandling.jl/) comes in.\r\nIt is a general framework designed to bridge the gap between these two worlds.\r\nAt its core is functionality which algorithmically generates mappings between structured and flat representations.\r\nThis functionality can be extended by users or package maintainers to handle new types, and it comes equipped with escape hatches to make working with existing modelling packages doable, without needing to modify said packages.\r\n\r\nIn this talk, we will\r\n1. show how to use ParameterHandling.jl as a user,\r\n2. show how you could extend it to handle a new type as a modelling package maintainer,\r\n3. show how you might make use of ParameterHandling.jl as a learning algorithm maintainer,\r\n4. discuss its current limitations, and how these related to other solutions available in the Julia ecosystem.", "recording_license": "", "do_not_record": false, "persons": [{"id": 1051, "code": "LQKANJ", "public_name": "Will Tebbutt", "biography": "I'm a PhD student in the Machine Learning group in Cambridge.\r\nI primarily work on Gaussian processes -- how to scale them to large data sets, how to use them in climate science, and how best to write software that implements them.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9731, "guid": "a8554edc-fff8-5087-9eb5-b052cd7248f6", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9731-standardize-your-predictors-with-standardizedpredictors-jl", "url": "https://pretalx.com/juliacon2021/talk/YJACBJ/", "title": "Standardize your predictors with StandardizedPredictors.jl", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Before fitting statistical or machine learning models, it's common to\r\nstandardize predictor variables to eliminate fixed offsets and differences in\r\nscale.  While these procedures are often easy to implement manually, they can\r\nintroduce subtle bugs and add bookkeeping overhead.  StandardizedPredctors.jl\r\nbuilds on StatsModels.jl to provide tools to conveniently and reproducibly\r\nstandardize numeric predictors.", "description": "Data comes in many and diverse forms, and often it needs to be\r\ntransformed before modeling. Even when your data consists of continuous\r\nquantities represented in numerical form, differences in the scale,\r\noffset, and other properties can present challenges to model\r\nconstruction, fitting, and interpretation. Standardization\u2014by centering,\r\nscaling, z-scoring, etc.\u2014is a common step in pre-processing data to\r\nprepare for modeling. While these procedures are often simple and easy\r\nto implement manually, they add bookkeeping overhead and can introduce\r\nerrors (especially when making predictions based on new data).\r\nStandardizedPredictors.jl builds on the StatsModels.jl ecosystem to\r\nprovide safe and convenient representations of various standardization\r\nschemes in the form of `AbstractTerm`s. These terms automatically compute\r\nstandardization parameters before fitting, support manual override,\r\nlazily apply standardization procedures to the data, do the necessary\r\nbookkeeping to reproducibly generate correct predictors from held-out\r\ndata, and generate a \u201cpaper trail\u201d in the coefficient tables of fitted\r\nmodels. This makes it easier and more convenient to standardize data in\r\na reproducible way and takes away a major footgun in a common data\r\npreprocessing step.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4393, "code": "SLNRF8", "public_name": "Dave Kleinschmidt", "biography": "Research scientist at [Beacon Biosignals](https://beacon.bio/)", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9661, "guid": "ce2f7165-19c7-5714-86a9-61629f56335e", "logo": "/media/juliacon2021/submissions/ZHJ9SD/Talk-01_2zb3sqL.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9661-awesome-computer-vision-done-quick", "url": "https://pretalx.com/juliacon2021/talk/ZHJ9SD/", "title": "Awesome Computer Vision Done Quick", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "AI researcher Bishmer Sekaran demonstrates how Julia is:\r\n\r\n* easy \r\n* fast\r\n* powerful \r\n\r\n when performing sophisticated Computer Vision image classification tasks using the [SSDMNV2](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7775036/) masked/unmasked image dataset.", "description": "A whirlwind tour of the concepts behind Convolutional Neural Networks in Deep Learning, their implementation in Flux.ml, and some significant real-world applications to benefit public health.\r\n\r\nAll code will be made available on Codeberg (or GitHub if the organizers prefer) under the same free MIT license which Julia itself is distributed under.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10281, "code": "X3PWGN", "public_name": "Bishmer Sekaran", "biography": "Bishmer Sekaran is an Artificial Intelligence researcher based in Singapore. He first discovered Julia in 2020 and has been a vocal proponent ever since.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9944, "guid": "7ca81954-165e-50dc-9ab2-60f918d4103e", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9944-theory-is-nearly-implementation-with-julia-types", "url": "https://pretalx.com/juliacon2021/talk/CQ9F37/", "title": "Theory is (nearly) implementation with julia types", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "Data paradigms are metaphors we think with.\r\nThis talk describes how julia re-united a psychometrician's probability theoretical and technical thinking in \"data\".\r\n\r\nI have thought in terms of\r\nboxes, registers and memory adresses,\r\nvalue bundles with C structures and Pascal records,\r\nobjects with inheritance in C++ and java,\r\nvectors and data frames in R.\r\nAll useful but oblique.\r\n\r\nFinally julia types liberated from tediously translating theory to implemetation.\r\nMore clarity, less mistakes.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 4398, "code": "ABRWNH", "public_name": "Gregor Kappler", "biography": "Gregor Kappler carries out psychometric research and data science consulting, and is founder of FilingForest, a julia-focused startup developing solutions for fast unbiased measurement in graph data.\r\n\r\nGregor was initially trained as a mathematician and psychologist, has implemented solutions for semantic text analytics for his PhD in 2007, and developed psychometric models for measuring with texts.\r\nHe has worked as a lecturer and researcher at the University of Vienna and the University of Jena and worked on a series of predictive analytic projects for software vendors and customers.\r\n\r\nGregor has switched to Julia from R in 2018, and is creator of the CombinedParsers package which provides parser combinators for fast, recursive and type-save parsing in pure Julia.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9788, "guid": "49eeff64-74df-56c1-8536-ac4ef575e78e", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9788-composablecommunities-jl-evolving-julia-package-communities", "url": "https://pretalx.com/juliacon2021/talk/ZUPX83/", "title": "ComposableCommunities.jl: Evolving Julia package communities", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Open source software communities depend on diverse groups of maintainers, contributors, and users working together to develop tools. In this talk, I introduce the idea of a ComposableCommunities dataset, discuss key incentives issues in further developing the package community.", "description": "While the bus factor may be one of the most popular (and organizationally political) metrics in open source software development, it is only a partial view of package community health, and often interpreted without regard to community anti-patterns like gatekeeping. Julia is unique in the extent of its use of GitHub as the user interface and \u2018operating system\u2019 for Julia package development. Good package infrastructure alone, however, does not guarantee healthy communities. Julia\u2019s package infrastructure and particularly its use of git and GitHub, mean that data about the package development process and package (as well as maintainer) dependency structures is available in unusual quality and granularity. I propose a new piece of \u2018community infrastructure\u2019 with which the Julia community can introspect, defined shared metrics and goals, and via which the economics of open source, in particular incentive misalignments like topic squatting, contributor churn, and zombie packages might be explored quantitatively.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10197, "code": "MHJGHB", "public_name": "Jeremiah Lewis", "biography": "Over the course of six years in data I\u2019ve optimized digital marketing, applied machine learning to the contemporary art world, and contributed to the digitization of the automobile industry. I am currently a Master\u2019s student in Economics at the Humboldt University in Berlin.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9722, "guid": "780e2b9a-959b-5fff-bb19-5d333912ead6", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9722-multiplying-monochrome-images-as-matrices-a-b-and-softmax", "url": "https://pretalx.com/juliacon2021/talk/BXEZAQ/", "title": "Multiplying monochrome images as matrices: A*B and softmax", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "We can interpret monochrome images as matrices KxM and MxN and combine them via matrix multiplication. It turns out that results are often visually interesting, especially if we normalize rows of the left-hand-side matrix and columns of the right-hand-side matrix with softmax before taking the product.", "description": "It would be great to understand the properties of matrix multiplication better. This seems to be particularly worthwhile because matrix multiplication plays a prominent role in Transformers, a class of machine learning models invented in 2017 and responsible for many recent breakthroughs including GPT-3. Sometimes, the rows of the left-hand-side matrix are softmax-normalized in order to use them as probabilities.\r\n\r\nOne can interpret a monochrome image as a matrix (the size of the matrix depends on the resolution of the image in question, so one should rescale the image in question as desired). I decided to explore whether matrix products of monochrome images are visually interesting. I used JuliaImages packages, Julia LinearAlgebra facilities and Julia Jupyter notebooks.\r\n\r\nI looked at standard Julia test images, such as \"mandrill\" and \"jetplane\", and discovered that there is plenty of visually interesting information in their matrix products. I used the scaling of pixel values which is also used by ImageView.imshow() methods.\r\n\r\nIt turned out that the matrix products were particularly informative and had a lot of visible fine structure, if one softmax-normalized rows of the left-hand-side matrix and columns of the right-hand-side matrix before taking the product. The images looked slightly toned-down and striped after normalization, but not too different visually. However the products were drastically different. Note that in Transformer models one usually applies softmax only on one side, but this turns out to be insufficient for our visual exploration of matrix products.\r\n\r\nI like the resulting images as visual art, and I think this might point to some interesting novel ways to obtain visual art by mathematical transformations.\r\n\r\nI also hope this might eventually be of help as people try to achieve better understanding and more fine-grained control of our machine learning models.\r\n\r\nThe markdown file commenting the Julia notebook and elaborating on machine learning connections is posted at https://github.com/anhinga/julia-notebooks/blob/main/images-as-matrices/presentation/commentary.md\r\n\r\nAfter this proposal was submitted, I have explored composing matrix multiplications with other image transformations. The resulting compact neural machines produce visually interesting results.\r\n\r\nI have conducted first experiments in solving machine learning problems formulated in terms of those compact machines taking advantage of flexibility of differentiable programming in Julia Flux.\r\n\r\nI have created a repository containing materials relevant to this poster: https://github.com/anhinga/JuliaCon2021-poster", "recording_license": "", "do_not_record": false, "persons": [{"id": 10355, "code": "FT77LL", "public_name": "Mishka (Michael Bukatin)", "biography": "### main theme\r\n\r\nMy main research focus has been to find, study, and develop a **high-level computer programming formalism\r\nallowing to deform programs in a continuous fashion** (just as one can deform recurrent neural networks in a continuous fashion).\r\n\r\nI was trying to approach this problem from various angles: doing research in the mathematics of continuous domains\r\nfor denotational semantics of programming languages, studying theoretical neuroscience, and so on.\r\n\r\nFinally, our research collaboration was starting to see the hints of the possible solution from approximately Fall of 2012,\r\nand the formalism for continuously deformable programs was developed by our research collaborations in 2015-2016. \r\n\r\nThese days I am continuing to focus on studying and experimenting with this formalism and I am hoping that it will\r\neventually stop being a purely research subject and will become a technology.\r\n\r\nI maintain a Web site for this formalism here: https://anhinga.github.io/\r\n\r\nI also maintain a list of open problems and promising research and technological directions and interdisciplinary\r\nconnections related to this formalism: https://www.cs.brandeis.edu/~bukatin/dmm-collaborative-research-agenda.pdf\r\n\r\n### brief timeline\r\n\r\nMy background in software, mathematics, and science goes back to Soviet Union, to machine code, Algol-60, Fortran-4,\r\nand to punched cards; to Pushchino, the Biological Center of the Soviet Academy of Sciences, and to\r\nthe Mathematical class of Moscow High School number 7.\r\n\r\nI started to focus on continuous models of computations in college, then emigrated to USA, worked as\r\na scientific programmer for Alex Rashin at Biosym Technologies doing computational geometry and computational chemistry\r\n(I was the second author on several papers in _The Journal of Physical Chemistry_ and _Biophysical Chemistry_\r\nfrom that period), then did a PhD in Computer Science at Brandeis University focusing of mathematics\r\nof continuous domains for denotational semantics (this is a copy of my 2002 PhD thesis: https://arxiv.org/abs/1512.03868).\r\n\r\nIn parallel, I worked in various places in the software industry. There I had a chance to first touch\r\ndataflow programming, Common Lisp, and actor model of programming. \r\n\r\nThis century I have been working at a geographic software company (ownership of it went through acquisitions, spin-offs,\r\nand such, so one very long employment looks like several shorter ones from a formal viewpoint), \r\nwhile doing research in parallel. My research focus was mostly on theoretical neuroscience for a while,\r\nthen a research collaboration on deep connections between _partial metrics_ and _fuzzy equalities_, \r\nand finally (from approximately Fall of 2012) a research collaboration\r\non deep connections between _partial contradictions_ and _vector semantics of programming languages_ \r\nand, from 2014-2015 on, a series of research collaborations on _neuromophic computations with linear streams_. \r\n\r\nStarting from about 2011 I was gradually moving from just being a lover of computer animation and electronic music to\r\nmy first attempts to make some visual, audio, and audio-visual art of my own, and I am continuing to make new computer art every few months or so.\r\nIt involved playing a bit with MilkDrop 2 for WinAmp, mixing music a bit with Serato DJ,\r\ndoing a lot of animations and a bit of sound work in Processing, doing a tiny bit of that in Clojure,\r\nand finally working a bit with shader-based GLSL animations.\r\n\r\n### 2015-present\r\n\r\n_Linear streams_ are streams for which linear combinations of several streams are defined. If one makes sure that\r\nlinear computations and general (often non-linear) computations are interleaved, then one gets continuously deformable programs which\r\nwe call **Dataflow matrix machines (DMMs)**. Another way to obtain DMMs is to start with recurrent neural networks\r\nand replace streams of numbers with linear streams and allow complicated \"activation functions\"\r\n(that is, transformations of linear streams) with arbitrary arity.\r\n\r\nThis setup also allows these neural machines to have very natural and flexible self-modification facilities.\r\nThere are toy implementations in Processing with mutable matrices, and the reference implementation in Clojure with\r\nimmutable streams of tree-shaped \"flexible-rank tensors\". The reference paper on DMMs is https://arxiv.org/abs/1712.07447\r\n\r\nI hope to create the next application of this formalism in Julia \r\n(both **Julia Flux** and **JAX** are the machine learning frameworks which finally have sufficient flexibility\r\nwe need to take full advantage of the flexibility of DMMs). I started to switch to Julia in the early 2020.\r\nI recently sketched a three-page note outlining my hopes in this sense: https://www.cs.brandeis.edu/~bukatin/towards-practical-dmms.pdf", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9869, "guid": "ada7f121-2107-53c5-b1a5-7353a7894096", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9869-high-performance-tsunami-forecasting", "url": "https://pretalx.com/juliacon2021/talk/WJTAME/", "title": "High Performance Tsunami Forecasting", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "We are developing a particle filter data assimilation package in Julia. The primary use case is forecasting tsunamis using data from a sparse set of observations and a numerical model. The application is designed to run in parallel on multiple nodes of HPC clusters and interface with third-party numerical models. Using Julia has benefited us in many ways, including high performance, fast development, testing, and leveraging open-source libraries.", "description": "Tsunami forecasting has many similarities with weather forecasting. The problem is trying to infer the future state of a large dynamic system from a sparse set of observations. To solve this problem, we are developing a particle filter data assimilation package with researchers from the department of statistical science at University College London. The package is aimed at high parallel performance and can run on UK Tier 2 HPC facilities to quickly produce forecasts using an assimilation of observed data and numerical models. It uses MPI  for distributed parallelism and HDF5 for serialisation.\r\n\r\nWe chose to use Julia because of its attractive combination of high performance and productivity and its active package ecosystem. It is also important for us to write code that scientists, who are more used to scripting languages such as MATLAB and R, can understand and reuse in their future work. At the same time, it is important to us to follow good software development practices and carefully document and test our code. Julia has allowed us to achieve a good balance of these aspects and is well worth considering for future scientific computing projects.\r\n\r\nThe code is public and can be found at https://github.com/Team-RADDISH/ParticleDA.jl", "recording_license": "", "do_not_record": false, "persons": [{"id": 10206, "code": "8DCCQ8", "public_name": "Tuomas Koskela", "biography": "I am a senior research software developer at University College London. My background is in developing plasma physics simulations for supercomputers. I'm interested in a lot of things, often broadly related to physics, energy and computing. \r\n\r\n[website](https://www.ucl.ac.uk/research-it-services/about-rits/people#software)\r\n[github](https://github.com/tkoskela)\r\n[linkedin](https://www.linkedin.com/in/tuomas-koskela-6b8359ba/)", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9756, "guid": "2728bce9-52cc-549a-b4d4-c9daf0baf6af", "logo": "/media/juliacon2021/submissions/DV3UWZ/CTMRG_l5uGNhF.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9756-julia-and-tensor-networks-for-statistical-physics", "url": "https://pretalx.com/juliacon2021/talk/DV3UWZ/", "title": "Julia and Tensor Networks for Statistical Physics", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "In this project we use Julia to solve lattice models of magnetic materials in Statistical Physics. A method based on Tensor Netorks was used - Corner Transfer Matrix Renormalisation Group.\r\nIn the first part of the project, we focused on the 2d Ising Antiferromagnet in a square lattice. Thermodynamic averages of physical quantities such as the magnetisation and free energy were obtained. \r\nThe same method was employed to the case of the 2d Ising Antiferromagnet in a Triangular lattice.", "description": "This project was done by a physics masters student at \u00c9cole Polytechnique F\u00e9derale de Lausanne under the orientation of prof. Fr\u00e9deric Mila and PhD student Jeanne Colbois.\r\nLattice models are prolific in the field of Statistical Physics, as they are simple to state but allow for studying the most important aspects of the behaviour of complex systems, such as critical behaviour and phase transition.\r\nAll the macroscopic properties of a given model can be obtained from the knowledge of its partition function. However, analytic computation of this quantity isn't always feasible, and usually numerical techniques need to be employed. \r\nExamples of such methods include Monte Carlo and Tensor Networks. The main advantage of the Tensor Network formulation is that it exploits the translation symmetry of the model, which allows it to describe the system in the thermodynamic limit.\r\nIn this project we used the Corner Transfer Matrix Renormalisation Group (CTMRG) algorithm, which exploits the properties of the Singular Value Decomposition to find a lower-dimensional representation of the lattice surrounding a site. \r\nThe choice of the Julia programming language was natural as it possessed the two qualities that were most important to me as a developer - fast performance and convenient syntax. The existence of a library specifically meant to deal with tensor networks - ITensors - also played a role in the choice. \r\nThe vast library of numerical libraries mantained by the Julia community, such as KrylovKit.jl and LsqFit.jl also proved to be extremely useful.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10379, "code": "ALDXWX", "public_name": "Afonso Rufino", "biography": "I'm a Portuguese physics student starting his masters at Instituto Superior T\u00e9cnico (Universidade de Lisboa).\r\nThis year I'm an exchange student at \u00c9cole Polytechnique Federale de Lausanne.\r\nBesides my love for physics, I've always been interested in software and programming languages.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9560, "guid": "21213e41-27a6-580c-a5c1-0eab6f909e57", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9560-early-adopters-jumping-the-adoption-chasm-in-a-company", "url": "https://pretalx.com/juliacon2021/talk/TYJXFL/", "title": "Early adopters jumping the adoption chasm in a company", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Follow up on \"The ups and downs of convincing to switch to Julia in a company\" talk from JuliaCon 2020. Ramping up from early adopters and trying to jump the early adopters to wider adoption chasm.\r\nWill be a summary of the last year attracting people inside ASML, convincing managers, fighting against infrastructure needs and informally training people.\r\nI am aiming of having a combined with other people to give their own perspective.", "description": "ASML is company in the Netherlands which is the world leader on photo-lithographic system which are crucial for semi-conductor manufacture. For many years its engineers have been using MATLAB to develop hardware and algorithms that are usually rewritten in C/C++ on the main photo-lithography systems. This is the well known *two-language problem* and for mission critical systems this has been accepted for long time.\r\n\r\nFor several years ASML has been expanding its market to Analytics and Software for process optimization for which the two-language problem seems to be a little less forgiving than for hardware because time to market is a larger driving force. \r\n\r\nFor this Julia seems to be a natural candidate to solve the problem. However as this talk will show it is hard to convince \"normal\" engineers to switch from their trusted tried and truth tools. Moreover, it's even harder to convince them to switch to a relatively unknown/unfamiliar language than a more mainstream like python ... even when it's not the right tool for the job. Which makes things even more difficult is that managers also have a say on this and most think that this is just a fad.\r\n\r\nThis presentation will give an overview of common reactions, comments and attitudes, and hopefully a guide on how to work around them.\r\n\r\nFollow up on last year talk updating on how people have responded regarding Julia as well as technical challenges encountered.", "recording_license": "", "do_not_record": true, "persons": [{"id": 4125, "code": "QCZCDE", "public_name": "Jorge Alberto Vieyra Salas", "biography": "Born in Mexico City. Studied a Bachelors in Chemical Engineering at UNAM. M.Sc. on Materials Science and Engineering at MIT. Studied PhD at TU Eindhoven on Applied Physics.\r\nWorked for Philips Research 1 year.\r\nWorking at ASML for 7 years on algorithms.", "answers": []}, {"id": 12365, "code": "3SFAMU", "public_name": "Evangelos Paradas", "biography": "I am Evangelos Paradas from Thessaloniki, Greece. I am physicist, holding a PhD in Particle Physics. The trip into the algorithms' world, started during my PhD, as I was responsible for a few algorithms of the High Level trigger of the CMS experiment at CERN.\r\nIn this context, the algorithms were written in C++. After a few years I moved to the Netherlands, working at ASML as Algorithm  Deployment architect.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9813, "guid": "dbd4d20c-94e8-5d9f-a32c-9704b39f7fbc", "logo": "/media/juliacon2021/submissions/GJQWXN/schem_fVq2SGO.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9813-arrhenius-jl-a-differentiable-combustion-simulation-package", "url": "https://pretalx.com/juliacon2021/talk/GJQWXN/", "title": "Arrhenius.jl: A Differentiable Combustion Simulation Package", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "In this talk, I will present an open-source Julia package called Arrhenius.jl. It bridges classical physics-based combustion models with Julia's scientific machine learning ecosystems, such as DifferentialEquations.jl, ForwardDiff.jl, and Flux.jl. I will present its applications in combustion model reduction, uncertainty quantification, and chemical kinetic model discovery.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10408, "code": "HMRW37", "public_name": "Weiqi Ji", "biography": "I am a postdoc researcher in the mechanical engineering department at the Massachusetts Institute of Technology. I develop interpretable machine learning for modeling dynamics in thermal fluids and biomedical applications.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9835, "guid": "774c43f6-b2b2-5f4f-97e7-24abb91d22a3", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9835-processing-light-sheet-microscopy-data-using-julia", "url": "https://pretalx.com/juliacon2021/talk/FRTBV8/", "title": "Processing Light-Sheet Microscopy Data Using Julia", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "Light-sheet microscopy is a technique that volumetrically scans fluorescently tagged biological specimens efficiently at high rates of speed. This data consists of three dimensional data collected over time across color channels and multiple views and results in a data flow of tens of gigabytes per second. I will discuss using Julia to meet the near acquisition demands of handling such data including 1) unpacking 12-bit integers, 2) compression, 3) chunking into subvolumes, and 4) storage.", "description": "To handle the high rate of data produced by multiple view light-sheet microscopy requires processing gigabtyes per seconds in order to overcome the limitations of microscope attached storage. Additionally since the data involves six dimensions, three spatial dimensions across time, wavelength, and view, there is a need to efficiently store the data in the form of localized subvolume blocks. I will discuss the experience of using Julia in combination with other tools in C++, Java, and LabView to handle data unpacking, compression, chunking and storage.\r\nMicroscopy data is collected by scientific cameras via frame grabbers which emit frames of 8, 12, or 16-bit unsigned integers depending on the configuration of the experiment. Collecting 12-bit data  is a popular choice since it provides a large dynamic range relative to 8-bit data over thousands of integer values while allowing for relatively fast acquisition and moderate data throughput versus 16-bit data. Since 12-bit data is usually packed and not aligned to byte boundaries, processing the data posses an initial problem that complicates data handling and compression. Successfully addressing this problem allows for biological experiments under the microscope to be extended since the data requires less storage or transfer bandwidth.\r\nJulia\u2019s abstract array interfaces as well as its ability to access low level vector intrinsics through SIMD.jl that allow for effective initial handling of 12-bit integers with the help of the BitIntegers.jl package. This enables the data to be efficiently processed in part or in whole. Also, this provides opportunities to rearrange, or shuffle, the data to prepare it for compression. Through APIs such as TranscodingStreams.jl, Julia code can access a multitude of compression schemes which allow for rapid prototyping. Additionally, Julia\u2019s ability to access native and asynchronous I/O allows for flexible storage through multiple formats which allow for automatic chunking and division into subvolumes. An example of this is the ImarisWriter.jl library produced as part of our efforts.\r\nA key aspect of using Julia in such an environment is it\u2019s ability to interoperate with multiple languages. Many of the tools that we needed to integrate have C or C++ interfaces, and Julia excelled at efficiently calling them without the need of much effort. Additionally, the ability to embed Julia in other applications such as LabView makes it easy to integrate the developed Julia code with existing solutions. Finally, much of the tooling for downstream image analysis exists in Java so the ability to use JavaCall.jl to integrate the near acquisition and image processing is another critical feature.\r\nOverall, the experience of using Julia for near acquisition microscopy tasks has been successful and rewarding. We\u2019ve been able to use Julia to address complex tasks in real time in order to meet demanding needs, and this is greatly facilitated by Julia\u2019s flexibility of both high-level abstraction and low level efficient code compilation. Ultimately, it has been the ease of use factor which has allowed my colleagues and I to adopt Julia as a critical technology in our workflow.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10421, "code": "USMVVE", "public_name": "Mark Kittisopikul, Ph.D.", "biography": "Mark Kittisopikul is a postdoctoral Scientific Computing Associate at the Janelia Research Campus of the Howard Hughes Medical Institute working with the Scientific Computing team to support the computational needs of the lab of Philipp Keller for next-generation light-sheet microscopy.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9649, "guid": "cc95f236-bb85-51a8-9ea2-c82e85777c14", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9649-build-your-own-fast-multi-user-jupyter-and-pluto-server", "url": "https://pretalx.com/juliacon2021/talk/EJASMD/", "title": "Build your own fast, multi-user Jupyter and Pluto server", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "The Jupyter and Julia communities provide all the tools required to set up a custom multi-user notebook server, configured exactly as needed for e.g. students to do coursework in Julia without the hassle of maintaining their own individual installations. In this short tutorial you will learn how to set up such a server, building up from a clean Debian installation towards a fully configured JupyterHub capable of running Jupyter and Pluto notebooks with a custom system image for speed.", "description": "Using [JupyterHub](https://jupyterhub.readthedocs.io/en/stable/), it is possible to make Jupyter, JupyterLab and even Pluto available to multiple users on the same server. The system supports a wide range of options for authentication and notebook launching. We will build on our experience of running the JupyterHub server at the Royal Military Academy to show how to configure a server that can run Julia 1.6 JupyterLab and Pluto notebooks. We will go through the following steps:\r\n\r\n1. Set up JupyterHub and authentication, including a discussion of some of the options\r\n2. Discussion of the launching options, which include distributing the system over multiple servers or a cluster\r\n3. Set up  Docker for the actual notebooks and Pluto\r\n4. Build a custom Docker image with the tools and packages required for your own problems\r\n5. Add Pluto to the launcher\r\n6. Build a system image integrated into the Docker image, for shorter startup times\r\n\r\nWe will end with a small demo of the system as it runs at the Royal Military Academy", "recording_license": "", "do_not_record": false, "persons": [{"id": 4225, "code": "H3TNC7", "public_name": "Bart Janssens", "biography": "Bart Janssens is a military associate professor at the mechanics department of the [Royal Military Academy](https://www.rma.ac.be), with a passion for computer graphics, high performance computing and fluid mechanics. For performance reasons, he used C++ until being introduced to Julia. His current work focuses on making scientific C++ libraries such as Trilinos interoperate with Julia, in order to port existing CFD code to Julia. He also uses JupyterLab and Pluto in his engineering (thermodynamics and gas turbines mostly) courses.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9883, "guid": "58c3fcca-73e3-5126-a022-b85f9dec9442", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9883-monads-in-julia-typeclasses-jl-and-datatypesbasic-jl", "url": "https://pretalx.com/juliacon2021/talk/UQGV9C/", "title": "Monads in Julia: TypeClasses.jl and DataTypesBasic.jl", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Functional programming has a lot of benefits. Within julia many know about immutability, however who has used monads? Monads capsulate context or side-effects and are one of the corner stones of classical functional programming. Take a look what monads are and how DataTypesBasic.jl and TypeClasses.jl implemented them in Julia.", "description": "Monads capsulate context or side-effects and are one of the corner stones of classical functional programming. It turns out that Julia with its Union types, Hierarchy and multiple dispatch allows for many ways to implement these concepts. After several iterations I converged at one representation which is both quite minimal and very powerful.\r\n\r\nThis talk will give you an introduction to monads, especially to Option, Try, Either, and ContextManager, and how to implement them in julia. We will take a look at both DataTypesBasic.jl https://github.com/JuliaFunctional/DataTypesBasic.jl and TypeClasses.jl https://github.com/JuliaFunctional/TypeClasses.jl, two packages of mine which implement some standard monads for Julia.", "recording_license": "", "do_not_record": false, "persons": [{"id": 4390, "code": "MJPZGQ", "public_name": "Stephan Sahm", "biography": "Stephan Sahm is Senior Data Science and ML Engineering Consultant. Having programmed in Java, Matlab, Python, R, Scala and Julia he appreciates the combination of simplicity and speed which the Julia language brings to Data Science. With master degree in math/stochastics and cognitive science together with 5 years industry experience he can help you bring your favourite Data idea into production.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9662, "guid": "46b6681d-13d4-57fd-b0b7-ea4aed4701f6", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9662-julia-as-a-framework-for-a-theoretical-physics-phd", "url": "https://pretalx.com/juliacon2021/talk/Y7ENBL/", "title": "Julia as a framework for a Theoretical Physics PhD", "subtitle": "", "track": null, "type": "Experience", "language": "en", "abstract": "I started used Julia as a backup language, soon became my first and unique programming language for doing my numerical checks of my theoretical findings. My theoretical physics PhD gone easy after I known about Julia and their wonderfulness.", "description": "I relate my experience as I changed to Julia in the middle of my PhD work, an action I don\u2019t regret at all.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9210, "code": "EEVZ3F", "public_name": "Alejandro R. Urz\u00faa", "biography": "I'm a _theoretical physicist_ who is slowly evolved in an _algorithm researcher_. I specialize in mathematical methods in optics and mechanics, both classical and quantum paradigms. I'm currently signed at National Institute of Astrophysics, Optics and Electronics.\r\n\r\nMy current research projects are: \r\n\r\n1. Energy analysis of harmonic oscillators arrays \r\n2. Phase transitions under group theoretical approximation\r\n3. Quantum state tomography and unitary transformations\r\n4. Epistemological and ontological problems in quantum mechanics", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9807, "guid": "3e609af2-4913-5a69-a57e-ce78b27840c0", "logo": "", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9807-non-parametric-methods-for-mixed-effects-models-of-eeg-data", "url": "https://pretalx.com/juliacon2021/talk/A3FSL3/", "title": "Non-parametric Methods for Mixed-Effects Models of EEG Data", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "Permutation-based testing has become exceptionally popular in the analysis of neuroimaging data, but so far has depended on two-stage analyses to handle repeated measures data in order to be computationally tractable. We introduce MixedModelsPermutations to perform fast permutation-based inference on mixed models. Using mixed models instead of a two-stage approach enables properly representing crossed and nested designs, explicitly modelling multiple sources of variability and unbalanced designs", "description": "Permutation-based testing has become exceptionally popular in the analysis of neuroimaging data, but so far has depended on two-stage analyses to handle repeated measures data in order to be computationally tractable. \r\nRelying on a two-stage procedure is, however, suboptimal because it prohibits modelling more than a single random effect (and so blocks proper analysis of designs with crossed or nested random effects) and is more sensitive to issues of balance between individual groups.\r\nThis precluded the wide adoption of MixedModels for neuroimaging, where variability between stimuli (item-effects) are very common.\r\nWith MixedModelsPermutations, we show that fast permutation-based inference with a single-stage approach based on mixed models is possible, thus opening the door for taking advantage of both permutation-based inference and mixed-effects models.\r\nSeveral theoretical problems remain, such as the ideal permutation regime in a hierarchical context, but the speed of Julia allows for testing proposed solutions in a way not previously possible.", "recording_license": "", "do_not_record": false, "persons": [{"id": 3828, "code": "3EFERC", "public_name": "Phillip Alday", "biography": "Phillip was a struggling mathematician, then a linguist and now a neuroscientist, but always a hacker.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9650, "guid": "f3808b81-3d4e-5efa-b113-6eebabebb90a", "logo": "/media/juliacon2021/submissions/XU9DTB/ProtoSyn_logo_68D7S86.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9650-protosyn-a-julia-based-platform-for-molecular-modelling", "url": "https://pretalx.com/juliacon2021/talk/XU9DTB/", "title": "ProtoSyn: a Julia based platform for molecular modelling", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "ProtoSyn aims to be a simple and intuitive package for molecular manipulation with an emphasis on peptide design and simulation. The main goal of ProtoSyn is to be a basis on top of which new tools and protocols can be experimented and prototyped. Taking advantage of Julia\u2019s environment, ProtoSyn has been built with emergent technologies in mind, such as distributed computing, GPU and SIMD acceleration and machine learning models usage. Version 1.0 is scheduled to be released in the end of 2021.", "description": "The rational placement of aminoacids in a sequence directly correlates to the 3D structure of the peptide, once folded, which, in turn, dictates the interactions with the environment and therefore the function of the peptide. Being able to design new peptides for specific functions would unlock the potential of unknown conformations not yet explored by nature, with applications in medical fields, agriculture, biological remediation, enzymatic synthesis, among others. \r\n\r\nThis was traditionally explored by random blind mutagenesis which is an expensive and time intensive experimental practise. With the evolution of computational power over the last couple of decades, computational design of small proteins has become the focus of scientific breakthroughs. Using computer simulations saves precious time and monetary costs of experiments, focusing efforts on simulated prototypes that have shown promising results. As such, multiple software solutions have been proposed over the years. An example would be Rosetta (and its Python wrap, PyRosetta), which has been indisputably invaluable as a platform for molecular manipulation and peptide design.\r\nHowever, as it happens with so many scientific-purposed software packages, Rosetta has fallen into the two-language problem, where the core of the simulation code is written in C with a more user-friendly wrap in Python that exposes some of the functionality. This has gravelly impaired the community ability to upgrade and modify this package, as well as imposing a steep learning curve to non-specialized would-be-users.\r\n\r\nProtoSyn, empowered by the Julia language ecosystem, aims to put forward a simple and easy to use platform for molecular manipulation and peptide design. A Julia-based solution to this challenge would naturally benefit from the native features of the language, such as easy parallelization and distributed computing, GPU acceleration and machine learning tools, among others. A list of current features of ProtoSyn includes: the removal, addition and mutation of an indiscriminate number of aminoacids, rigid body docking of ligands, Monte-Carlo and steepest descent drivers and rotamer library search, among others. As a whole, this list of features constitutes the core of ProtoSyn: a playground for the development and prototyping of new sequences and structures of proteins. A set of extra features has been identified and initial support for them has been prepared. These include branched structures, user interface with a UI and even molecular dynamic drivers, but further development in these modules is needed.\r\n\r\nFor the steepest descent and Monte-Carlo simulations, a critical component of any molecular manipulation software is the definition of an energy function: a fitness evaluating function that measures how realistic a given molecular structure is. \u201cTorchANI\u201d is a machine learning model trained on DFT results, providing realistic results with up to 10e6 speedup in computation times, and has been developed in Python by a team of researchers from Florida. Using PyCall package, this external Python package is loaded and used in Julia as the core piece of the ProtoSyn\u2019s energy function. Other components include the Caterpillar Solvation Energy as well as a Contact Map restraint.\r\n\r\nOverall, ProtoSyn is able to provide an easy to use, intuitive and robust experience in molecular manipulation, allowing even non-specialized users access to basic simulation tools that can greatly reduce prototyping costs and experimental time. ProtoSyn is also fast, being accelerated by both GPU and SIMD technologies, and easily employing distributed computing protocols allows us to speed simulations even further. In conclusion, the first development cycle of ProtoSyn is hopefully coming to a close, with final tests, documentation, examples and tutorials being prepared. The open-source code in finally ready for the community to check and improve upon.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10289, "code": "YK78JV", "public_name": "Jos\u00e9 Pereira", "biography": "I am a PhD Student in Universidade de Aveiro, Portugal, currently pursuing Biochemistry with a twist. Over the past 5 years I've directed my research efforts towards Computational Chemistry, more specifically, for the development of scientific software. I started learning Julia 3 or 4 years ago, and have since grown more and more in love with its syntax and ecosystem. Currently, my main PhD project is the development of ProtoSyn, a simple and intuitive package for the molecular manipulation and simulation of peptides.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9842, "guid": "b406ac30-cb91-56dc-a6d6-8b9959719b37", "logo": "/media/juliacon2021/submissions/ADKMPS/ICESAT_BeautyShot_Laser_b9W7NLe.png", "date": "2021-07-30T17:15:00+00:00", "start": "17:15", "duration": "00:03", "room": "BoF/Mini Track", "slug": "juliacon2021-9842-spacelidar-jl-processing-icesat-2-gedi-satellite-lidar-data", "url": "https://pretalx.com/juliacon2021/talk/ADKMPS/", "title": "SpaceLiDAR.jl: Processing ICESat-2 & GEDI satellite LiDAR data", "subtitle": "", "track": null, "type": "Virtual Poster", "language": "en", "abstract": "We present the first toolbox for both [ICESat-2](https://icesat-2.gsfc.nasa.gov/) and [GEDI](https://gedi.umd.edu/) satellite LiDAR data as a Julia package.\r\nICESat-2 and GEDI are two NASA missions launched at the end of 2018. \r\nThe GEDI full waveform LiDAR is attached to the ISS and investigates vertical forest structure.\r\nICESat-2's ATLAS instrument is a discrete LiDAR system in a polar orbit and investigates ice sheets.", "description": "[SpaceLiDAR.jl](https://github.com/evetion/SpaceLiDAR.jl/) can search for, download, convert and analyze datasets produced by both missions, specifically the L2A product of GEDI and the ATL03 and ATL08 of ICESat-2, which are the first geolocated products.\r\nFurthermore, it can derive points, linestrings, interpolate rasters and store them, making use of the Julia ecosystem, including the recent [GeoDataFrames.jl](https://github.com/evetion/GeoDataFrames.jl), a spatially enabled Tables interface. This package and Julia in general enable us to do our research into global elevation models.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9652, "code": "Q33DZA", "public_name": "Maarten Pronk", "biography": "GeoData Scientist at [Deltares](https://www.deltares.nl/en/). Github: [@evetion](https://github.com/evetion/)", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9853, "guid": "b50b0e67-cb35-5519-bcce-9fde54010b0d", "logo": "", "date": "2021-07-30T19:00:00+00:00", "start": "19:00", "duration": "01:30", "room": "BoF/Mini Track", "slug": "juliacon2021-9853-discussing-gender-diversity-in-the-julia-community", "url": "https://pretalx.com/juliacon2021/talk/RAFSMK/", "title": "Discussing Gender Diversity in the Julia Community", "subtitle": "", "track": null, "type": "Birds of Feather", "language": "en", "abstract": "Julia Gender Inclusive is an initiative that came to life from a focus group that has been working on diversity in the Julia community for the last year. We are a group of people whose gender is underrepresented in the community and aim at providing a supportive space for all gender minorities in the Julia community. Through a BoF session we wish to discuss what we are doing and what we hope to do in the future with other people whose gender is underrepresented or allies willing to support us.", "description": "The objective of this talk is to find more people who feel their gender is underrepresented within the Julia community or want to support people who feel so. We aim at creating a safe and fruitful discussion about gender diversity and new actions we can take from Julia Gender Inclusive.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10443, "code": "YK9PFQ", "public_name": "Laura Ventosa", "biography": "Mathematics undergraduate student and Economics graduate. I love playing computational statistics using Julia.", "answers": []}, {"id": 10385, "code": "E3TDSM", "public_name": "Kim Louisa Auth", "biography": "I am a PhD student in Computational Mechanics at Chalmers University of Technology (Sweden), where I use Julia for doing Finite Element simulations.", "answers": []}, {"id": 10333, "code": "CFLQJP", "public_name": "Xuan (Tan Zhi Xuan)", "biography": "Xuan (Sh-YEN, IPA: \u0255\u0265\u025bn) is a PhD student at MIT in the Computational Cognitive Science and Probabilistic Computing research groups. Their current research focuses on inferring the hidden structure of human motivations by modeling agents as probabilistic programs, in the hope of aligning AI with the higher-order goals, values, and principles that humans strive (in part) to live by.", "answers": []}], "links": [], "attachments": [], "answers": []}], "JuMP Track": [{"id": 10870, "guid": "01323d96-b47c-5dac-af71-fd72be0c8753", "logo": "", "date": "2021-07-30T12:30:00+00:00", "start": "12:30", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-10870-modelling-australia-s-national-electricity-market-with-jump", "url": "https://pretalx.com/juliacon2021/talk/TMXKDM/", "title": "Modelling Australia's National Electricity Market with JuMP", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "I will discuss challenges, techniques and design choices in developing a flexible JuMP-based modelling workflow as a decision tool for a major Australian transmission network operator's development planning across diverse scenarios.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 11324, "code": "SHJAQB", "public_name": "James D Foster", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9711, "guid": "7cf1dd8c-00b7-571c-ac78-8537b4b60c80", "logo": "/media/juliacon2021/submissions/EUVCJY/schriftzug_plus_logo_XiOFZKx.png", "date": "2021-07-30T12:40:00+00:00", "start": "12:40", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-9711-anymod-jl-a-julia-package-for-creating-energy-system-models", "url": "https://pretalx.com/juliacon2021/talk/EUVCJY/", "title": "AnyMOD.jl: A Julia package for creating energy system models", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "AnyMOD.jl is a Julia framework for creating large-scale energy system models. It applies a novel graph-based approach that was developed to address the challenges in modeling high levels of intermittent generation and sectoral integration. To enable modelers to work more efficiently, the framework provides features that help to visualize results, streamline the read-in of input data, and rescale optimization problems to increase solver performance.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 10347, "code": "DXRPDQ", "public_name": "Leonard G\u00f6ke", "biography": "Research Associate and PhD candidate at TU Berlin, open-science and macro-energy system modeling, https://github.com/leonardgoeke", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10876, "guid": "4a82241c-5035-5272-8f73-6cd601ad8769", "logo": "", "date": "2021-07-30T12:50:00+00:00", "start": "12:50", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-10876-power-market-tool-pomato-", "url": "https://pretalx.com/juliacon2021/talk/9SVMZ3/", "title": "Power Market Tool (POMATO)", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "In this talk, we present the open-source Power Market Tool (POMATO), which has been designed to study capacity allocation and congestion management policies of zonal electricity markets, especially flow-based market coupling.", "description": "Europe's increase in electricity production from renewable energy resources (RES) in combination with a significant decline of conventional generation capacity has spawned political and academic interest in the transmission system's ability to accommodate this transition. Central to this discussion is the efficiency of capacity allocation and congestion management (CACM) policies between and within electricity market areas that are interconnected by shared and synchronized transmission infrastructure. To facilitate unrestricted cross-border electricity trading in the presence of finite physical transmission capacity, European system and electricity market operator inaugurated flow-based market coupling (FBMC).\r\n\r\nFBMC is a coordinated multi-stage process that requires detailed forecasts and network models, which are typically not or only partially disclosed by the system operators. Academic publications that synthesize FBMC in model frameworks agree on a three step process \u2013 D-2 (base case), D-1 (day-ahead) and D-0 (redispatch) \u2013 but differ greatly in some core assumptions. Further, FBMC effectiveness for a future renewable-dominant generation mix is typically overlooked in the current literature. \r\n\r\nThe open-source Power Market Tool (POMATO) has been designed to study CACM policies of zonal electricity markets, especially flow-based market coupling (FBMC). For this purpose, POMATO implements methods for the analysis of simultaneous zonal market clearing, nodal (N-k secure) power flow computation for capacity allocation, and multi-stage market clearing with adaptive grid representation and redispatch. Additionally, POMATO includes risk-aware optimal power flow via chance constraints to internalize forecast uncertainty during the market clearing process. All optimization features rely on Julia/JuMP, leveraging its accessibility, computational performance, and solver interfaces. The Julia Code is embedded in a Python front-end, providing flexible and easily maintainable data processing and user interaction features.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11330, "code": "9TJLXF", "public_name": "Richard Weinhold", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9217, "guid": "19d14351-f0f5-5343-875d-4899b4c25ea0", "logo": "/media/juliacon2021/submissions/XGCJBA/InfrastructureModels_ymZnRCd.png", "date": "2021-07-30T13:00:00+00:00", "start": "13:00", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-9217-a-brief-introduction-to-infrastructuremodels", "url": "https://pretalx.com/juliacon2021/talk/XGCJBA/", "title": "A Brief Introduction to InfrastructureModels", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "The design, operation and resilience of critical infrastructure networks plays a foundational role in modern society. One open question is how artificial intelligence can provide decision support to maintain and adapt critical infrastructures to a changing world. This talk provides an overview of InfrastructureModels, a software foundation developed at Los Alamos National Laboratory for critical infrastructures analysis and optimization to help explore this question.", "description": "This talk will begin by motivating the need for optimization of the design and operations of critical infrastructure networks and discuss some of the challenges facing future infrastructure systems. It will then highlight why Julia and JuMP provide an ideal foundation for to building critical infrastructure analysis capabilities. The talk will finish with an overview of the design and use of Los Alamos National Laboratory's InfrastructureModels packages using optimization of electric power transmission networks as a specific example.", "recording_license": "", "do_not_record": false, "persons": [{"id": 9513, "code": "DNAPAH", "public_name": "Carleton Coffrin", "biography": "Dr. Carleton Coffrin is a staff scientist at Los Alamos National Laboratory in the Advanced Network Science Initiative, an interdisciplinary team that investigates the application of emerging optimization and machine learning methods to problems in critical infrastructure systems.  Dr. Coffrin\u2019s work focuses on developing novel optimization methods for network design, operation, and restoration for power networks.  His work on power system optimization has been recognized by the IEEE PES 2014 Optimal Power Flow Competition, the ARPA-e 2020 Grid Optimization Competition and Los Alamos National Laboratory's Early Career Researcher award.  Dr. Coffrin is also exploring how novel computing devices, such as quantum computers and memristor networks, can improve the next generation of optimization algorithms.  Dr. Coffrin received his Ph.D. in Computer Science from Brown University in 2012, under the supervision of Pascal Van Hentenryck.", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10871, "guid": "a4c043c8-d2a2-5f6e-ba7d-0237f3faeeef", "logo": "", "date": "2021-07-30T13:30:00+00:00", "start": "13:30", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10871-unitcommitment-jl-security-constrained-unit-commitment-in-jump", "url": "https://pretalx.com/juliacon2021/talk/XNVLKH/", "title": "UnitCommitment.jl: Security-Constrained Unit Commitment in JuMP", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In this talk, we introduce UnitCommitment.jl, an open-source Julia/JuMP optimization package which aims to eliminate some of the roadblocks researchers typically face when developing and evaluating new solution methods for the Security-Constrained Unit Commitment (SCUC) problem.", "description": "The Security-Constrained Unit Commitment (SCUC) problem is one of the most fundamental and challenging problems in power systems optimization, being solved daily by Independent System Operators (ISOs) to clear the day-ahead electricity markets. The package provides: (i) an extensible and fully-documented JSON-based data specification format for SCUC, developed in collaboration with ISOs, which can help researchers to share data sets across institutions; (ii) a diverse collection of large-scale benchmark instances, collected from the literature, converted into a common data format, and extended using data-driven methods make them more challenging and realistic; (iii) a Julia/JuMP implementation of state-of-the-art Mixed-Integer Linear Programming formulations and solution methods for the problem; and (iv) a suite of automated benchmark scripts to accurately evaluate the performance impact of newly proposed methods. The package is being developed as part of the \"IEEE Task Force on Solving Large Scale Optimization Problems in Electricity Market and Power System Application\".", "recording_license": "", "do_not_record": false, "persons": [{"id": 11325, "code": "MF33DM", "public_name": "Alinson Santos Xavier", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10875, "guid": "8f720ee1-7c67-57e4-8dd9-c50cc2531c84", "logo": "", "date": "2021-07-30T19:00:00+00:00", "start": "19:00", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-10875-linear-programming-by-first-order-methods", "url": "https://pretalx.com/juliacon2021/talk/ANYQTY/", "title": "Linear programming by first-order methods", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "We present PDLP, a practical first-order method for linear programming (LP) that can solve to the high levels of accuracy that are expected in traditional LP applications. In addition, it can scale to very large problems because its core operation is matrix-vector multiplications.", "description": "PDLP is derived by applying the primal-dual hybrid gradient (PDHG) method, popularized by Chambolle and Pock (2011), to a saddle-point formulation of LP. PDLP enhances PDHG for LP by combining several new techniques with older tricks from the literature; the enhancements include diagonal preconditioning, presolving, adaptive step sizes, and adaptive restarting. PDLP compares favorably with SCS on medium-sized instances when solving both to moderate and high accuracy. Furthermore, we highlight standard benchmark instances and a large-scale application (PageRank) where our open-source prototype of PDLP outperforms a commercial LP solver. The prototype of PDLP is written in Julia and available at https://github.com/google-research/FirstOrderLp.jl.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11329, "code": "UYK3EM", "public_name": "Miles Lubin", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10868, "guid": "a8f73d0e-9d95-5ea8-9c33-3ff29e65de89", "logo": "", "date": "2021-07-30T19:30:00+00:00", "start": "19:30", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-10868-cerberus-a-solver-for-mixed-integer-programs-with-disjunctions", "url": "https://pretalx.com/juliacon2021/talk/REKLVV/", "title": "Cerberus: A solver for mixed-integer programs with disjunctions", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "Disjunctive programming (DP) is a powerful framework for modeling complex logic in optimization problems. In this talk, we present Cerberus, a prototype MIP solver that treats disjunctive constraints as first-class objects.", "description": "Typically, DP problems are reformulated as mixed-integer programming (MIP) problems, and then passed to a MIP solver. Crucially, the MIP solver only receives this \"flattened\" MIP reformulation, and not the original, rich DP structure. We discuss how this structural information can be used within a LP-based branch-and-cut algorithm for dynamic reformulation and domain propagation without breaking incremental LP solves, a crucial ingredient for the success of modern solvers. We focus in particular on how the JuMP ecosystem facilitates the rapid development of such a solver which is heavily dependent on advanced functionality from the both the underlying solvers and the modeling interface.", "recording_license": "", "do_not_record": false, "persons": [{"id": 11322, "code": "X3VPLE", "public_name": "Joey Huchette", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 10980, "guid": "2868bf65-b4d4-52ef-a692-2cd0bd12ffbb", "logo": "", "date": "2021-07-30T19:40:00+00:00", "start": "19:40", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-10980-highs", "url": "https://pretalx.com/juliacon2021/talk/FHWUR9/", "title": "HiGHS", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "In this talk we present HiGHS, a suite of high performance open source optimization solvers, written in C++. HiGHS has simplex and interior point solvers for LP, and MIP and QP solvers. HiGHS can be called from Julia via the HiGHS.jl package.", "description": "", "recording_license": "", "do_not_record": false, "persons": [{"id": 11364, "code": "TMSADH", "public_name": "Ivet Galabova", "biography": null, "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9803, "guid": "c007be63-231d-56a0-9094-a3defb514f9a", "logo": "", "date": "2021-07-30T19:50:00+00:00", "start": "19:50", "duration": "00:10", "room": "JuMP Track", "slug": "juliacon2021-9803-voptsolver-an-ecosystem-for-multi-objective-linear-optimization", "url": "https://pretalx.com/juliacon2021/talk/TP88SL/", "title": "vOptSolver: an ecosystem for multi-objective linear optimization", "subtitle": "", "track": null, "type": "Lightning talk", "language": "en", "abstract": "vOptSolver is an open source ecosystem written in the Julia language, for modeling and solving multi-objective linear optimization problems (mixed integer problems, continuous problems, integer problems, and combinatorial problems). Currently vOptSolver is composed of two independant packages named vOptGeneric.jl and vOptSpecific.jl integrated and registered as Julia packages since 2017. The source codes, examples, documentation and tutorial are available at https://github.com/vOptSolver.", "description": "vOptSolver is aimed to be a software for scientifics and practionners. It has been conceived to be intuitive for various profile of users (mathematicians, informaticians, and engineers), corresponding to needs encountered in research and development (open-source codes available for the design of new algorithms), decision-making (ready-to-use methods and algorithms for solving optimization problems), and education (environment for teachning and practicing the theories and algorithms).\r\n\r\nThe optimization problem to solve is built in formulating a model with the algebraic modeling language JuMP, extended to support multi-objective models, for non-structured optimization problems, or in calling the corresponding API for structured optimization problems. The problem data and the optimization results are set on and handled by the datastructures and functionalities of Julia. \r\n\r\nvOptSolver integrates several generic and specific algorithms of the literature for computing the set of exact non-dominated points. It returns also the efficient solutions corresponding to this set. The generic algorithms make use of a MIP solver, while specific algorithms call problem-dedicated algorithms.\r\n\r\nReferences :\r\n\r\nI. Dunning, J. Huchette, M. Lubin, JuMP: A Modeling Language for Mathematical Optimization, SIAM Review 59 (2) (2017) 295\u2013320.\r\n\r\nB. Legat, O. Dowson, J. D. Garcia, M. Lubin, MathOptInterface: a data structure for mathematical optimization problems (2020). arXiv:2002.03447\r\n\r\nX. Gandibleux, G. Soleilhac, A. Przybylski, S. Ruzika, vOptSolver: an open source software environment for multiobjective mathematical optimization, IFORS2017: 21st Conference of the International Federation of Operational Research Societies. July 17-21, 2017. Quebec City (Canada). (2017).", "recording_license": "", "do_not_record": false, "persons": [{"id": 10404, "code": "A3VNSX", "public_name": "Xavier Gandibleux", "biography": "Full Professor in Operations Research and Computer Science, Universit\u00e9 de Nantes (France).", "answers": []}], "links": [], "attachments": [], "answers": []}, {"id": 9778, "guid": "0557b7a6-b14a-5571-90ed-a4bee91f14a4", "logo": "", "date": "2021-07-30T20:00:00+00:00", "start": "20:00", "duration": "00:30", "room": "JuMP Track", "slug": "juliacon2021-9778-a-derivative-free-local-optimizer-for-multi-objective-problems", "url": "https://pretalx.com/juliacon2021/talk/Z8AJ9J/", "title": "A Derivative-Free Local Optimizer for Multi-Objective Problems", "subtitle": "", "track": null, "type": "Talk", "language": "en", "abstract": "In real-world applications, optimization problems might arise where there is more than one objective.\r\nAdditionally, some objectives could be computationally expensive to evaluate, with no gradient information available.\r\nI present a derivative-free local optimizer (written in Julia) aimed at such problems. It employs a trust-region strategy and local surrogate models (e.g., polynomials or radial basis function models) to save function evaluations.", "description": "I will revisit the basic concepts of multi-objective optimization and introduce the notion of Pareto optimality and Pareto criticality. Based on this idea, the steepest descent direction for multi-objective problems (MOPs) is derived. When used in conjunction with a trust region strategy, the steepest descent direction can be used to generate iterates converging to first-order critical points.\r\nBesides talking about the mathematical background, I want to describe how local surrogate models are constructed and how we use other available packages (JuMP, NLopt, DynamicPolynomials etc.) in our implementation.\r\nMoreover, I will show the results of a few numerical experiments proving the efficiency of the approach and talk a bit about how the local solver could be embedded in a global(ish) framework.", "recording_license": "", "do_not_record": false, "persons": [{"id": 10389, "code": "W7Q33Z", "public_name": "Manuel Berkemeier", "biography": "PhD student at Paderborn University. My main research interest lies in multiobjective (non-linear) optimization.", "answers": []}], "links": [], "attachments": [], "answers": []}]}}]}}}